
/*!
	how many to draw? that's gonna be a problem. i'm gonna have to calculate first and then check the tree for the names visible.
*/

/*!
	deal with non-ascii.
*/

/*!
	keep only executables? that's a little more complex, and therefore slow, than it should be.
*/

/*!
	consider different roots for each directory in path.
*/

/*!
	when reading text live, check if the text is ascii. if it isn't, change a flag. change a flag on backspace, too.
*/



























/*! microlauncher.cold

MIT License

Copyright (C) 2024 Stefanos "Steven" Tsakiris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

/*!includes:{*/
	#define _DEFAULT_SOURCE
	#include <dirent.h>
	#undef  _DEFAULT_SOURCE
	#include <limits.h>
	#include <locale.h>
	#include <pthread.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <signal.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/stat.h>
	#include <xcb/randr.h>
	#include <xcb/xcb.h>
	#include <xcb/xcbext.h>
	#include <X11/Xlib.h>
	#include <X11/Xlib-xcb.h>
	#include <X11/Xlocale.h>
	#include "cold/cold.hold"
/*!}*/

/*!defines:{*/
	#define DEBUG /*---------------------------------*/ (true)

	#define PROGRAM_NAME /*--------------------------*/ "microlauncher"

	#define PTHREAD_CREATE_SUCCESS /*----------------*/ (0)
	#define PTHREAD_SETCANCELSTATE_SUCCESS /*--------*/ (0)
	#define PTHREAD_SETCANCELTYPE_SUCCESS /*---------*/ (0)
	#define PTHREAD_MUTEXATTR_INIT_SUCCESS /*--------*/ (0)
	#define PTHREAD_MUTEXATTR_SETPSHARED_SUCCESS /*--*/ (0)
	#define PTHREAD_MUTEXATTR_DESTROY_SUCCESS /*-----*/ (0)
	#define PTHREAD_MUTEX_INIT_SUCCESS /*------------*/ (0)
	#define PTHREAD_MUTEX_LOCK_SUCCESS /*------------*/ (0)
	#define PTHREAD_MUTEX_TRYLOCK_SUCCESS /*---------*/ (0)
	#define PTHREAD_MUTEX_UNLOCK_SUCCESS /*----------*/ (0)
	#define PTHREAD_MUTEX_DESTROY_SUCCESS /*---------*/ (0)
	#define PTHREAD_CONDATTR_INIT_SUCCESS /*---------*/ (0)
	#define PTHREAD_CONDATTR_SETPSHARED_SUCCESS /*---*/ (0)
	#define PTHREAD_CONDATTR_DESTROY_SUCCESS /*------*/ (0)
	#define PTHREAD_COND_INIT_SUCCESS /*-------------*/ (0)
	#define PTHREAD_COND_WAIT_SUCCESS /*-------------*/ (0)
	#define PTHREAD_COND_TIMEDWAIT_SUCCESS /*--------*/ (0)
	#define PTHREAD_COND_SIGNAL_SUCCESS /*-----------*/ (0)
	#define PTHREAD_COND_BROADCAST_SUCCESS /*--------*/ (0)
	#define PTHREAD_COND_DESTROY_SUCCESS /*----------*/ (0)
	#define PTHREAD_RWLOCKATTR_INIT_SUCCESS /*-------*/ (0)
	#define PTHREAD_RWLOCKATTR_SETKIND_NP_SUCCESS /*-*/ (0)
	#define PTHREAD_RWLOCKATTR_DESTROY_SUCCESS /*----*/ (0)
	#define PTHREAD_RWLOCK_INIT_SUCCESS /*-----------*/ (0)
	#define PTHREAD_RWLOCK_WRLOCK_SUCCESS /*---------*/ (0)
	#define PTHREAD_RWLOCK_RDLOCK_SUCCESS /*---------*/ (0)
	#define PTHREAD_RWLOCK_UNLOCK_SUCCESS /*---------*/ (0)
	#define PTHREAD_RWLOCK_DESTROY_SUCCESS /*--------*/ (0)
	#define PTHREAD_JOIN_SUCCESS /*------------------*/ (0)

	#define GETHOSTNAME_SUCCESS /*-------------------*/ (0)

	#define _STRING_NODE_CHILDREN_AMOUNT /*----------*/ (14)
	#define STRING_NODE_CHILDREN_AMOUNT /*-----------*/ (_STRING_NODE_CHILDREN_AMOUNT > 28? 28 : _STRING_NODE_CHILDREN_AMOUNT)
	#define SHORTCUT_CODE_AMOUNT /*------------------*/ (256)

	#define DEFAULT_OUTPUT_STREAM /*-----------------*/ (stdout)
	#define DEFAULT_ERROR_STREAM /*------------------*/ (stderr)

	#define MESSAGE_START /*-------------------------*/ ("\x1b[1m")
	#define MESSAGE_FATAL /*-------------------------*/ ("\x1b[91m")
	#define MESSAGE_ERROR /*-------------------------*/ ("\x1b[33m")
	#define MESSAGE_EVENT /*-------------------------*/ ("\x1b[32m")
	#define MESSAGE_END /*---------------------------*/ ("\x1b[m")

	#define NONE_ARGUMENT /*-------------------------*/ (0)
	#define UNRECOGNIZED_ARGUMENT /*-----------------*/ (1)
	#define HELP_ARGUMENT /*-------------------------*/ (2)
	#define STDOUT_ARGUMENT /*-----------------------*/ (3)
	#define STDERR_ARGUMENT /*-----------------------*/ (4)
	#define CONFIG_ARGUMENT /*-----------------------*/ (5)
	#define ERROR_ARGUMENT /*------------------------*/ (6)
	#define SERVER_ARGUMENT /*-----------------------*/ (7)

	#define NONE_INSTRUCTION_TYPE /*-----------------*/ (b(0000000))
	#define NAME_INSTRUCTION_TYPE /*-----------------*/ (b(0000001))
	#define NAME_LIST_INSTRUCTION_TYPE /*------------*/ (b(0000010))
	#define NUMBER_INSTRUCTION_TYPE /*---------------*/ (b(0000100))
	#define STRING_INSTRUCTION_TYPE /*---------------*/ (b(0001000))
	#define EXECUTE_INSTRUCTION_TYPE /*--------------*/ (b(0010000))
	#define IMAGE_INSTRUCTION_TYPE /*----------------*/ (b(0100000))
	#define END_INSTRUCTION_TYPE /*------------------*/ (b(1000000))

	#define NONE_NAME_LIST /*------------------------*/ (0)
	#define SUCCESS_NAME_LIST /*---------------------*/ (1)
	#define INVALID_NAME_NAME_LIST /*----------------*/ (2)
	#define PREMATURE_END_NAME_LIST /*---------------*/ (3)

	#define NONE_NUMBER /*---------------------------*/ (0)
	#define VALID_NUMBER_NUMBER /*-------------------*/ (1)
	#define NON_NUMBER_NUMBER /*---------------------*/ (2)
	#define OVERFLOWN_NUMBER_NUMBER /*---------------*/ (3)
	#define DIVIDED_BY_ZERO_NUMBER /*----------------*/ (4)

	#define NONE_READ_CONFIG /*----------------------*/ (0)
	#define CANNOT_OPEN_READ_CONFIG /*---------------*/ (1)
	#define CANNOT_READ_READ_CONFIG /*---------------*/ (2)
	#define UNSUPPORTED_FORMAT_READ_CONFIG /*--------*/ (3)
	#define BAD_HEADER_READ_CONFIG /*----------------*/ (4)
	#define BAD_DEPTH_READ_CONFIG /*-----------------*/ (5)
	#define BAD_COMPRESSION_READ_CONFIG /*-----------*/ (6)
	#define UNSUPPORTED_HEIGHT_READ_CONFIG /*--------*/ (7)
	#define BAD_SIZE_READ_CONFIG /*------------------*/ (8)
	#define FAILED_READ_CONFIG /*--------------------*/ (9)
	#define BAD_PIXELS_READ_CONFIG /*----------------*/ (10)
	#define BAD_IMAGE_READ_CONFIG /*-----------------*/ (11)
	#define SUCCESS_READ_CONFIG /*-------------------*/ (12)

	#define NONE_BOOLEAN /*--------------------------*/ (0)
	#define TRUE_BOOLEAN /*--------------------------*/ (1)
	#define FALSE_BOOLEAN /*-------------------------*/ (2)

	#define NONE_COMMAND /*--------------------------*/ (0)
	#define EXECUTE_COMMAND /*-----------------------*/ (1)
	#define RESTART_COMMAND /*-----------------------*/ (2)
	#define EXIT_COMMAND /*--------------------------*/ (3)

	#define NONE_VARIABLE /*-------------------------*/ (0)

	#define EMPTY_SHARED_STATUS /*-------------------*/ (0)
	#define FULL_SHARED_STATUS /*--------------------*/ (1)

	#define NONE_ROTATION /*-------------------------*/ (0)
	#define DEGREE_90_ROTATION /*--------------------*/ (1)
	#define DEGREE_180_ROTATION /*-------------------*/ (2)
	#define DEGREE_270_ROTATION /*-------------------*/ (3)

	#define NONE_NORMAL_HINT /*----------------------*/ (b(0000000000))
	#define USER_POSITION_NORMAL_HINT /*-------------*/ (b(0000000001))
	#define USER_SIZE_NORMAL_HINT /*-----------------*/ (b(0000000010))
	#define PROGRAM_POSITION_NORMAL_HINT /*----------*/ (b(0000000100))
	#define PROGRAM_SIZE_NORMAL_HINT /*--------------*/ (b(0000001000))
	#define PROGRAM_MINIMUM_SIZE_NORMAL_HINT /*------*/ (b(0000010000))
	#define PROGRAM_MAXIMUM_SIZE_NORMAL_HINT /*------*/ (b(0000100000))
	#define PROGRAM_RESIZE_INCREMENT_NORMAL_HINT /*--*/ (b(0001000000))
	#define PROGRAM_ASPECT_NORMAL_HINT /*------------*/ (b(0010000000))
	#define PROGRAM_BASE_SIZE_NORMAL_HINT /*---------*/ (b(0100000000))
	#define PROGRAM_WINDOW_GRAVITY_NORMAL_HINT /*----*/ (b(1000000000))

	#define NONE_HINT /*-----------------------------*/ (b(000000000))
	#define INPUT_HINT /*----------------------------*/ (b(000000001))
	#define STATE_HINT /*----------------------------*/ (b(000000010))
	#define ICON_PIXMAP_HINT /*----------------------*/ (b(000000100))
	#define ICON_WINDOW_HINT /*----------------------*/ (b(000001000))
	#define ICON_POSITION_HINT /*--------------------*/ (b(000010000))
	#define ICON_MASK_HINT /*------------------------*/ (b(000100000))
	#define WINDOW_GROUP_HINT /*---------------------*/ (b(001000000))
	#define URGENCY_HINT /*--------------------------*/ (b(100000000))

	#define WITHDRAWN_STATE /*-----------------------*/ (0)
	#define NORMAL_STATE /*--------------------------*/ (1)
	#define ICON_STATE /*----------------------------*/ (3)

	#define QUIT() /*--------------------------------*/ local void             quit(int signal)
	#define GETSHAREDCHARACTER() /*------------------*/ local int              getSharedCharacter(FILE *const configFile)
	#define INITMEMORYMANAGER() /*-------------------*/ local bool             initMemoryManager(void)
	#define PUSHPOINTER() /*-------------------------*/ local uint32          _pushPointer(void *const pointer, const char *const label, int (*const freeFunction)(void *))
	#define POPPOINTER() /*--------------------------*/ local void             popPointer(const uint32 token)
	#define UPDATEPOINTER() /*-----------------------*/ local void             updatePointer(const uint32 token, void *const pointer)
	#define DELETEMEMORYMANAGER() /*-----------------*/ local void             deleteMemoryManager(void)
	#define IFREE() /*-------------------------------*/ local int              iFree(void *const pointer)
	#define ISHMCTL() /*-----------------------------*/ local int              ishmctl(void *const pointer)
	#define IXCBDISCONNECT() /*----------------------*/ local int              iXCBDisconnect(void *const pointer)
	#define SHMINIT() /*-----------------------------*/ local void             shmInit(void)
	#define SHMCONNECT() /*--------------------------*/ local void             shmConnect(void)
	#define SHMMAIN() /*-----------------------------*/ local void *           shmMain(void *const arg)
	#define SHMDISCONNECT() /*-----------------------*/ local void             shmDisconnect(void)
	#define IDENTIFYARGUMENT() /*--------------------*/ local uint8            identifyArgument(const char *p)
	#define INSENSITIVESTRINGCOMPARE() /*------------*/ local bool             insensitiveStringCompare(const char *s0, const char *s1)
	#define SENSITIVESTRINGCOMPARE() /*--------------*/ local bool             sensitiveStringCompare(const char *s0, const char *s1)
	#define SETSTRINGROOT() /*-----------------------*/ local void             setStringRoot(StringNodeRoot *const root)
	#define BULKINSERTSTRING() /*--------------------*/ local void             bulkInsertString(StringNodeRoot *const root, const char *const *current)
	#define INSERTSTRING() /*------------------------*/ local bool             insertString(StringNodeRoot *const root, const char *string)
	#define GETSTRINGNODE() /*-----------------------*/ local StringNode *     getStringNode(StringNodeRoot *const root, const char **const stringReturn)
	#define DELETESTRINGROOT() /*--------------------*/ local void             deleteStringRoot(StringNodeRoot *const root)
	#define SETSHORTCUTROOT() /*---------------------*/ local void             setShortcutRoot(ShortcutNodeRoot *const root)
	#define INSERTSHORTCUT() /*----------------------*/ local bool             insertShortcut(ShortcutNodeRoot *const root, const uint8 code, const uint16 modifier, const uint8 command, char *const string, const uint stringToken, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define GETNEXTSHORTCUT() /*---------------------*/ local bool             getNextShortcut(const ShortcutNodeRoot *const root, uint8 code, uint16 modifier, int *const nextOffset)
	#define REMOVESHORTCUT() /*----------------------*/ local bool             removeShortcut(ShortcutNodeRoot *const root, const uint8 code, const uint16 modifier)
	#define UNSETSHORTCUTROOT() /*-------------------*/ local void             unsetShortcutRoot(ShortcutNodeRoot *const root)
	#define UNGRABSHORTCUTS() /*---------------------*/ local void             ungrabShortcuts(void)
	#define SETCONFIGVARIABLES() /*------------------*/ local void             setConfigVariables(void)
	#define READCONFIG() /*--------------------------*/ local void             readConfig(const bool createConfigFile, const char *const configPath, int (*getConfigChar)(FILE *file))
	#define MATCHNAMELIST() /*-----------------------*/ local uint8            matchNameList(StringNodeRoot *const root, const char *const statementWall, char **statementCurrentReturn, uint8 *const valueReturn)
	#define MATCHINTEGER() /*------------------------*/ local uint8            matchInteger(char **statementCurrent, const char *const statementWall, int64 *const returnValue)
	#define MATCHSTRING() /*-------------------------*/ local bool             matchString(char **statementCurrent, char **stringReturn, uint32 *stringToken)
	#define MATCHEXECUTE() /*------------------------*/ local bool             matchExecute(char **statementCurrent, char **executeReturn, uint32 *executeToken)
	#define READIMAGE() /*---------------------------*/ local uint8            readImage(const char *const path, const char **errorMessage, Image *image)
	#define FREECONFIGVARIABLES() /*-----------------*/ local void             freeConfigVariables(void)
	#define EXEC() /*--------------------------------*/ local void             exec(const char *const string)
	#define SETMEMORY() /*---------------------------*/ local void             setMemory(void *const destinationStart, const uint64 value, const uint itemAmount, const uint8 perByteAmount)
	#define COPYMEMORY() /*--------------------------*/ local void             copyMemory(void *const sourceStart, void *const destinationStart, const uint byteAmount)
	#define FINDSTRINGLENGTH() /*--------------------*/ local uint             findStringLength(const void *string)
	#define UTF8TOUCS2() /*--------------------------*/ local uint             UTF8ToUCS2(const uint8 *utf8, uint16 *const ucs2Start, const int ucs2Length)
	#define GETTIMESTAMP() /*------------------------*/ local xcb_timestamp_t  getTimestamp(void)
	#define GETPOINTERMONITOR() /*-------------------*/ local Monitor *        getPointerMonitor(void)
	#define GETWINDOWMONITOR() /*--------------------*/ local Monitor *        getWindowMonitor(const xcb_window_t window)
	#define COMPOSITEIMAGES() /*---------------------*/ local void             compositeImages(void (*operation)(const uint32 *const, uint32 *const), const int sourceX, const int sourceY, Image *const source, int destinationX, int destinationY, Image *const destination)
	#define COMPOSITEIMAGESOVER() /*-----------------*/ local void             compositeImagesOver(const uint32 *const source, uint32 *const destination)
	#define COMPOSITEIMAGESAND() /*------------------*/ local void             compositeImagesAnd(const uint32 *const source, uint32 *const destination)
	#define TWOPASSBOXBLUR() /*----------------------*/ local void             twoPassBoxBlur(const int width, const int height, const int boxSize, uint32 *destinationData)
	#define ROTATEIMAGE() /*-------------------------*/ local bool             rotateImage(const uint8 rotation, Image *const image, const bool deletePreviousData)
	#define FILLDRAWABLE() /*------------------------*/ local void             fillDrawable(const xcb_drawable_t drawable, const xcb_gcontext_t gc, const int16 x, const int16 y, const uint16 width, const uint16 height, const uint32 color)
	#define RESTARTCOMMAND() /*----------------------*/ local void             restartCommand(void)
	#define EXITCOMMAND() /*-------------------------*/ local void             exitCommand(void)
	#define CANCELTHREADS() /*-----------------------*/ local void             cancelThreads(void)
	#define FREEMONITORS() /*------------------------*/ local void             freeMonitors(void)
	#define PRINTUNACCOUNTEDFORPOINTERS() /*---------*/ local void             printUnaccountedForPointers(const Pointer *current, const Pointer *wall)
	#define PRINTERROR() /*--------------------------*/ local void             printError(const char *const message, ...)
	#define PRINTTITLEDERROR() /*--------------------*/ local void             printTitledError(const char *const title, const char *const message)
	#define PRINTTITLEDQUOTEDERROR() /*--------------*/ local void             printTitledQuotedError(const char *const title, const char *const argument, const char *const message)
	#define PRINTCONNECTIONERROR() /*----------------*/ local void             printConnectionError(void)
	#define PRINTTITLEDNAMEDERROR() /*---------------*/ local void             printTitledNamedError(const char *const title, const char *const message, const char *const name)
	#define PRINTXERROR() /*-------------------------*/ local void             printXError(const char *const *const name)
	#define PRINTTITLEDVALUEDERROR() /*--------------*/ local void             printTitledValuedError(const char *const title, const char *const message, const uint value)
	#define PRINTCONFIGERROR() /*--------------------*/ local void             printConfigError(const char *const type, const char *const message, const char finalStatementCharacter, const bool printLine, const bool printConfig, const bool printPointer, const bool printPattern, const char *const configPath, const uint statementLine, const char *const statementStart, const char *const statementWall, const Instruction *instructionStart, const Instruction *instructionCurrent, StringNodeRoot *const *const instructionDataStart, const char *const *currentScopeInstructionList, const StringNodeRoot *const currentScopeInstructionRoot)
	#define OPENERRORSTREAM() /*---------------------*/ local bool             openErrorStream(void)
	#define CLOSEERRORSTREAM() /*--------------------*/ local void             closeErrorStream(void)

	#define xcb_wait_for_reply(a, b, c) /*-----------*/ (xcb_wait_for_reply(a, (b).sequence, c))
	#define xcb_discard_reply(a, b) /*---------------*/ (xcb_discard_reply(a, (b).sequence))
	#define xcb_send_event(a, b, c, d, e) /*---------*/ (xcb_send_event(a, b, c, d, (void *)(e)))
	#define xcb_send_event_checked(a, b, c, d, e) /*-*/ (xcb_send_event_checked(a, b, c, d, (void *)(e)))

	#define SELF(self) /*----------------------------*/ self

	#define pushPointer(a, b, c) /*------------------*/ (_pushPointer(a, b, (int (*const)(void *))(c)))
	#define findString(a, b) /*----------------------*/ (!getStringNode(a, (const char **const)(b)))

	#if DEBUG
		#define printXEvent(n) /*--------*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %sX event:%s %s\n", colorStart, programName, colorEvent, colorEnd \
			, useXEventName(n, eventName) \
			: useXEventName(n, randrEventName) \
			: "unhandled extension event" \
		))
		#define useXEventName(n0, n1) /*-*/ n0 == n1? *(n1 + (((*event).response_type & ~b(10000000)) >= countof(n1)? countof(n1) - 1 : (*event).response_type & ~b(10000000)))
		#define printCommand(void) /*----*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %scommand:%s %s\n", colorStart, programName, colorEvent, colorEnd, *(commandList + ((*eventModifierNode).command >= countof(commandList)? countof(commandList) - 1 : (*eventModifierNode).command))))
	#else
		#define printXEvent(void) /*-----*/ EMPTY_MACRO
		#define printCommand(void) /*----*/ EMPTY_MACRO
	#endif
/*!}*/

/*!defs:{*/
	def uint8 /*-*/ Command;
	def uint8 /*-*/ Instruction;
	def uint8 /*-*/ JmpPoint;

	def struct{
		const char * /*--------*/ label;
		uint64 * /*------------*/ data;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[4];
		int /*-----------------*/ (*free)(void *);
	} Pointer;

	def struct{
		Pointer * /*-----------*/ data;
		uint16 /*--------------*/ size;
		uint16 /*--------------*/ allocated;
		uint8 /*---------------*/ pad0[4];
	} DynamicDataSegment;

	def struct{
		int32 /*---------------*/ leftX;
		int32 /*---------------*/ rightX;
		int32 /*---------------*/ topY;
		int32 /*---------------*/ bottomY;
		int32 /*---------------*/ w;
		int32 /*---------------*/ h;
		uint32 /*--------------*/ millimeterWidth;
		uint32 /*--------------*/ millimeterHeight;
	} Monitor;

	def struct{
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint16 /*--------------*/ offset[STRING_NODE_CHILDREN_AMOUNT];
	} StringNode;

	def struct{
		StringNode * /*--------*/ dataStart;
		const char *const * /*-*/ stringArray;
		uint32 /*--------------*/ dataToken;
		uint16 /*--------------*/ dataSize;
		uint16 /*--------------*/ dataAllocated;
		uint8 /*---------------*/ pad0[4];
		uint8 /*---------------*/ counter;
		uint8 /*---------------*/ returnedCounter;
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint16 /*--------------*/ offset[28];
	} StringNodeRoot;

	def struct{
		bool /*----------------*/ inUse;
		Command /*-------------*/ command;
		uint16 /*--------------*/ modifier;
		int32 /*---------------*/ nextOffset;
		char * /*--------------*/ string;
		uint32 /*--------------*/ stringToken;
		int32 /*---------------*/ field0;
		int32 /*---------------*/ field1;
		int32 /*---------------*/ field2;
		int32 /*---------------*/ field3;
		int32 /*---------------*/ field4;
	} ModifierNode;

	def struct{
		uint32 /*--------------*/ codeListStart[SHORTCUT_CODE_AMOUNT];
		uint32 /*--------------*/ codeListWall[SHORTCUT_CODE_AMOUNT];
		ModifierNode * /*------*/ modifierStart;
		uint32 /*--------------*/ modifierToken;
		uint32 /*--------------*/ modifierSize;
		uint32 /*--------------*/ modifierAllocated;
		uint32 /*--------------*/ modifierNotInUseOffset;
	} ShortcutNodeRoot;

	def struct{
		void * /*--------------*/ data;
		uint32 /*--------------*/ dataToken;
		uint32 /*--------------*/ size;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
	} Image;

	def struct{
		xcb_atom_t /*----------*/ WM_NAME;
		xcb_atom_t /*----------*/ WM_ICON_NAME;
		xcb_atom_t /*----------*/ WM_NORMAL_HINTS;
		xcb_atom_t /*----------*/ WM_SIZE_HINTS;
		xcb_atom_t /*----------*/ WM_HINTS;
		xcb_atom_t /*----------*/ WM_CLASS;
		xcb_atom_t /*----------*/ WM_TRANSIENT_FOR;
		xcb_atom_t /*----------*/ WM_PROTOCOLS;
		xcb_atom_t /*----------*/ WM_TAKE_FOCUS;
		xcb_atom_t /*----------*/ WM_DELETE_WINDOW;
		xcb_atom_t /*----------*/ WM_COLORMAP_WINDOWS;
		xcb_atom_t /*----------*/ WM_COLORMAP_NOTIFY;
		xcb_atom_t /*----------*/ WM_CLIENT_MACHINE;
		xcb_atom_t /*----------*/ WM_LOCALE_NAME;
		xcb_atom_t /*----------*/ WM_WINDOW_ROLE;
		xcb_atom_t /*----------*/ WM_COMMAND;
		xcb_atom_t /*----------*/ WM_CLIENT_LEADER;
		xcb_atom_t /*----------*/ WM_STATE;
		xcb_atom_t /*----------*/ WM_CHANGE_STATE;
		xcb_atom_t /*----------*/ WM_ICON_SIZE;
		xcb_atom_t /*----------*/ UTF8_STRING;
		xcb_atom_t /*----------*/ _NET_SUPPORTED;
		xcb_atom_t /*----------*/ _NET_CLIENT_LIST;
		xcb_atom_t /*----------*/ _NET_CLIENT_LIST_STACKING;
		xcb_atom_t /*----------*/ _NET_NUMBER_OF_DESKTOPS;
		xcb_atom_t /*----------*/ _NET_DESKTOP_GEOMETRY;
		xcb_atom_t /*----------*/ _NET_DESKTOP_VIEWPORT;
		xcb_atom_t /*----------*/ _NET_CURRENT_DESKTOP;
		xcb_atom_t /*----------*/ _NET_DESKTOP_NAMES;
		xcb_atom_t /*----------*/ _NET_ACTIVE_WINDOW;
		xcb_atom_t /*----------*/ _NET_WORKAREA;
		xcb_atom_t /*----------*/ _NET_SUPPORTING_WM_CHECK;
		xcb_atom_t /*----------*/ _NET_VIRTUAL_ROOTS;
		xcb_atom_t /*----------*/ _NET_DESKTOP_LAYOUT;
		xcb_atom_t /*----------*/ _NET_SHOWING_DESKTOP;
		xcb_atom_t /*----------*/ _NET_CLOSE_WINDOW;
		xcb_atom_t /*----------*/ _NET_MOVERESIZE_WINDOW;
		xcb_atom_t /*----------*/ _NET_WM_MOVERESIZE;
		xcb_atom_t /*----------*/ _NET_RESTACK_WINDOW;
		xcb_atom_t /*----------*/ _NET_REQUEST_FRAME_EXTENTS;
		xcb_atom_t /*----------*/ _NET_WM_NAME;
		xcb_atom_t /*----------*/ _NET_WM_VISIBLE_NAME;
		xcb_atom_t /*----------*/ _NET_WM_ICON_NAME;
		xcb_atom_t /*----------*/ _NET_WM_VISIBLE_ICON_NAME;
		xcb_atom_t /*----------*/ _NET_WM_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DOCK;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_TOOLBAR;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_MENU;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_UTILITY;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_SPLASH;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DIALOG;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_NORMAL;
		xcb_atom_t /*----------*/ _NET_WM_STATE;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MODAL;
		xcb_atom_t /*----------*/ _NET_WM_STATE_STICKY;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MAXIMIZED_VERT;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MAXIMIZED_HORZ;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SHADED;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SKIP_TASKBAR;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SKIP_PAGER;
		xcb_atom_t /*----------*/ _NET_WM_STATE_HIDDEN;
		xcb_atom_t /*----------*/ _NET_WM_STATE_FULLSCREEN;
		xcb_atom_t /*----------*/ _NET_WM_STATE_ABOVE;
		xcb_atom_t /*----------*/ _NET_WM_STATE_BELOW;
		xcb_atom_t /*----------*/ _NET_WM_STATE_DEMANDS_ATTENTION;
		xcb_atom_t /*----------*/ _NET_WM_ALLOWED_ACTIONS;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MOVE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_RESIZE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MINIMIZE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_SHADE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_STICK;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MAXIMIZE_HORZ;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MAXIMIZE_VERT;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_FULLSCREEN;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_CHANGE_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_CLOSE;
		xcb_atom_t /*----------*/ _NET_WM_STRUT;
		xcb_atom_t /*----------*/ _NET_WM_STRUT_PARTIAL;
		xcb_atom_t /*----------*/ _NET_WM_ICON_GEOMETRY;
		xcb_atom_t /*----------*/ _NET_WM_ICON;
		xcb_atom_t /*----------*/ _NET_WM_PID;
		xcb_atom_t /*----------*/ _NET_WM_HANDLED_ICONS;
		xcb_atom_t /*----------*/ _NET_WM_USER_TIME;
		xcb_atom_t /*----------*/ _NET_FRAME_EXTENTS;
		xcb_atom_t /*----------*/ _NET_WM_PING;
		xcb_atom_t /*----------*/ _NET_WM_SYNC_REQUEST;
		xcb_atom_t /*----------*/ _NET_WM_SYNC_REQUEST_COUNTER;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_ORIENTATION;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_OPCODE;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_MESSAGE_DATA;
		xcb_atom_t /*----------*/ _XEMBED_INFO;
		xcb_atom_t /*----------*/ _XEMBED;
		xcb_atom_t /*----------*/ _XROOTPMAP_ID;
	} CommonAtom;
/*!}*/

/*!globals:{*/
	local const char * /*-----------------*/ programName;
	local const char * /*-----------------*/ localeName;
	local const char * /*-----------------*/ configPath;
	local const char * /*-----------------*/ errorPath;
	local const char * /*-----------------*/ connectionName;
	local const char * /*-----------------*/ colorStart;
	local const char * /*-----------------*/ colorFatal;
	local const char * /*-----------------*/ colorError;
	local const char * /*-----------------*/ colorEvent;
	local const char * /*-----------------*/ colorEnd;
	local const char * /*-----------------*/ labelExamined;
	local const ModifierNode * /*---------*/ eventModifierNode;
	local bool /*-------------------------*/ memorySegmentMutexCreated;
	local pthread_mutex_t /*--------------*/ memorySegmentMutex;
	local bool /*-------------------------*/ mustOpenErrorStream;
	local FILE * /*-----------------------*/ errorStream;
	local uint32 /*-----------------------*/ errorStreamToken;
	local volatile bool /*----------------*/ processingSignal;
	local bool /*-------------------------*/ quitting;
	local DynamicDataSegment /*-----------*/ dynamicDataSegment;
	local bool /*-------------------------*/ globalsLockCreated;
	local pthread_rwlock_t /*-------------*/ globalsLock;
	local bool /*-------------------------*/ shmRunning;
	local int /*--------------------------*/ shmid;
	local uint32 /*-----------------------*/ shmidToken;
	local uint8 * /*----------------------*/ sharedStart;
	local uint32 /*-----------------------*/ sharedToken;
	local uint8 * /*----------------------*/ sharedCurrent;
	local bool /*-------------------------*/ sharedMutexCreated;
	local pthread_mutex_t * /*------------*/ sharedMutex;
	local bool /*-------------------------*/ sharedCondCreated;
	local pthread_cond_t * /*-------------*/ sharedCond;
	local bool /*-------------------------*/ sharedThreadCreated;
	local pthread_t /*--------------------*/ sharedThread;
	local bool /*-------------------------*/ sharedQuittingThread;
	local int /*--------------------------*/ screenNumber;
	local xcb_connection_t * /*-----------*/ connection;
	local uint32 /*-----------------------*/ connectionToken;
	local xcb_screen_t * /*---------------*/ screen;
	local Display * /*--------------------*/ display;
	local uint32 /*-----------------------*/ displayToken;
	local XIM /*--------------------------*/ im;
	local XIC /*--------------------------*/ ic;
	local uint8 /*------------------------*/ randrMajorOpcode;
	local uint8 /*------------------------*/ randrBaseEvent;
	local uint8 /*------------------------*/ randrBaseError;
	local xcb_visualid_t /*---------------*/ visual;
	local uint8 /*------------------------*/ depth;
	local CommonAtom /*-------------------*/ atom;
	local uint /*-------------------------*/ monitorAllocated;
	local Monitor * /*--------------------*/ monitorStart;
	local uint32 /*-----------------------*/ monitorToken;
	local xcb_colormap_t /*---------------*/ colormap;
	local xcb_gcontext_t /*---------------*/ gc;
	local bool /*-------------------------*/ displaySimpleConfigErrors;
	local StringNodeRoot /*---------------*/ globalScopesInstructionRoot;
	local StringNodeRoot /*---------------*/ globalInstructionRoot;
	local StringNodeRoot /*---------------*/ scope1ScopeInstructionRoot;
	local StringNodeRoot /*---------------*/ booleanRoot;
	local StringNodeRoot /*---------------*/ commandRoot;
	local StringNodeRoot /*---------------*/ variableRoot;
	local StringNodeRoot /*---------------*/ modifierRoot;
	local StringNodeRoot /*---------------*/ macroRoot;
	local ShortcutNodeRoot /*-------------*/ keycodeShortcut;
	local ShortcutNodeRoot /*-------------*/ buttonShortcut;
	local int /*--------------------------*/ keyPressNextOffset;
	local int /*--------------------------*/ keyReleaseNextOffset;
	local int /*--------------------------*/ buttonPressNextOffset;
	local int /*--------------------------*/ buttonReleaseNextOffset;
	local xcb_generic_event_t * /*--------*/ event;
	local uint32 /*-----------------------*/ eventToken;
	local uint8 /*------------------------*/ shortcutCode;
	local uint16 /*-----------------------*/ shortcutModifier;

	local const char *const /*------------*/ errorName[] = {"unrecognized", "request", "value", "window", "pixmap", "atom", "cursor", "font", "match", "drawable", "access", "allocation", "colormap", "graphics context", "id choice", "name", "length", "implementation", "unrecognized"};
	local const char *const /*------------*/ operationName[] = {"unrecognized", "create window", "change window attributes", "get window attributes", "destroy window", "destroy subwindows", "change save set", "reparent window", "map window", "map subwindows", "unmap window", "unmap subwindows", "configure window", "circulate window", "get geometry", "query tree", "intern atom", "get atom name", "change property", "delete property", "get property", "list properties", "set selection owner", "get selection owner", "convert selection", "send event", "grab pointer", "ungrab pointer", "grab button", "ungrab button", "change active pointer grab", "grab keyboard", "ungrab keyboard", "grab key", "ungrab key", "allow events", "grab server", "ungrab server", "query pointer", "get motion events", "translate coordinates", "warp pointer", "set input focus", "get input focus", "query keymap", "open font", "close font", "query font", "query text extents", "list fonts", "list fonts with info", "set font path", "get font path", "create pixmap", "free pixmap", "create graphics context", "change graphics context", "copy graphics context", "set dashes", "set clip rectangles", "free graphics context", "clear area", "copy area", "copy plane", "poly point", "poly line", "poly segment", "poly rectangle", "poly arc", "fill poly", "poly fill rectangle", "poly fill arc", "put image", "get image", "poly text (8)", "poly text (16)", "image text (8)", "image text (16)", "create colormap", "free colormap", "copy colormap and free", "install colormap", "uninstall colormap", "list installed colormaps", "allocate color", "allocate named color", "allocate color cells", "allocate color planes", "free colors", "store colors", "store named color", "query colors", "lookup color", "create cursor", "create glyph cursor", "free cursor", "recolor cursor", "query best size", "query extension", "list extensions", "change keyboard mapping", "get keyboard mapping", "change keyboard control", "get keyboard control", "bell", "change pointer control", "get pointer control", "set screen saver", "get screen saver", "change hosts", "list hosts", "set access control", "set close down mode", "kill client", "rotate properties", "force screen saver", "set pointer mapping", "get pointer mapping", "set modifier mapping", "get modifier mapping", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "no", "unrecognized"};
	local const char *const /*------------*/ randrErrorName[] = {"bad output", "bad crtc", "bad mode", "bad provider", "unrecognized"};
	local const char *const /*------------*/ randrOperationName[] = {"query version", "unrecognized", "set screen config", "unrecognized", "select input", "get screen info", "get screen size range", "set screen size", "get screen resources", "get output info", "list output properties", "query output property", "configure output property", "change output property", "delete output property", "get output property", "create mode", "destroy mode", "add output mode", "delete output mode", "get crtc info", "set crtc config", "get crtc gamma size", "get crtc gamma", "set crtc gamma", "get screen resources current", "set crtc transform", "get crtc transform", "get panning", "set panning", "set output primary", "get output primary", "get providers", "get provider info", "set provider offload sink", "set provider output source", "list provider properties", "query provider property", "configure provider property", "change provider property", "delete provider property", "get provider property", "get monitors", "set monitor", "delete monitor", "create lease", "free lease", "unrecognized"};

	local const char *const /*------------*/ globalScopesInstructionList[] = {
		  "scope1"
		, NULL
	};
	local const char *const /*------------*/ globalInstructionList[] = {
		  "help"
		, "expand"
		, "contract"
		, "read-config"
		, "use-messenger"
		, "do"
		, "set"
		, "grab-keycode"
		, "grab-button"
		, "grab-gesture"
		, "ungrab-keycode"
		, "ungrab-button"
		, "ungrab-gesture"
		, "stop"
		, NULL
	};
	local const char *const /*------------*/ scope1ScopeInstructionList[] = {
		  "help"
		, "expand"
		, "contract"
		, "stop"
		, NULL
	};
	local const char *const /*------------*/ booleanList[] = {
		  "none"
		, "true"
		, "false"
		, NULL
	};
	local const char *const /*------------*/ commandList[] = {
		  "none"
		, "execute"
		, "restart"
		, "exit"
		, NULL
	};
	local const char *const /*------------*/ variableList[] = {
		  "none"
		, NULL
	};
	local const char *const /*------------*/ modifierList[] = {
		  "none"
		, "shift"
		, "caps"
		, "control"
		, "mod-1"
		, "mod-2"
		, "mod-3"
		, "mod-4"
		, "mod-5"
		, "button-1"
		, "button-2"
		, "button-3"
		, "button-4"
		, "button-5"
		, NULL
	};
	local const char *const /*------------*/ macroList[] = {
		  "button-1"
		, "button-2"
		, "button-3"
		, "button-4"
		, "button-5"
		, NULL
	};

	local const Instruction /*------------*/ helpInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ expandInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ contractInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ readConfigInstruction[] = {STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ useMessengerInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ doInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ setInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ grabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ grabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ ungrabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ ungrabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ stopInstruction[] = {END_INSTRUCTION_TYPE};

	local const Instruction /*------------*/ executeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, EXECUTE_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ executeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, EXECUTE_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ executeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, EXECUTE_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};

	local StringNodeRoot *const *const /*-*/ helpInstructionData = NULL;
	local StringNodeRoot *const *const /*-*/ expandInstructionData = NULL;
	local StringNodeRoot *const *const /*-*/ contractInstructionData = NULL;
	local StringNodeRoot *const *const /*-*/ readConfigInstructionData = NULL;
	local StringNodeRoot *const /*--------*/ useMessengerInstructionData[] = {&booleanRoot};
	local StringNodeRoot *const /*--------*/ doInstructionData[] = {&commandRoot};
	local StringNodeRoot *const /*--------*/ setInstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ grabKeycodeInstructionData[] = {&modifierRoot, &commandRoot};
	local StringNodeRoot *const /*--------*/ grabButtonInstructionData[] = {&modifierRoot, &commandRoot};
	local StringNodeRoot *const /*--------*/ ungrabKeycodeInstructionData[] = {&modifierRoot};
	local StringNodeRoot *const /*--------*/ ungrabButtonInstructionData[] = {&modifierRoot};
	local StringNodeRoot *const *const /*-*/ stopInstructionData = NULL;

	local StringNodeRoot *const /*--------*/ executeDoSubinstructionData[] = {&commandRoot};
	local StringNodeRoot *const /*--------*/ executeGrabKeycodeSubinstructionData[] = {&modifierRoot, &commandRoot};
	local StringNodeRoot *const /*--------*/ executeGrabButtonSubinstructionData[] = {&modifierRoot, &commandRoot};

	#define getInstruction(i) /*-----*/ (i##Instruction)
	#define getInstructionData(i) /*-*/ (i##InstructionData)
	#define getGlobalScope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(readConfig) \
		, get##i(useMessenger) \
		, get##i(do) \
		, get##i(set) \
		, get##i(grabKeycode) \
		, get##i(grabButton) \
		, get##i(ungrabKeycode) \
		, get##i(ungrabButton) \
		, get##i(stop) \
	}
	#define getScope1Scope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(stop) \
	}
	local const Instruction *const /*-----*/ globalScopeInstruction[] = getGlobalScope(Instruction);
	local const Instruction *const /*-----*/ scope1ScopeInstruction[] = getScope1Scope(Instruction);

	local StringNodeRoot *const *const /*-*/ globalScopeInstructionData[] = getGlobalScope(InstructionData);
	local StringNodeRoot *const *const /*-*/ scope1ScopeInstructionData[] = getScope1Scope(InstructionData);
	#undef  getScope1Scope
	#undef  getGlobalScope
	#undef  getInstructionData
	#undef  getInstruction

	#if DEBUG
	local const char *const /*------------*/ eventName[] = {"error", "unrecognized", "key press", "key release", "button press", "button release", "motion notify", "enter notify", "leave notify", "focus in", "focus out", "keymap notify", "expose", "graphics expose", "no expose", "visibility notify", "create notify", "destroy notify", "unmap notify", "map notify", "map request", "reparent notify", "configure notify", "configure request", "gravity notify", "resize request", "circulate notify", "circulate request", "property notify", "selection clear", "selection request", "selection notify", "colormap notify", "client message", "mapping notify", "generic event"};
	local const char *const /*------------*/ randrEventName[] = {"screen change notify", "notify", "unrecognized"};
	#endif
/*!}*/

/*!functions:{*/
	QUIT();
	GETSHAREDCHARACTER();
	INITMEMORYMANAGER();
	PUSHPOINTER();
	POPPOINTER();
	UPDATEPOINTER();
	DELETEMEMORYMANAGER();
	IFREE();
	ISHMCTL();
	IXCBDISCONNECT();
	SHMINIT();
	SHMCONNECT();
	SHMMAIN();
	SHMDISCONNECT();
	IDENTIFYARGUMENT();
	INSENSITIVESTRINGCOMPARE();
	SENSITIVESTRINGCOMPARE();
	SETSTRINGROOT();
	BULKINSERTSTRING();
	INSERTSTRING();
	GETSTRINGNODE();
	DELETESTRINGROOT();
	SETSHORTCUTROOT();
	INSERTSHORTCUT();
	GETNEXTSHORTCUT();
	REMOVESHORTCUT();
	UNSETSHORTCUTROOT();
	UNGRABSHORTCUTS();
	SETCONFIGVARIABLES();
	READCONFIG();
	MATCHNAMELIST();
	MATCHINTEGER();
	MATCHSTRING();
	MATCHEXECUTE();
	READIMAGE();
	FREECONFIGVARIABLES();
	EXEC();
	SETMEMORY();
	COPYMEMORY();
	FINDSTRINGLENGTH();
	UTF8TOUCS2();
	GETTIMESTAMP();
	GETPOINTERMONITOR();
	GETWINDOWMONITOR();
	COMPOSITEIMAGES();
	COMPOSITEIMAGESOVER();
	COMPOSITEIMAGESAND();
	TWOPASSBOXBLUR();
	ROTATEIMAGE();
	FILLDRAWABLE();
	RESTARTCOMMAND();
	EXITCOMMAND();
	CANCELTHREADS();
	FREEMONITORS();
	PRINTUNACCOUNTEDFORPOINTERS();
	PRINTERROR();
	PRINTTITLEDERROR();
	PRINTTITLEDQUOTEDERROR();
	PRINTCONNECTIONERROR();
	PRINTTITLEDNAMEDERROR();
	PRINTXERROR();
	PRINTTITLEDVALUEDERROR();
	PRINTCONFIGERROR();
	OPENERRORSTREAM();
	CLOSEERRORSTREAM();
/*!}*/









#define RANDRQUERYVERSIONUNCHECKED() /*--*/ local xcb_void_cookie_t  randrQueryVersionUnchecked(xcb_connection_t *const connection, const uint32 majorVersion, const uint32 minorVersion)

RANDRQUERYVERSIONUNCHECKED();

RANDRQUERYVERSIONUNCHECKED(){
	xcb_void_cookie_t cookie;
	cookie.sequence = xcb_randr_query_version_unchecked(connection, majorVersion, minorVersion).sequence;
	ret cookie;
}









#ifdef a
#define DRAWWINDOW() /*-*/ local void drawWindow(void)

local xcb_window_t /*---*/ window;
local xcb_pixmap_t /*---*/ pixmap;
local xcb_gcontext_t /*-*/ gc;

DRAWWINDOW();

DRAWWINDOW(){



	/*!*/



	ret;
}
#endif









#define NONE_ASCII_STRING_NODE /*--------*/ (0)
#define COMPLETE_ASCII_STRING_NODE /*----*/ (1)
#define INCOMPLETE_ASCII_STRING_NODE /*--*/ (2)

#define SETASCIISTRINGROOT() /*----------*/ local void   setASCIIStringRoot(ASCIIStringNodeRoot *const root)
#define ISASCIISTRING() /*---------------*/ local bool   isASCIIString(const void *string)
#define INSERTASCIISTRING() /*-----------*/ local bool   insertASCIIString(ASCIIStringNodeRoot *const root, const char *string)
#define GETASCIISTRINGNODE() /*----------*/ local uint8  getASCIIStringNode(ASCIIStringNodeRoot *const root, const char **const stringReturn, ASCIIStringNode **nodeReturn)
#define GETMULTIPLEASCIISTRINGNODES() /*-*/ local void   getMultipleASCIIStringNodes(ASCIIStringNodeRoot *const root, const uint amount, const char *prefix)
#define DELETEASCIISTRINGROOT() /*-------*/ local void   deleteASCIIStringRoot(ASCIIStringNodeRoot *const root)

#define findASCIIString(a, b) /*---------*/ (getASCIIStringNode(a, b, NULL) == COMPLETE_ASCII_STRING_NODE)

def struct{
	uint8 /*-------------*/ letter;
	uint8 /*-------------*/ childrenAmount;
	uint8 /*-------------*/ counter;
	uint8 /*-------------*/ pad0[1];
	uint32 /*------------*/ childOffset[128];
	uint32 /*------------*/ parentOffset;
} ASCIIStringNode;

def struct{
	ASCIIStringNode * /*-*/ dataStart;
	uint32 /*------------*/ dataToken;
	uint16 /*------------*/ dataSize;
	uint16 /*------------*/ dataAllocated;
} ASCIIStringNodeRoot;

SETASCIISTRINGROOT();
ISASCIISTRING();
INSERTASCIISTRING();
GETASCIISTRINGNODE();
GETMULTIPLEASCIISTRINGNODES();
DELETEASCIISTRINGROOT();

SETASCIISTRINGROOT(){
	#define DATA_BLOCK_SIZE /*-*/ (16384)
	(*root).dataSize = DATA_BLOCK_SIZE;
	(*root).dataAllocated = 1;
	(*root).dataStart = malloc(DATA_BLOCK_SIZE * sizeof(ASCIIStringNode));
	(*root).dataToken = pushPointer((*root).dataStart, "string tree pointer", iFree);
	if(!(*root).dataStart){
		printTitledError("memory allocation error", "could not allocate memory for a ascii string tree");
		ret;
	}
	setMemory((*root).dataStart, 0, DATA_BLOCK_SIZE * sizeof(ASCIIStringNode) / sizeof(uint32), sizeof(uint32));
	ret;
}
ISASCIISTRING(){
	jmp loop;
	loop:{
		if(*(uint8 *)string == b(00000000)) ret true;
		if(*(uint8 *)string >= b(10000000)) ret false;
		string = (uint8 *)string + 1;
		jmp loop;
	}
}
INSERTASCIISTRING(){
	ASCIIStringNode *data = (*root).dataStart;
	ASCIIStringNode *node;
	uint allocated = (*root).dataAllocated;
	uint size = (*root).dataSize;
	jmp getNode;
	getNode: switch getASCIIStringNode(root, &string, &node) over
		to COMPLETE_ASCII_STRING_NODE: /*---*/ ret false;
		to INCOMPLETE_ASCII_STRING_NODE: /*-*/ jmp insertNodeLoop;
		off: /*-----------------------------*/ ret false;
	end
	insertNodeLoop:{
		char c;
		uint parentOffset;
		if(allocated == size){
			const uint nodeOffset = node - data;
			void *temp;
			size += DATA_BLOCK_SIZE;
			temp = realloc(data, size * sizeof(ASCIIStringNode));
			updatePointer((*root).dataToken, temp);
			if(!temp){
				printTitledError("memory allocation error", "could not reallocate memory for a ascii string nodes");
				size -= DATA_BLOCK_SIZE;
				(*root).dataStart = data;
				(*root).dataSize = size;
				(*root).dataAllocated = allocated;
				ret false;
			}
			data = temp;
			node = data + nodeOffset;
			setMemory(data + size - DATA_BLOCK_SIZE, 0, DATA_BLOCK_SIZE * sizeof(ASCIIStringNode) / sizeof(uint32), sizeof(uint32));
		}
		c = *string;
		parentOffset = node - data;
		*((*node).childOffset + c) = allocated;
		inc (*node).childrenAmount;
		node = data + allocated;
		(*node).parentOffset = parentOffset;
		inc allocated;
		if(c){
			(*node).letter = c;
			inc string;
			jmp insertNodeLoop;
		}
		(*node).letter = b(10000000);
		(*root).dataStart = data;
		(*root).dataSize = size;
		(*root).dataAllocated = allocated;
		ret true;
	}
}
GETASCIISTRINGNODE(){



	/*! optimize how children are found (the null pointers to children discrepancy). */



	const uint32 *childOffsetCurrent;
	const uint32 *childOffsetWall;
	const char *string = *stringReturn;
	ASCIIStringNode *const data = (*root).dataStart;
	ASCIIStringNode *node = data;
	uint8 counter;
	uint8 childrenAmount;
	char c;
	jmp confirmRootValidity;
	confirmRootValidity:{
		if(!data){
			ret NONE_ASCII_STRING_NODE;
		}
		jmp getChildNode;
	}
	getChildNode:{
		childOffsetCurrent = (*node).childOffset;
		childOffsetWall = childOffsetCurrent + countof((*node).childOffset);
		counter = 0;
		childrenAmount = (*node).childrenAmount;
		c = *string;
		jmp findChildNodeLoop;
	}
	findChildNodeLoop:{
		if(childOffsetCurrent < childOffsetWall){
			ASCIIStringNode *child;
			if(!*childOffsetCurrent){
				inc childOffsetCurrent;
				jmp findChildNodeLoop;
			}
			child = data + *childOffsetCurrent;
			inc counter;
			if((*child).letter == c){
				node = child;
				inc string;
				jmp getChildNode;
			}
			if((*child).letter == b(10000000) and !c){
				*stringReturn = string;
				if(nodeReturn){
					*nodeReturn = node;
				}
				ret COMPLETE_ASCII_STRING_NODE;
			}
			if(counter <= childrenAmount){
				inc childOffsetCurrent;
				jmp findChildNodeLoop;
			}
		}
		*stringReturn = string;
		if(nodeReturn){
			*nodeReturn = node;
		}
		ret INCOMPLETE_ASCII_STRING_NODE;
	}
}









GETMULTIPLEASCIISTRINGNODES(){
	const uint32 *childOffsetCurrent;
	const char *string = prefix;









	/*! what if we try to set a count to the root, or even before that? */



	ASCIIStringNode *data = (*root).dataStart;
	ASCIIStringNode *node = data;
	ASCIIStringNode *lastPrefixNode;



	uint foundStringCounter = 0;
	uint8 foreStart[256];
	uint8 *foreCurrent = foreStart;



	jmp getNode;
	getNode: switch getASCIIStringNode(root, &string, &node) over
		to COMPLETE_ASCII_STRING_NODE: /*---*/ jmp prefixFound;
		to INCOMPLETE_ASCII_STRING_NODE: /*-*/ jmp prefixFound;
		off: /*-----------------------------*/ jmp emergencyExit;
	end
	prefixFound:{



		if(node > data){
			(*(data + (*node).parentOffset)).counter = countof((*node).childOffset);
		}
		(*node).counter = 0;
		childOffsetCurrent = (*node).childOffset + (*node).counter;



		fprintf(stdout, "prefix found: \"%s\"\n", prefix);
		lastPrefixNode = node;
		jmp prefixFoundLoop;
		prefixFoundLoop:{
			if(prefix){
				*foreCurrent = *prefix;
				inc foreCurrent;
				inc prefix;
				jmp prefixFoundLoop;
			}
			*foreCurrent = '\0';
			jmp newNextLetterLoop;
		}
	}



	newNextLetterLoop:{
		if(childOffsetCurrent < (*node).childOffset + countof((*node).childOffset)){
			if(!*childOffsetCurrent){
				inc childOffsetCurrent;
				inc (*node).counter;
				jmp newNextLetterLoop;
			}
			inc (*node).counter;









			/*! above is correct, even if unoptimized */









			{
				ASCIIStringNode *const child = data + *childOffsetCurrent;
				if((*child).letter == b(10000000)){



					*foreCurrent = '\0';
					dec foreCurrent;
					fprintf(stdout, "\t%u: %s\n", foundStringCounter, foreStart);



					node = data + (*node).parentOffset;
					childOffsetCurrent = (*node).childOffset + (*node).counter;
					if(inc foundStringCounter == amount){
						jmp emergencyExit;
					}
					jmp newNextLetterLoop;
				}



				*foreCurrent = (*child).letter;
				inc foreCurrent;



				node = child;
				(*node).counter = 0;
				childOffsetCurrent = (*node).childOffset + (*node).counter;
				jmp newNextLetterLoop;
			}









		}
		if(node != lastPrefixNode){



			dec foreCurrent;



			node = data + (*node).parentOffset;
			childOffsetCurrent = (*node).childOffset + (*node).counter;
			jmp newNextLetterLoop;
		}
		jmp emergencyExit;
	}



	emergencyExit:{



		fprintf(stdout, "found %u\n", foundStringCounter);



		ret;
	}
}
DELETEASCIISTRINGROOT(){
	free((*root).dataStart);
	popPointer((*root).dataToken);
	ret;
	#undef  DATA_BLOCK_SIZE
}









int main(int argumentAmount, const char *const *argument){









	{
		char *pathStart = getenv("PATH");



		ASCIIStringNodeRoot asciiRoot;
		setASCIIStringRoot(&asciiRoot);



		fprintf(stdout, "\n\n\n");
		if(pathStart and *pathStart){
			char *pathCurrent = pathStart;
			uint i = 1;
			jmp printPathNameLoop;
			printPathNameLoop:{
				DIR *dir;
				char lastChar;
				if(*pathCurrent != ':' and *pathCurrent != '\0'){
					inc pathCurrent;
					jmp printPathNameLoop;
				}
				lastChar = *(pathStart + (pathCurrent - pathStart));
				*(pathStart + (pathCurrent - pathStart)) = '\0';
				fprintf(stdout, "path %u: %s\n", i, pathStart);



				dir = opendir(pathStart);
				if(dir){;
					jmp printDirectoryNameLoop;
					printDirectoryNameLoop:{
						struct dirent *entry;
						if((entry = readdir(dir))){
							const char *const name = (*entry).d_name;
							if(!(*name == '.' and (*(name + 1) == '\0' or (*(name + 1) == '.' and *(name + 2) == '\0')))){
								const bool isAscii = isASCIIString(name);
#ifdef a
								const unsigned char type = (*entry).d_type;
								char *typeName;
								switch type over
									to DT_BLK: /*--*/ typeName = "block device"; /*-----*/ brk;
									to DT_CHR: /*--*/ typeName = "character device"; /*-*/ brk;
									to DT_DIR: /*--*/ typeName = "directory"; /*--------*/ brk;
									to DT_FIFO: /*-*/ typeName = "fifo"; /*-------------*/ brk;
									to DT_LNK: /*--*/ typeName = "symbolic link"; /*----*/ brk;
									to DT_REG: /*--*/ typeName = "regular file"; /*-----*/ brk;
									to DT_SOCK: /*-*/ typeName = "socket"; /*-----------*/ brk;
									off: /*--------*/ typeName = "unknown"; /*----------*/ brk;
								end
								fprintf(stdout, "%-49s (%s, %s)\n", name, typeName, isAscii? "ascii" : "non-ascii");
#endif
								if(isAscii){
									const char *n = name;
									if(!insertASCIIString(&asciiRoot, n)){
										fprintf(stdout, "\t%s not put\n", name);
									}
									n = name;
									if(!findASCIIString(&asciiRoot, &n)){
										fprintf(stdout, "\t%s not found\n", name);
									}
								}else{
									fprintf(stdout, "\tgotta add to non-ascii list\n");
								}
							}
							jmp printDirectoryNameLoop;
						}
						closedir(dir);
					}
				}
				fprintf(stdout, "\n");
				*(pathStart + (pathCurrent - pathStart)) = lastChar;
				if(*pathCurrent == ':'){
					inc pathCurrent;
				}
				if(*pathCurrent){
					inc i;
					pathStart = pathCurrent;
					jmp printPathNameLoop;
				}
			}
		}









		getMultipleASCIIStringNodes(&asciiRoot, 256, "");









		deleteASCIIStringRoot(&asciiRoot);
	}









	(void)setMemory;
	(void)copyMemory;
	(void)findStringLength;
	(void)UTF8ToUCS2;
	(void)getPointerMonitor;
	(void)getWindowMonitor;
	(void)compositeImages;
	(void)compositeImagesOver;
	(void)compositeImagesAnd;
	(void)twoPassBoxBlur;
	(void)rotateImage;
	(void)fillDrawable;
	jmp setSignalHandler;
	setSignalHandler:{
		def struct sigaction /*-*/ Sigaction;
		Sigaction s;
		processingSignal = true;
		s.sa_handler = quit;
		s.sa_flags = 0;
		sigemptyset(&s.sa_mask);
		sigaction(SIGABRT, &s, NULL);
		sigaction(SIGBUS,  &s, NULL);
		sigaction(SIGFPE,  &s, NULL);
		sigaction(SIGILL,  &s, NULL);
		sigaction(SIGINT,  &s, NULL);
		sigaction(SIGQUIT, &s, NULL);
		sigaction(SIGSEGV, &s, NULL);
		sigaction(SIGTERM, &s, NULL);
		sigaction(SIGTRAP, &s, NULL);
		sigaction(SIGUSR1, &s, NULL);
		sigaction(SIGUSR2, &s, NULL);
		jmp setGlobals;
	}
	setGlobals:{
		programName /*-------------*/ = *argument;
		localeName /*--------------*/ = setlocale(LC_ALL, "");
		configPath /*--------------*/ = NULL;
		errorPath /*---------------*/ = NULL;
		connectionName /*----------*/ = NULL;
		colorStart /*--------------*/ = MESSAGE_START;
		colorFatal /*--------------*/ = MESSAGE_FATAL;
		colorError /*--------------*/ = MESSAGE_ERROR;
		colorEvent /*--------------*/ = MESSAGE_EVENT;
		colorEnd /*----------------*/ = MESSAGE_END;
		mustOpenErrorStream /*-----*/ = false;
		errorStream /*-------------*/ = DEFAULT_ERROR_STREAM;
		errorStreamToken /*--------*/ = 0;
		quitting /*----------------*/ = false;
		connection /*--------------*/ = NULL;
		connectionToken /*---------*/ = 0;
		display /*-----------------*/ = NULL;
		displayToken /*------------*/ = 0;
		im /*----------------------*/ = XCB_NONE;
		ic /*----------------------*/ = XCB_NONE;
		monitorStart /*------------*/ = NULL;
		monitorToken /*------------*/ = 0;
		keyPressNextOffset /*------*/ = 0;
		keyReleaseNextOffset /*----*/ = 0;
		buttonPressNextOffset /*---*/ = 0;
		buttonReleaseNextOffset /*-*/ = 0;
		event /*-------------------*/ = NULL;
		eventToken /*--------------*/ = 0;
		setConfigVariables();
		initMemoryManager();
		shmInit();
		setStringRoot(&globalScopesInstructionRoot);
		setStringRoot(&globalInstructionRoot);
		setStringRoot(&scope1ScopeInstructionRoot);
		setStringRoot(&booleanRoot);
		setStringRoot(&commandRoot);
		setStringRoot(&variableRoot);
		setStringRoot(&modifierRoot);
		setStringRoot(&macroRoot);
		setShortcutRoot(&keycodeShortcut);
		setShortcutRoot(&buttonShortcut);
		{
			pthread_rwlockattr_t attributes;
			if(pthread_rwlockattr_init(&attributes) != PTHREAD_RWLOCKATTR_INIT_SUCCESS){
				printTitledError("pthread error", "could not init global lock attributes");
			}
			if(pthread_rwlockattr_setkind_np(&attributes, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) != PTHREAD_RWLOCKATTR_SETKIND_NP_SUCCESS){
				printTitledError("pthread error", "could not set global lock attributes lock kind");
			}
			globalsLockCreated = pthread_rwlock_init(&globalsLock, &attributes) == PTHREAD_RWLOCK_INIT_SUCCESS;
			if(!globalsLockCreated){
				printTitledError("pthread error", "could not init globals lock");
			}
			if(pthread_rwlockattr_destroy(&attributes) != PTHREAD_RWLOCKATTR_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy global lock attributes");
			}
		}
		processingSignal /*-----*/ = false;
		jmp getProgramArguments;
	}
	getProgramArguments:{
		if(argumentAmount == 1){
			printError("%s%s: %susage:%s %s [argument] [value] or %s [argument] [--help]\n\t[-h], [--help]  \tdisplay this message\n\t[-c], [--config]\tpath to config file, mandatory\n\t[-e], [--error] \tpath to error file, optional\n\t[-s], [--server]\tX server connection, optional\n", colorStart, programName, colorError, colorEnd, programName, programName);
			jmp mainEmergencyExit;
		}
		dec argumentAmount;
		jmp checkErrorRedirection;
	}
	checkErrorRedirection:{
		if(!isatty(fileno(DEFAULT_ERROR_STREAM))){
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
		}
		jmp matchArgumentsLoop;
	}
	matchArgumentsLoop:{
		switch identifyArgument(*(inc argument)) over
			to HELP_ARGUMENT: /*---*/ jmp helpArgument;
			to CONFIG_ARGUMENT: /*-*/ jmp configArgument;
			to ERROR_ARGUMENT: /*--*/ jmp errorArgument;
			to SERVER_ARGUMENT: /*-*/ jmp serverArgument;
			off: /*----------------*/ jmp notAnArgument;
		end
	}
	helpArgument:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s [argument] [value] or %s [argument] [--help]\n\t[-h], [--help]  \tdisplay this message\n\t[-c], [--config]\tpath to config file, mandatory\n\t[-e], [--error] \tpath to error file, optional\n\t[-s], [--server]\tX server connection, optional\n", programName, programName, programName);
		jmp mainEmergencyExit;
	}
	configArgument:{
		if(configPath){
			printTitledError("argument error", "the config argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no config value specified");
			jmp mainEmergencyExit;
		}
		configPath = *(inc argument);
		switch identifyArgument(configPath) over
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp openConfigFile;
			to HELP_ARGUMENT: /*---------*/ jmp displayConfigUsage;
			off: /*----------------------*/ jmp displayNoConfigValue;
		end
	}
	openConfigFile:{
		DIR *const dir = opendir(configPath);
		FILE *file;
		uint32 token = pushPointer(dir, "config directory argument", closedir);
		if(dir){
			closedir(dir);
			popPointer(token);
			printTitledQuotedError("argument error", *argument, "config value is directory");
			jmp mainEmergencyExit;
		}
		file = fopen(configPath, "r");
		token = pushPointer(file, "config file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			jmp matchArgumentLoopControl;
		}
		file = fopen(configPath, "w");
		token = pushPointer(file, "config file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			remove(configPath);
			jmp matchArgumentLoopControl;
		}
		printTitledError("argument error", "could not read or create config file");
		jmp mainEmergencyExit;
	}
	displayConfigUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --config \"/path/to/file\"\n\tif the specified file doesn't exist it will be created\n\tand it will contain the hardcoded default configuration\n", programName, programName);
		jmp mainEmergencyExit;
	}
	displayNoConfigValue:{
		printTitledError("argument error", "no config value specified");
		jmp mainEmergencyExit;
	}
	errorArgument:{
		if(errorPath){
			printTitledError("argument error", "the error argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no error value specified");
			jmp mainEmergencyExit;
		}
		errorPath = *(inc argument);
		switch identifyArgument(errorPath) over
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp openErrorFile;
			to HELP_ARGUMENT: /*---------*/ jmp displayErrorUsage;
			to STDOUT_ARGUMENT: /*-------*/ jmp setErrorStreamStdout;
			to STDERR_ARGUMENT: /*-------*/ jmp setErrorStreamStderr;
			off: /*----------------------*/ jmp displayNoErrorValue;
		end
	}
	openErrorFile:{
		DIR *const dir = opendir(configPath);
		FILE *file;
		uint32 token = pushPointer(dir, "error directory argument", closedir);
		if(dir){
			closedir(dir);
			popPointer(token);
			printTitledQuotedError("argument error", *argument, "error value is directory");
			jmp mainEmergencyExit;
		}
		file = fopen(errorPath, "r");
		token = pushPointer(file, "error file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			mustOpenErrorStream = true;
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
			jmp matchArgumentLoopControl;
		}
		file = fopen(errorPath, "w");
		token = pushPointer(file, "error file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			remove(errorPath);
			mustOpenErrorStream = true;
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
			jmp matchArgumentLoopControl;
		}
		printTitledError("argument error", "could not create error file");
		jmp mainEmergencyExit;
	}
	displayErrorUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --error \"/path/to/file\"\n\tif the specified file doesn't exist it will be created\n", programName, programName);
		jmp mainEmergencyExit;
	}
	setErrorStreamStdout:{
		errorStream = stdout;
		jmp matchArgumentLoopControl;
	}
	setErrorStreamStderr:{
		errorStream = stderr;
		jmp matchArgumentLoopControl;
	}
	displayNoErrorValue:{
		printTitledError("argument error", "no error value specified");
		jmp mainEmergencyExit;
	}
	serverArgument:{
		if(connectionName){
			printTitledError("argument error", "the server argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no server value specified");
			jmp mainEmergencyExit;
		}
		connectionName = *(inc argument);
		switch identifyArgument(connectionName) over
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp matchArgumentLoopControl;
			to HELP_ARGUMENT: /*---------*/ jmp displayServerUsage;
			off: /*----------------------*/ jmp displayNoServerValue;
		end
	}
	displayServerUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --server \"name\"\n\tthe name of the server, if running, should be something like \":0\"\n\tit can be checked with the $DISPLAY variable on a running server (no tty)\n", programName, programName);
		jmp mainEmergencyExit;
	}
	displayNoServerValue:{
		printTitledError("argument error", "no server value specified");
		jmp mainEmergencyExit;
	}
	notAnArgument:{
		printTitledQuotedError("argument error", *argument, "is not recognized as program argument, check help? [-h]");
		jmp mainEmergencyExit;
	}
	matchArgumentLoopControl:{
		if(dec argumentAmount){
			jmp matchArgumentsLoop;
		}
		jmp argumentsFinalCheck;
	}
	argumentsFinalCheck:{
		if(!configPath){
			printTitledError("argument error", "no config argument specified");
			jmp mainEmergencyExit;
		}
		if(errorPath and sensitiveStringCompare(errorPath, configPath)){
			mustOpenErrorStream = false;
			printTitledError("argument error", "config and error files are the same");
			jmp mainEmergencyExit;
		}
		jmp startConcurrentThreads;
	}
	startConcurrentThreads:{
		jmp establishServerConnection;
	}
	establishServerConnection:{
		screenNumber = 0;
		connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
		connectionToken = pushPointer(connection, "X connection", iXCBDisconnect);
		screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		jmp establishDualServerConnection;
	}
	establishDualServerConnection:{
		xcb_disconnect(connection);
		popPointer(connectionToken);
		connection = NULL;
		connectionToken = 0;
		display = XOpenDisplay(connectionName);
		displayToken = pushPointer(display, "X connection", XCloseDisplay);
		if(!display){
			printTitledError("fatal X server error", "could not connect to server");
			jmp mainEmergencyExit;
		}
		screenNumber = DefaultScreen(display);
		connection = XGetXCBConnection(display);
		connectionToken = 0;
		screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		XSetEventQueueOwner(display, XCBOwnsEventQueue);
		jmp checkExtensionAvailability;
	}
	checkExtensionAvailability:{
		#define STRING(f) /*--------*/ { \
			  f("RANDR") \
		}
		#define BASE_POINTER /*-----*/ { \
			  &randrMajorOpcode \
			, &randrBaseEvent \
			, &randrBaseError \
		}
		#define VERSION_FUNCTION /*-*/ { \
			  &randrQueryVersionUnchecked \
		}
		#define MAJOR_VERSION /*----*/ { \
			  XCB_RANDR_MAJOR_VERSION \
		}
		#define MINOR_VERSION /*----*/ { \
			  XCB_RANDR_MINOR_VERSION \
		}
		char *nameStart[] = STRING(SELF);
		uint lengthStart[] = STRING(lengthof);
		xcb_query_extension_cookie_t cookieStart[countof(nameStart)];
		uint8 *basePointerStart[countof(nameStart) * 3] = BASE_POINTER;
		xcb_void_cookie_t (*versionFunctionStart[countof(nameStart)])(xcb_connection_t *, uint32, uint32) = VERSION_FUNCTION;
		uint32 majorVersionStart[countof(nameStart)] = MAJOR_VERSION;
		uint32 minorVersionStart[countof(nameStart)] = MINOR_VERSION;
		xcb_void_cookie_t versionCookieStart[countof(nameStart)];
		char **nameCurrent = nameStart;
		uint *lengthCurrent = lengthStart;
		xcb_query_extension_cookie_t *cookieCurrent = cookieStart;
		uint8 **basePointerCurrent = basePointerStart;
		xcb_void_cookie_t (**versionFunctionCurrent)(xcb_connection_t *, uint32, uint32) = versionFunctionStart;
		uint32 *majorVersionCurrent = majorVersionStart;
		uint32 *minorVersionCurrent = minorVersionStart;
		xcb_void_cookie_t *versionCookieCurrent = versionCookieStart;
		xcb_query_extension_cookie_t *const cookieWall = cookieCurrent + countof(nameStart);
		xcb_void_cookie_t *const versionCookieWall = versionCookieCurrent + countof(nameStart);
		jmp queryExtensionRequestLoop;
		queryExtensionRequestLoop:{
			*cookieCurrent = xcb_query_extension_unchecked(connection, *lengthCurrent, *nameCurrent);
			if(inc cookieCurrent < cookieWall){
				inc nameCurrent;
				inc lengthCurrent;
				jmp queryExtensionRequestLoop;
			}
			cookieCurrent = cookieStart;
			nameCurrent = nameStart;
			lengthCurrent = lengthStart;
			jmp queryExtensionReplyLoop;
		}
		queryExtensionReplyLoop:{
			xcb_query_extension_reply_t *const reply = xcb_wait_for_reply(connection, *cookieCurrent, NULL);
			uint32 token = pushPointer(reply, "query extension reply", iFree);
			(*versionCookieCurrent).sequence = 0;
			**(basePointerCurrent + 0) = 0;
			**(basePointerCurrent + 1) = 0;
			**(basePointerCurrent + 2) = 0;
			if(!reply){
				printTitledNamedError("reply error", "could not get reply for", *nameCurrent);
			}else{
				if(!(*reply).present){
					printTitledQuotedError("extension error", *nameCurrent, "extension is not available");
				}else{
					*versionCookieCurrent = (*versionFunctionCurrent)(connection, *majorVersionCurrent, *minorVersionCurrent);
					**(basePointerCurrent + 0) = (*reply).major_opcode;
					**(basePointerCurrent + 1) = (*reply).first_event;
					**(basePointerCurrent + 2) = (*reply).first_error;
				}
				free(reply);
				popPointer(token);
			}
			if(inc cookieCurrent < cookieWall){
				inc nameCurrent;
				basePointerCurrent += 3;
				inc versionFunctionCurrent;
				inc majorVersionCurrent;
				inc minorVersionCurrent;
				inc versionCookieCurrent;
				jmp queryExtensionReplyLoop;
			}
			versionCookieCurrent = versionCookieStart;
			jmp queryExtensionVersionReplyLoop;
		}
		queryExtensionVersionReplyLoop:{
			if((*versionCookieCurrent).sequence){
				void *const reply = xcb_wait_for_reply(connection, *versionCookieCurrent, NULL);
				uint32 token = pushPointer(reply, "query extension version reply", iFree);
				free(reply);
				popPointer(token);
			}
			if(inc versionCookieCurrent < versionCookieWall){
				jmp queryExtensionVersionReplyLoop;
			}
			jmp setAtoms;
		}
		#undef  MINOR_VERSION
		#undef  MAJOR_VERSION
		#undef  VERSION_FUNCTION
		#undef  BASE_POINTER
		#undef  STRING
	}
	setAtoms:{
		#define STRING(f) /*-*/ { \
			  f("WM_NAME") \
			, f("WM_ICON_NAME") \
			, f("WM_NORMAL_HINTS") \
			, f("WM_SIZE_HINTS") \
			, f("WM_HINTS") \
			, f("WM_CLASS") \
			, f("WM_TRANSIENT_FOR") \
			, f("WM_PROTOCOLS") \
			, f("WM_TAKE_FOCUS") \
			, f("WM_DELETE_WINDOW") \
			, f("WM_COLORMAP_WINDOWS") \
			, f("WM_COLORMAP_NOTIFY") \
			, f("WM_CLIENT_MACHINE") \
			, f("WM_LOCALE_NAME") \
			, f("WM_WINDOW_ROLE") \
			, f("WM_COMMAND") \
			, f("WM_CLIENT_LEADER") \
			, f("WM_STATE") \
			, f("WM_CHANGE_STATE") \
			, f("WM_ICON_SIZE") \
			, f("UTF8_STRING") \
			, f("_NET_SUPPORTED") \
			, f("_NET_CLIENT_LIST") \
			, f("_NET_CLIENT_LIST_STACKING") \
			, f("_NET_NUMBER_OF_DESKTOPS") \
			, f("_NET_DESKTOP_GEOMETRY") \
			, f("_NET_DESKTOP_VIEWPORT") \
			, f("_NET_CURRENT_DESKTOP") \
			, f("_NET_DESKTOP_NAMES") \
			, f("_NET_ACTIVE_WINDOW") \
			, f("_NET_WORKAREA") \
			, f("_NET_SUPPORTING_WM_CHECK") \
			, f("_NET_VIRTUAL_ROOTS") \
			, f("_NET_DESKTOP_LAYOUT") \
			, f("_NET_SHOWING_DESKTOP") \
			, f("_NET_CLOSE_WINDOW") \
			, f("_NET_MOVERESIZE_WINDOW") \
			, f("_NET_WM_MOVERESIZE") \
			, f("_NET_RESTACK_WINDOW") \
			, f("_NET_REQUEST_FRAME_EXTENTS") \
			, f("_NET_WM_NAME") \
			, f("_NET_WM_VISIBLE_NAME") \
			, f("_NET_WM_ICON_NAME") \
			, f("_NET_WM_VISIBLE_ICON_NAME") \
			, f("_NET_WM_DESKTOP") \
			, f("_NET_WM_WINDOW_TYPE") \
			, f("_NET_WM_WINDOW_TYPE_DESKTOP") \
			, f("_NET_WM_WINDOW_TYPE_DOCK") \
			, f("_NET_WM_WINDOW_TYPE_TOOLBAR") \
			, f("_NET_WM_WINDOW_TYPE_MENU") \
			, f("_NET_WM_WINDOW_TYPE_UTILITY") \
			, f("_NET_WM_WINDOW_TYPE_SPLASH") \
			, f("_NET_WM_WINDOW_TYPE_DIALOG") \
			, f("_NET_WM_WINDOW_TYPE_NORMAL") \
			, f("_NET_WM_STATE") \
			, f("_NET_WM_STATE_MODAL") \
			, f("_NET_WM_STATE_STICKY") \
			, f("_NET_WM_STATE_MAXIMIZED_VERT") \
			, f("_NET_WM_STATE_MAXIMIZED_HORZ") \
			, f("_NET_WM_STATE_SHADED") \
			, f("_NET_WM_STATE_SKIP_TASKBAR") \
			, f("_NET_WM_STATE_SKIP_PAGER") \
			, f("_NET_WM_STATE_HIDDEN") \
			, f("_NET_WM_STATE_FULLSCREEN") \
			, f("_NET_WM_STATE_ABOVE") \
			, f("_NET_WM_STATE_BELOW") \
			, f("_NET_WM_STATE_DEMANDS_ATTENTION") \
			, f("_NET_WM_ALLOWED_ACTIONS") \
			, f("_NET_WM_ACTION_MOVE") \
			, f("_NET_WM_ACTION_RESIZE") \
			, f("_NET_WM_ACTION_MINIMIZE") \
			, f("_NET_WM_ACTION_SHADE") \
			, f("_NET_WM_ACTION_STICK") \
			, f("_NET_WM_ACTION_MAXIMIZE_HORZ") \
			, f("_NET_WM_ACTION_MAXIMIZE_VERT") \
			, f("_NET_WM_ACTION_FULLSCREEN") \
			, f("_NET_WM_ACTION_CHANGE_DESKTOP") \
			, f("_NET_WM_ACTION_CLOSE") \
			, f("_NET_WM_STRUT") \
			, f("_NET_WM_STRUT_PARTIAL") \
			, f("_NET_WM_ICON_GEOMETRY") \
			, f("_NET_WM_ICON") \
			, f("_NET_WM_PID") \
			, f("_NET_WM_HANDLED_ICONS") \
			, f("_NET_WM_USER_TIME") \
			, f("_NET_FRAME_EXTENTS") \
			, f("_NET_WM_PING") \
			, f("_NET_WM_SYNC_REQUEST") \
			, f("_NET_WM_SYNC_REQUEST_COUNTER") \
			, f("_NET_SYSTEM_TRAY_ORIENTATION") \
			, f("_NET_SYSTEM_TRAY_OPCODE") \
			, f("_NET_SYSTEM_TRAY_MESSAGE_DATA") \
			, f("_XEMBED_INFO") \
			, f("_XEMBED") \
			, f("_XROOTPMAP_ID") \
		}
		const char *const atomNameStart[] = STRING(SELF);
		const uint atomNameSizeStart[] = STRING(lengthof);
		xcb_intern_atom_cookie_t cookieStart[countof(atomNameStart)];
		const char *const *atomNameCurrent = atomNameStart;
		const uint *atomNameSizeCurrent = atomNameSizeStart;
		xcb_intern_atom_cookie_t *cookieCurrent = cookieStart;
		xcb_intern_atom_cookie_t *const cookieWall = cookieStart + countof(cookieStart);
		xcb_atom_t *atomCurrent = (void *)&atom;
		jmp atomRequestLoop;
		atomRequestLoop:{
			*cookieCurrent = xcb_intern_atom_unchecked(connection, false, *atomNameSizeCurrent, *atomNameCurrent);
			if(inc cookieCurrent < cookieWall){
				inc atomNameSizeCurrent;
				inc atomNameCurrent;
				jmp atomRequestLoop;
			}
			cookieCurrent = cookieStart;
			jmp atomReplyLoop;
		}
		atomReplyLoop:{
			xcb_intern_atom_reply_t *const reply = xcb_wait_for_reply(connection, *cookieCurrent, NULL);
			uint32 token = pushPointer(reply, "atom reply", iFree);
			if(!reply){
				printError("%s%s: %s%s:%s %s %s %s\n", colorStart, programName, colorError, "atom error", colorEnd, "could not get the", *(atomNameStart + (cookieCurrent - cookieStart)), "atom");
			}else{
				*atomCurrent = (*reply).atom;
				free(reply);
				popPointer(token);
			}
			if(inc cookieCurrent < cookieWall){
				inc atomCurrent;
				jmp atomReplyLoop;
			}
			jmp setOtherAtoms;
		}
		#undef  STRING
	}
	setOtherAtoms:{
		jmp selectInput;
	}
	selectInput:{
		const uint32 valueList = XCB_EVENT_MASK_NO_EVENT;
		xcb_void_cookie_t cookie = xcb_change_window_attributes_checked(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
		xcb_generic_error_t *error = xcb_request_check(connection, cookie);
		uint32 token = pushPointer(error, "select input event mask error", iFree);
		if(error){
			printTitledError("select input error", "could not apply to receive root window events");
			free(error);
			popPointer(token);
		}
		cookie = xcb_randr_select_input_checked(connection, (*screen).root, XCB_RANDR_NOTIFY_MASK_SCREEN_CHANGE);
		error = xcb_request_check(connection, cookie);
		token = pushPointer(error, "select input xrandr event mask error", iFree);
		if(error){
			printTitledError("randr select input error", "could not apply to receive monitor events");
			free(error);
			popPointer(token);
		}
		jmp selectExtraInput;
	}
	selectExtraInput:{
		xcb_grab_keyboard_reply_t *reply;
		uint32 token;
		if(!XSupportsLocale()){
			printTitledError("locale error", "current X locale not supported");
		}
		if(!(im = XOpenIM(display, NULL, NULL, NULL))){
			printTitledError("input method error", "could not open input method");
		}elif(!(ic = XCreateIC(im, XNInputStyle, XIMPreeditNothing | XIMStatusNothing, XNClientWindow, (*screen).root, NULL))){
			printTitledError("input context error", "could not open input context");
		}
		reply = xcb_wait_for_reply(connection, xcb_grab_keyboard_unchecked(connection, true, (*screen).root, getTimestamp(), XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC), NULL);
		token = pushPointer(reply, "grab keyboard reply", iFree);
		if(!reply){
			printTitledError("select input error", "could not grab keyboard");
		}else{
			free(reply);
			popPointer(token);
		}
		jmp setupScreenProfile;
	}
	setupScreenProfile:{
		xcb_depth_iterator_t depthIterator = xcb_screen_allowed_depths_iterator(screen);
		xcb_visualtype_iterator_t visualIterator;
		visual = (*screen).root_visual;
		depth = (*screen).root_depth;
		jmp findDepth;
		findDepth:{
			if((*depthIterator.data).depth == 32){
				visualIterator = xcb_depth_visuals_iterator(depthIterator.data);
				jmp findVisual;
			}
			if(!depthIterator.rem){
				printTitledError("screen error", "could not find a 32-bit depth visual, using default screen visual instead");
				jmp setupIDs;
			}
			xcb_depth_next(&depthIterator);
			jmp findDepth;
		}
		findVisual:{
			if((*visualIterator.data)._class == XCB_VISUAL_CLASS_TRUE_COLOR){
				visual = (*visualIterator.data).visual_id;
				depth = (*depthIterator.data).depth;
				jmp setupIDs;
			}
			if(!visualIterator.rem){
				printTitledError("screen error", "could not match 32-bit depth with a true color visual, using default screen visual instead");
				jmp setupIDs;
			}
			dec visualIterator.rem;
			inc visualIterator.data;
			jmp findVisual;
		}
	}
	setupIDs:{
		colormap = xcb_generate_id(connection);
		gc = xcb_generate_id(connection);
		xcb_create_colormap(connection, XCB_COLORMAP_ALLOC_NONE, colormap, (*screen).root, visual);
		xcb_create_gc(connection, gc, (*screen).root, XCB_NONE, NULL);
		jmp storeMonitors;
	}
	storeMonitors:{
		xcb_randr_get_monitors_reply_t *const reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors_unchecked(connection, (*screen).root, true), NULL);
		uint32 replyToken = pushPointer(reply, "monitor reply", iFree);
		Monitor *monitorCurrent;
		Monitor *monitorWall;
		xcb_randr_monitor_info_iterator_t iterator;
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		freeMonitors();
		if(!reply){
			printTitledError("reply error", "could not get monitors");
			monitorAllocated = 0;
			jmp storeMonitorsExit;
		}
		monitorAllocated = (*reply).nMonitors;
		monitorStart = malloc(monitorAllocated * sizeof(Monitor));
		monitorToken = pushPointer(monitorStart, "monitor pointer", iFree);
		if(!monitorStart){
			printTitledError("memory allocation error", "could not store monitor data");
			monitorAllocated = 0;
			free(reply);
			jmp storeMonitorsExit;
		}
		iterator = xcb_randr_get_monitors_monitors_iterator(reply);
		monitorCurrent = monitorStart;
		monitorWall = monitorStart + monitorAllocated;
		jmp storeMonitorLoop;
		storeMonitorLoop:{
			if(monitorCurrent < monitorWall){
				const xcb_randr_monitor_info_t *const data = iterator.data;
				const int x = (*data).x;
				const int y = (*data).y;
				const int w = (*data).width;
				const int h = (*data).height;
				xcb_randr_output_t *outputCurrent;
				xcb_randr_output_t *outputWall;
				if(monitorCurrent > monitorStart){
					const Monitor *current = monitorStart;
					const Monitor *const wall = monitorCurrent;
					jmp removeSameMonitorLoop;
					removeSameMonitorLoop:{
						if(current < wall){
							if((*current).leftX == x and (*current).topY == y and (*current).w == w and (*current).h == h){
								dec monitorAllocated;
								xcb_randr_monitor_info_next(&iterator);
								jmp storeMonitorLoop;
							}
							inc current;
							jmp removeSameMonitorLoop;
						}
					}
				}
				(*monitorCurrent).leftX = x;
				(*monitorCurrent).topY = y;
				(*monitorCurrent).rightX = x + w;
				(*monitorCurrent).bottomY = y + h;
				(*monitorCurrent).w = w;
				(*monitorCurrent).h = h;
				outputCurrent = xcb_randr_monitor_info_outputs(data);
				outputWall = outputCurrent + xcb_randr_monitor_info_outputs_length(data);
				jmp getOutputMillimeterSizeLoop;
				getOutputMillimeterSizeLoop:{
					if(outputCurrent < outputWall){
						xcb_randr_get_output_info_reply_t *const reply = xcb_wait_for_reply(connection, xcb_randr_get_output_info_unchecked(connection, *outputCurrent, getTimestamp()), NULL);
						uint32 token = pushPointer(reply, "get output info reply", iFree);
						if(reply){
							if((*reply).connection == XCB_RANDR_CONNECTION_CONNECTED){
								(*monitorCurrent).millimeterWidth = (*reply).mm_width;
								(*monitorCurrent).millimeterHeight = (*reply).mm_height;
								outputCurrent = outputWall;
							}
							free(reply);
							popPointer(token);
						}
						inc outputCurrent;
						jmp getOutputMillimeterSizeLoop;
					}
					xcb_randr_monitor_info_next(&iterator);
					inc monitorCurrent;
					jmp storeMonitorLoop;
				}
			}
			free(reply);
			popPointer(replyToken);
			jmp trimMonitorMemory;
		}
	}
	trimMonitorMemory:{
		void *temp = realloc(monitorStart, monitorAllocated * sizeof(Monitor));
		updatePointer(monitorToken, temp);
		if(!temp){
			jmp storeMonitorsExit;
		}
		monitorStart = temp;
		jmp storeMonitorsExit;
	}
	storeMonitorsExit:{
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		if(event){
			jmp eventLoop;
		}
		jmp preReadConfig;
	}
	preReadConfig:{
		bulkInsertString(&globalScopesInstructionRoot, globalScopesInstructionList);
		bulkInsertString(&globalInstructionRoot, globalInstructionList);
		bulkInsertString(&scope1ScopeInstructionRoot, scope1ScopeInstructionList);
		bulkInsertString(&booleanRoot, booleanList);
		bulkInsertString(&commandRoot, commandList);
		bulkInsertString(&variableRoot, variableList);
		bulkInsertString(&modifierRoot, modifierList);
		bulkInsertString(&macroRoot, macroList);
		jmp readConfig;
	}
	readConfig:{
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		displaySimpleConfigErrors = true;
		restartCommand();
		setConfigVariables();
		readConfig(true, configPath, fgetc);
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		jmp eventLoopCheckShortcuts;
	}
	eventLoopCheckShortcuts:{
		if(keyPressNextOffset){
			jmp keyPressEvent;
		}
		if(keyReleaseNextOffset){
			jmp keyReleaseEvent;
		}
		if(buttonPressNextOffset){
			jmp buttonPressEvent;
		}
		if(buttonReleaseNextOffset){
			jmp buttonReleaseEvent;
		}
		jmp eventLoop;
	}
	eventLoop:{
		xcb_flush(connection);
		free(event);
		popPointer(eventToken);
		event = NULL;
		eventToken = 0;
		jmp waitForEvent;
	}
	waitForEvent:{
		event = xcb_wait_for_event(connection);
		eventToken = pushPointer(event, "event pointer", iFree);
		if(event){
			jmp switchEvent;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		jmp waitForEvent;
	}
	switchEvent:{
		#define XCB_ONE /*-*/ (1)
		printXEvent(eventName);
		switch (*event).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unrecognizedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp keyPressEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp keyReleaseEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp buttonPressEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp buttonReleaseEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp unexpectedEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp unexpectedEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp genericEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	errorEvent:{
		#define e /*-*/ ((xcb_generic_error_t *)event)
		printXError(errorName);
		jmp eventLoop;
		#undef  e
	}
	keyPressEvent:{
		#define e /*-*/ ((xcb_key_press_event_t *)event)
		XEvent xlibEvent;
		if(getNextShortcut(&keycodeShortcut, (*e).detail, (*e).state, &keyPressNextOffset)){
			jmp switchCommandDown;
		}









		/*!*/
			if((*e).detail == 9){
				jmp mainEmergencyExit;
			}
			xlibEvent.xkey.type = (*e).response_type & ~b(10000000);
			xlibEvent.xkey.send_event = false;
			xlibEvent.xkey.display = display;
			xlibEvent.xkey.window = (*e).event;
			xlibEvent.xkey.root = (*e).root;
			xlibEvent.xkey.subwindow = (*e).child;
			xlibEvent.xkey.time = (*e).time;
			xlibEvent.xkey.x = (*e).event_x;
			xlibEvent.xkey.y = (*e).event_y;
			xlibEvent.xkey.x_root = (*e).root_x;
			xlibEvent.xkey.y_root = (*e).root_y;
			xlibEvent.xkey.state = (*e).state;
			xlibEvent.xkey.keycode = (*e).detail;
			xlibEvent.xkey.same_screen = (*e).same_screen;
			if(!XFilterEvent(&xlibEvent, (*screen).root)){
				char buffer[4];
				int count = Xutf8LookupString(ic, &xlibEvent.xkey, buffer, sizeof(buffer), NULL, NULL);
				if(count){
					fprintf(stdout, " xcb buffer: %.*s\n", count, buffer);
				}
				jmp eventLoop;
			}
			XSetEventQueueOwner(display, XlibOwnsEventQueue);
			jmp xlibEventLoop;
			xlibEventLoop:{
				if(XPending(display)){
					XNextEvent(display, &xlibEvent);
					jmp switchXlibEvent;
				}
				xlibEvent.type = NoEventMask;
				jmp switchXlibEvent;
			}
			switchXlibEvent: switch xlibEvent.type over
				to KeyPress:{
					if(xlibEvent.xkey.keycode == 9){
						jmp mainEmergencyExit;
					}
					if(!XFilterEvent(&xlibEvent, (*screen).root)){
						char buffer[4];
						int count = Xutf8LookupString(ic, &xlibEvent.xkey, buffer, sizeof(buffer), NULL, NULL);
						if(count){
							fprintf(stdout, "xlib buffer: %.*s\n", count, buffer);
						}
					}
					jmp xlibEventLoop;
				}
				off:{
					XSetEventQueueOwner(display, XCBOwnsEventQueue);
					jmp eventLoop;
				}
			end









		jmp eventLoop;
		#undef  e
	}
	keyReleaseEvent:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		if(!keyReleaseNextOffset){
			xcb_query_keymap_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_keymap_unchecked(connection), NULL);
			uint32 token = pushPointer(reply, "query keymap reply", iFree);
			if(reply){
				const bool isPressed = !!(*((*reply).keys + (*e).detail / 8) & (1 << (*e).detail % 8));
				free(reply);
				popPointer(token);
				if(isPressed){
					jmp eventLoop;
				}
			}
		}
		if(getNextShortcut(&keycodeShortcut, (*e).detail, (*e).state, &keyReleaseNextOffset)){
			jmp switchCommandUp;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonPressEvent:{
		#define e /*-*/ ((xcb_button_press_event_t *)event)
		if(getNextShortcut(&buttonShortcut, (*e).detail, (*e).state, &buttonPressNextOffset)){
			jmp switchCommandDown;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonReleaseEvent:{
		#define e /*-*/ ((xcb_button_release_event_t *)event)
		if(getNextShortcut(&buttonShortcut, (*e).detail, (*e).state, &buttonReleaseNextOffset)){
			jmp switchCommandUp;
		}
		jmp eventLoop;
		#undef  e
	}
	genericEvent:{
		#define e /*-*/ ((xcb_ge_generic_event_t *)event)
		jmp unexpectedEvent;
		#undef  e
	}
	extensionEvent:{
		const uint8 eventType = (*event).response_type & ~b(10000000);
		if(eventType >= randrBaseEvent and eventType < randrBaseEvent + countof(randrEventName) - 1){
			jmp switchRandrEvent;
		}
		if(eventType >= randrBaseError and eventType < randrBaseError + countof(randrErrorName) - 1){
			jmp switchRandrError;
		}
		jmp unhandledEvent;
	}
	switchRandrEvent:{
		printXEvent(randrEventName);
		switch ((*event).response_type & ~b(10000000)) - randrBaseEvent over
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY: /*-*/ jmp storeMonitors;
			to XCB_RANDR_NOTIFY: /*---------------*/ jmp storeMonitors;
			off: /*-------------------------------*/ jmp unrecognizedEvent;
		end
	}
	switchRandrError:{
		printXError(randrErrorName);
		switch ((*event).response_type & ~b(10000000)) - randrBaseError over
			to XCB_RANDR_BAD_OUTPUT: /*---*/ jmp eventLoop;
			to XCB_RANDR_BAD_CRTC: /*-----*/ jmp eventLoop;
			to XCB_RANDR_BAD_MODE: /*-----*/ jmp eventLoop;
			to XCB_RANDR_BAD_PROVIDER: /*-*/ jmp eventLoop;
			off: /*-----------------------*/ jmp unrecognizedEvent;
		end
	}
	unrecognizedEvent:{
		printTitledValuedError("X event error", "unrecognized event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unrecognizedError:{
		printTitledValuedError("X event error", "unrecognized error with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
		jmp unrecognizedError;
	}
	unexpectedEvent:{
		printTitledValuedError("unexpected X event", "unexpected event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unhandledEvent:{
		printTitledValuedError("X event error", "unhandled event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	switchCommandDown:{
		printCommand();
		switch (*eventModifierNode).command over
			to NONE_COMMAND: /*----*/ jmp noneCommandDown;
			to EXECUTE_COMMAND: /*-*/ jmp executeCommandDown;
			to RESTART_COMMAND: /*-*/ jmp restartCommandDown;
			to EXIT_COMMAND: /*----*/ jmp exitCommandDown;
			off: /*----------------*/ jmp unrecognizedCommand;
		end
	}
	noneCommandDown:{
		jmp eventLoopCheckShortcuts;
	}
	executeCommandDown:{
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		exec((*eventModifierNode).string);
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		jmp eventLoopCheckShortcuts;
	}
	restartCommandDown:{
		jmp readConfig;
	}
	exitCommandDown:{
		jmp mainEmergencyExit;
	}
	switchCommandUp:{
		printCommand();
		switch (*eventModifierNode).command over
			to NONE_COMMAND: /*----*/ jmp noneCommandUp;
			to EXECUTE_COMMAND: /*-*/ jmp noneCommandUp;
			to RESTART_COMMAND: /*-*/ jmp noneCommandUp;
			to EXIT_COMMAND: /*----*/ jmp noneCommandUp;
			off: /*----------------*/ jmp unrecognizedCommand;
		end
	}
	noneCommandUp:{
		jmp eventLoopCheckShortcuts;
	}
	unrecognizedCommand:{
		printTitledValuedError("command error", "executed unrecognized command with type", (*eventModifierNode).command);
		jmp eventLoopCheckShortcuts;
	}
	mainEmergencyExit:{
		exitCommand();
		ret 0;
	}
}
QUIT(){
	const char *message;
	const Pointer *start;
	const Pointer *current;
	const Pointer *wall;
	jmp evaluateHandlerAvailability;
	evaluateHandlerAvailability:{
		if(quitting){
			switch signal over
				to SIGABRT: /*-*/ brk;
				to SIGBUS: /*--*/ brk;
				to SIGFPE: /*--*/ brk;
				to SIGILL: /*--*/ brk;
				to SIGSEGV: /*-*/ brk;
				to SIGTRAP: /*-*/ brk;
				off: /*--------*/ ret;
			end
			printTitledNamedError("quitting error", "could not free", labelExamined);
			jmp exit;
		}
		if(processingSignal and signal != SIGINT){
			ret;
		}
		processingSignal = true;
		jmp findSignal;
	}
	findSignal: switch signal over
		to SIGABRT: /*-*/ message = "aborted"; /*--------------*/ jmp exitWithError;
		to SIGBUS: /*--*/ message = "hardware faulted"; /*-----*/ jmp exitWithError;
		to SIGFPE: /*--*/ message = "programmer math'd up"; /*-*/ jmp exitWithError;
		to SIGILL: /*--*/ message = "executable corrupted"; /*-*/ jmp exitWithError;
		to SIGINT: /*--*/ message = "interrupted"; /*----------*/ jmp exitWithError;
		to SIGQUIT: /*-*/ message = "voluntarily quitted"; /*--*/ jmp exitWithError;
		to SIGSEGV: /*-*/ message = "segmentation faulted"; /*-*/ jmp exitWithError;
		to SIGTERM: /*-*/ message = "terminated"; /*-----------*/ jmp exitWithError;
		to SIGTRAP: /*-*/ message = "trapped"; /*--------------*/ jmp exitWithError;
		to SIGUSR1: /*-*/ /*-----------------------------------*/ jmp handleUserSignal;
		to SIGUSR2: /*-*/ /*-----------------------------------*/ jmp handleUserSignal;
		off: /*--------*/ message = "unhandled signal"; /*-----*/ jmp exitWithError;
	end
	handleUserSignal:{
		processingSignal = false;
		ret;
	}
	exitWithError:{
		quitting = true;
		printTitledError("signal received", message);
		if(dynamicDataSegment.allocated <= 1){
			jmp exit;
		}
		start = dynamicDataSegment.data;
		current = start + 1;
		wall = start + dynamicDataSegment.allocated;
		switch signal over
			to SIGABRT:
			to SIGBUS:
			to SIGFPE:
			to SIGILL:
			to SIGSEGV:
			to SIGTRAP:{
				printError("%s%s: %spointers at time of error:%s ", colorStart, programName, colorError, colorEnd);
				if(dynamicDataSegment.allocated > 1){
					jmp printPointedVariables;
				}
				printError("none\n");
				jmp freePointedVariablesLoop;
			}
			off:{
				jmp freePointedVariablesLoop;
			}
		end
	}
	printPointedVariables:{
		printUnaccountedForPointers(current, wall);
		current = start + 1;
		jmp freePointedVariablesLoop;
	}
	freePointedVariablesLoop:{
		if((*current).data){
			labelExamined = (*current).label;
			(*current).free((*current).data);
		}
		if(inc current < wall){
			jmp freePointedVariablesLoop;
		}
		jmp exit;
	}
	exit:{
		deleteMemoryManager();
		closeErrorStream();
		exit(EXIT_SUCCESS);
	}
}
GETSHAREDCHARACTER(){
	(void)configFile;
	inc sharedCurrent;
	ret *(sharedCurrent - 1);
}
INITMEMORYMANAGER(){
	#define DYNAMIC_DATA_SEGMENT_BLOCK_SIZE /*-*/ (16)
	#define s /*-------------------------------*/ (dynamicDataSegment)
	s.size = DYNAMIC_DATA_SEGMENT_BLOCK_SIZE;
	s.allocated = 0;
	s.data = malloc(DYNAMIC_DATA_SEGMENT_BLOCK_SIZE * sizeof(Pointer));
	memorySegmentMutexCreated = pthread_mutex_init(&memorySegmentMutex, NULL) == PTHREAD_MUTEX_INIT_SUCCESS;
	if(!memorySegmentMutexCreated){
		printTitledError("pthread error", "could not init memory segment mutex");
	}
	if(!s.data){
		printTitledError("memory allocation error", "could not allocate memory for dynamic memory segment");
		ret false;
	}
	(*s.data).data = (void *)1;
	inc s.allocated;
	ret true;
}
PUSHPOINTER(){
	uint32 token = 0;
	jmp checkPointerValidity;
	checkPointerValidity:{
		if(!s.data or !pointer or !memorySegmentMutexCreated){
			ret 0;
		}
		if(pthread_mutex_lock(&memorySegmentMutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
			printTitledError("pthread error", "could not lock pushPointer() mutex");
		}
		jmp appendPointer;
	}
	appendPointer:{
		Pointer *data;
		token = s.allocated;
		if(token == s.size){
			void *temp;
			s.size += DYNAMIC_DATA_SEGMENT_BLOCK_SIZE;
			if(!(temp = realloc(s.data, s.size * sizeof(Pointer)))){
				token = 0;
				jmp emergencyExit;
			}
			s.data = temp;
		}
		data = s.data + token;
		(*data).label = label;
		(*data).data = pointer;
		(*data).token = token;
		(*data).free = freeFunction;
		inc s.allocated;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memorySegmentMutexCreated and pthread_mutex_unlock(&memorySegmentMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock pushPointer() mutex");
		}
		ret token;
	}
}
POPPOINTER(){
	jmp checkTokenValidity;
	checkTokenValidity:{
		if(!s.data or !token or !memorySegmentMutexCreated){
			ret;
		}
		if(pthread_mutex_lock(&memorySegmentMutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
			printTitledError("pthread error", "could not lock popPointer() mutex");
		}
		(*(s.data + token)).data = NULL;
		jmp trimSegmentLoop;
	}
	trimSegmentLoop:{
		if(!(*(s.data + dec s.allocated)).data){
			jmp trimSegmentLoop;
		}
		inc s.allocated;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memorySegmentMutexCreated and pthread_mutex_unlock(&memorySegmentMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock popPointer() mutex");
		}
		ret;
	}
}
UPDATEPOINTER(){
	jmp checkTokenValidity;
	checkTokenValidity:{
		if(!s.data or !token or !pointer or !memorySegmentMutexCreated){
			ret;
		}
		if(pthread_mutex_lock(&memorySegmentMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock updatePointer() mutex");
		}
		jmp updatePointer;
	}
	updatePointer:{
		(*(s.data + token)).data = pointer;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memorySegmentMutexCreated and pthread_mutex_unlock(&memorySegmentMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock updatePointer() mutex");
		}
		ret;
	}
}
DELETEMEMORYMANAGER(){
	free(s.data);
	if(memorySegmentMutexCreated){
		if(pthread_mutex_destroy(&memorySegmentMutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy memory segment mutex");
		}
		memorySegmentMutexCreated = false;
	}
	ret;
}
IFREE(){
	free(pointer);
	ret 0;
}
ISHMCTL(){
	#define SHMGET_FAILURE /*-*/ (-1)
	const int shmid = (int64)pointer;
	if(shmid != SHMGET_FAILURE){
		shmctl(shmid, IPC_RMID, NULL);
	}
	ret 0;
	#undef  SHMGET_FAILURE
}
IXCBDISCONNECT(){
	xcb_disconnect(pointer);
	ret 0;
	#undef  s
	#undef  DYNAMIC_DATA_SEGMENT_BLOCK_SIZE
}
SHMINIT(){
	#define STAT_FAILURE /*----*/ (-1)
	#define SHMGET_FAILURE /*--*/ (-1)
	#define SHMAT_FAILURE /*---*/ ((void *)-1)
	#define SHMCTL_FAILURE /*--*/ (-1)
	#define SHMDT_FAILURE /*---*/ (-1)
	#define STAT_PATH /*-------*/ ("/dev/shm/" PROGRAM_NAME)
	#define SHM_KEY /*---------*/ (((s.st_dev << 20) & 0xfff00000) | ((s.st_ino << 8) & 0x000fff00) | 0x00000045)
	#define SHARED_SIZE /*-----*/ (65536)
	#define SHM_HEADER_SIZE /*-*/ (sizeof(pthread_mutex_t) + sizeof(pthread_cond_t) + sizeof(uint8))
	#define SHM_FOOTER_SIZE /*-*/ (2)
	#define SHM_BODY_SIZE /*---*/ (SHM_SIZE - SHM_HEADER_SIZE - SHM_FOOTER_SIZE)
	#define SHM_NONE /*--------*/ (0)
	shmRunning = false;
	shmid = SHMGET_FAILURE;
	shmidToken = 0;
	sharedStart = SHMAT_FAILURE;
	sharedToken = 0;
	sharedMutexCreated = false;
	sharedCondCreated = false;
	sharedThreadCreated = false;
	sharedQuittingThread = false;
	ret;
}
SHMCONNECT(){
	def struct stat /*-*/ Stat;
	FILE *file;
	Stat s;
	shmRunning = true;
	jmp createKeyFile;
	createKeyFile:{
		uint32 token;
		file = fopen(STAT_PATH, "w");
		token = pushPointer(file, "shm file", fclose);
		if(!file){
			file = fopen(STAT_PATH, "r");
			token = pushPointer(file, "shm file", fclose);
			if(!file){
				printError("%s%s: %s%s:%s %s %s %s\n", colorStart, programName, colorError, "shared memory error", colorEnd, "could neither create nor read", STAT_PATH, "file");
				ret;
			}
		}
		fclose(file);
		popPointer(token);
		jmp getKeyFileStat;
	}
	getKeyFileStat:{
		if(stat(STAT_PATH, &s) == STAT_FAILURE){
			printTitledError("shared memory error", "could not generate shared memory key");
			ret;
		}
		jmp createSharedMemory;
	}
	createSharedMemory:{
		shmid = shmget(SHM_KEY, SHARED_SIZE, IPC_CREAT | 0600);
		shmidToken = pushPointer((void *)(int64)shmid, "shm id", ishmctl);
		if(shmid == SHMGET_FAILURE){
			printTitledError("shared memory error", "could not create shared memory segment");
			ret;
		}
		jmp attachToSharedMemory;
	}
	attachToSharedMemory:{
		sharedStart = shmat(shmid, NULL, SHM_NONE);
		sharedToken = pushPointer(sharedStart, "shared memory pointer", shmdt);
		if(sharedStart == SHMAT_FAILURE){
			printTitledError("shared memory error", "could not attach to shared memory");
			ret;
		}
		sharedMutex = (void *)sharedStart;
		sharedCond = (void *)(sharedStart + sizeof(pthread_mutex_t));
		*(sharedStart + SHM_HEADER_SIZE - sizeof(uint8)) = EMPTY_SHARED_STATUS;
		jmp createThreadObjects;
	}
	createThreadObjects:{
		pthread_mutexattr_t mutexAttributes;
		pthread_condattr_t condAttributes;
		if(pthread_mutexattr_init(&mutexAttributes) != PTHREAD_MUTEXATTR_INIT_SUCCESS){
			printTitledError("pthread error", "could not init shared mutex attributes");
		}
		if(pthread_mutexattr_setpshared(&mutexAttributes, PTHREAD_PROCESS_SHARED) != PTHREAD_MUTEXATTR_SETPSHARED_SUCCESS){
			printTitledError("pthread error", "could not set shared mutex shared process attribute");
		}
		sharedMutexCreated = pthread_mutex_init(sharedMutex, &mutexAttributes) == PTHREAD_MUTEX_INIT_SUCCESS;
		if(!sharedMutexCreated){
			printTitledError("pthread error", "could not init shared mutex");
		}
		if(pthread_mutexattr_destroy(&mutexAttributes) != PTHREAD_MUTEXATTR_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy shared mutex attributes");
		}
		if(pthread_condattr_init(&condAttributes) != PTHREAD_CONDATTR_INIT_SUCCESS){
			printTitledError("pthread error", "could not init shared cond attributes");
		}
		if(pthread_condattr_setpshared(&condAttributes, PTHREAD_PROCESS_SHARED) != PTHREAD_CONDATTR_SETPSHARED_SUCCESS){
			printTitledError("pthread error", "could not set shared cond shared process attribute");
		}
		sharedCondCreated = pthread_cond_init(sharedCond, &condAttributes) == PTHREAD_COND_INIT_SUCCESS;
		if(!sharedCondCreated){
			printTitledError("pthread error", "could not init shared cond");
		}
		if(pthread_condattr_destroy(&condAttributes) != PTHREAD_CONDATTR_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy shared cond attributes");
		}
		sharedThreadCreated = pthread_create(&sharedThread, NULL, shmMain, NULL) == PTHREAD_CREATE_SUCCESS;
		if(!sharedThreadCreated){
			printTitledError("pthread error", "could not create shared memory thread");
		}
		ret;
	}
}
SHMMAIN(){
	(void)arg;
	if(pthread_mutex_lock(sharedMutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock shared mutex");
	}
	jmp waitIndefinitely;
	waitIndefinitely:{
		if(pthread_cond_wait(sharedCond, sharedMutex) != PTHREAD_COND_WAIT_SUCCESS){
			printTitledError("pthread error", "could not wait shared mutex");
		}
		sharedCurrent = sharedStart + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t);
		if(sharedQuittingThread){
			*sharedCurrent = FULL_SHARED_STATUS;
			if(pthread_mutex_unlock(sharedMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock shared mutex");
			}
			ret NULL;
		}
		if(*sharedCurrent == FULL_SHARED_STATUS){
			if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
				printTitledError("pthread error", "could not lock globals write lock");
			}
			*sharedCurrent = EMPTY_SHARED_STATUS;
			inc sharedCurrent;
			readConfig(false, "transmitter", getSharedCharacter);
			if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock globals write lock");
			}
			*(sharedStart + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t)) = EMPTY_SHARED_STATUS;
		}
		jmp waitIndefinitely;
	}
}
SHMDISCONNECT(){
	if(!shmRunning){
		ret;
	}
	shmRunning = false;
	jmp destroyThreadObjects;
	destroyThreadObjects:{
		sharedQuittingThread = true;
		if(sharedThreadCreated){
			if(sharedMutexCreated and sharedCondCreated){
				if(pthread_mutex_lock(sharedMutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
					printTitledError("pthread error", "could not lock shared mutex");
				}
				if(pthread_cond_signal(sharedCond) != PTHREAD_COND_SIGNAL_SUCCESS){
					printTitledError("pthread error", "could not signal shared thread");
				}
				if(pthread_mutex_unlock(sharedMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock shared mutex");
				}
			}
			if(pthread_join(sharedThread, NULL) != PTHREAD_JOIN_SUCCESS){
				printTitledError("pthread error", "could not join shared thread");
			}
			sharedThreadCreated = false;
		}
		if(sharedCond and sharedCondCreated){
			if(pthread_cond_destroy(sharedCond) != PTHREAD_COND_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy shared cond");
			}
			sharedCondCreated = false;
		}
		if(sharedMutex and sharedMutexCreated){
			if(pthread_mutex_destroy(sharedMutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy shared mutex");
			}
			sharedMutexCreated = false;
		}
		jmp markForDeletion;
	}
	markForDeletion:{
		if(shmid != SHMGET_FAILURE and shmctl(shmid, IPC_RMID, NULL) == SHMCTL_FAILURE){
			printTitledError("shared memory error", "could not mark shared memory for deletion");
			ret;
		}
		popPointer(shmidToken);
		shmid = SHMGET_FAILURE;
		shmidToken = 0;
		jmp detach;
	}
	detach:{
		if(sharedStart != SHMAT_FAILURE and shmdt(sharedStart) == SHMDT_FAILURE){
			printTitledError("shared memory error", "could not detach from shared memory");
			ret;
		}
		popPointer(sharedToken);
		sharedStart = SHMAT_FAILURE;
		sharedToken = 0;
		ret;
	}
	#undef  SHM_NONE
	#undef  SHM_BODY_SIZE
	#undef  SHM_FOOTER_SIZE
	#undef  SHM_HEADER_SIZE
	#undef  SHARED_SIZE
	#undef  SHM_KEY
	#undef  STAT_PATH
	#undef  SHMDT_FAILURE
	#undef  SHMCTL_FAILURE
	#undef  SHMAT_FAILURE
	#undef  SHMGET_FAILURE
	#undef  STAT_FAILURE
}
IDENTIFYARGUMENT(){
	if(*p != '-') jmp findValueArgument;
	inc p;
	if(*p != '-') jmp findShortArgument;
	inc p;
	jmp findLongArgument;
	findValueArgument:{
		if(insensitiveStringCompare("stdout", p)) /*-*/ ret STDOUT_ARGUMENT;
		if(insensitiveStringCompare("stderr", p)) /*-*/ ret STDERR_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
	findShortArgument:{
		if(insensitiveStringCompare("h", p)) /*------*/ ret HELP_ARGUMENT;
		if(insensitiveStringCompare("c", p)) /*------*/ ret CONFIG_ARGUMENT;
		if(insensitiveStringCompare("e", p)) /*------*/ ret ERROR_ARGUMENT;
		if(insensitiveStringCompare("s", p)) /*------*/ ret SERVER_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
	findLongArgument:{
		if(insensitiveStringCompare("help", p)) /*---*/ ret HELP_ARGUMENT;
		if(insensitiveStringCompare("config", p)) /*-*/ ret CONFIG_ARGUMENT;
		if(insensitiveStringCompare("error", p)) /*--*/ ret ERROR_ARGUMENT;
		if(insensitiveStringCompare("server", p)) /*-*/ ret SERVER_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
}
INSENSITIVESTRINGCOMPARE(){
	jmp compareCharacterLoop;
	compareCharacterLoop:{
		char c1 = *s1;
		c1 |= 32 * (c1 >= 'A' and c1 <= 'Z');
		if(*s0 != c1) /*-*/ ret false;
		if(!c1) /*-------*/ ret true;
		inc s0;
		inc s1;
		jmp compareCharacterLoop;
	}
}
SENSITIVESTRINGCOMPARE(){
	jmp compareCharacterLoop;
	compareCharacterLoop:{
		if(*s0 != *s1) /*-*/ ret false;
		if(!*s0) /*-------*/ ret true;
		inc s0;
		inc s1;
		jmp compareCharacterLoop;
	}
}
SETSTRINGROOT(){
	#define DATA_BLOCK_SIZE /*-*/ (256)
	(*root).dataSize = DATA_BLOCK_SIZE;
	(*root).dataAllocated = 0;
	(*root).dataStart = malloc(DATA_BLOCK_SIZE * sizeof(StringNode));
	(*root).dataToken = pushPointer((*root).dataStart, "string tree pointer", iFree);
	(*root).counter = 1;
	(*root).letter = 0;
	(*root).childrenAmount = 0;
	if(!(*root).dataStart){
		printTitledError("memory allocation error", "could not allocate memory for a string tree");
		(*root).dataSize = 0;
	}
	ret;
}
BULKINSERTSTRING(){
	jmp confirmRootValidity;
	confirmRootValidity:{
		if(!(*root).dataStart){
			ret;
		}
		(*root).stringArray = current;
		jmp insertStringLoop;
	}
	insertStringLoop:{
		if(insertString(root, *current) and *(inc current)){
			jmp insertStringLoop;
		}
		jmp trimMemory;
	}
	trimMemory:{
		void *temp;
		(*root).dataSize = (*root).dataAllocated;
		temp = realloc((*root).dataStart, (*root).dataSize * sizeof(StringNode));
		updatePointer((*root).dataToken, temp);
		if(!temp){
			ret;
		}
		(*root).dataStart = temp;
		ret;
	}
}
INSERTSTRING(){
	StringNode *node;
	uint allocated = (*root).dataAllocated;
	uint size = (*root).dataSize;
	StringNode *data = (*root).dataStart;
	jmp findString;
	findString:{
		if(!(node = getStringNode(root, &string))){
			ret false;
		}
		jmp addLetterLoop;
	}
	addLetterLoop:{
		if(allocated == size){
			const uint nodeOffset = node - data;
			void *temp;
			size += DATA_BLOCK_SIZE;
			temp = realloc(data, size * sizeof(StringNode));
			updatePointer((*root).dataToken, temp);
			if(!temp){
				printTitledError("memory allocation error", "could not reallocate memory for string tree nodes");
				size -= DATA_BLOCK_SIZE;
				(*node).letter = b(10000000) | (*root).counter;
				inc (*root).counter;
				(*root).dataStart = data;
				(*root).dataSize = size;
				(*root).dataAllocated = allocated;
				ret false;
			}
			data = temp;
			if(node != (void *)&(*root).letter){
				node = data + nodeOffset;
			}
		}
		if((*node).childrenAmount >= STRING_NODE_CHILDREN_AMOUNT){
			printTitledError("insert string error", "out of space for new children in string node");
			ret false;
		}
		*((*node).offset + (*node).childrenAmount) = allocated;
		inc (*node).childrenAmount;
		node = data + allocated;
		(*node).childrenAmount = 0;
		inc allocated;
		if(*string){
			(*node).letter = *string;
			inc string;
			jmp addLetterLoop;
		}
		(*node).letter = b(10000000) | (*root).counter;
		inc (*root).counter;
		(*root).dataStart = data;
		(*root).dataSize = size;
		(*root).dataAllocated = allocated;
		ret true;
	}
}
GETSTRINGNODE(){
	const uint16 *offsetCurrent;
	const uint16 *offsetWall;
	const char *string;
	StringNode *node;
	StringNode *data;
	char c;
	jmp confirmRootValidity;
	confirmRootValidity:{
		if(!(*root).dataStart){
			ret NULL;
		}
		string = *stringReturn;
		node = (void *)&(*root).letter;
		data = (*root).dataStart;
		jmp findLetterLoop;
	}
	findLetterLoop:{
		offsetCurrent = (*node).offset;
		offsetWall = offsetCurrent + (*node).childrenAmount;
		c = *string;
		c += (c >= 'A' and c <= 'Z') * 32 - (c == '_') * 50;
		jmp nextLetterLoop;
	}
	nextLetterLoop:{
		if(offsetCurrent < offsetWall){
			StringNode *const n = data + *offsetCurrent;
			if(!c and (*n).letter & b(10000000)){
				(*root).returnedCounter = ((*n).letter & ~b(10000000)) - 1;
				*stringReturn = string;
				ret NULL;
			}
			if((*n).letter != c){
				inc offsetCurrent;
				jmp nextLetterLoop;
			}
			node = n;
			inc string;
			jmp findLetterLoop;
		}
		*stringReturn = string;
		ret node;
	}
}
DELETESTRINGROOT(){
	free((*root).dataStart);
	popPointer((*root).dataToken);
	ret;
	#undef  DATA_BLOCK_SIZE
}
SETSHORTCUTROOT(){
	#define MODIFIER_DATA_BLOCK_SIZE /*-*/ (32)
	(*root).modifierSize = MODIFIER_DATA_BLOCK_SIZE;
	(*root).modifierAllocated = 1;
	(*root).modifierNotInUseOffset = 1;
	(*root).modifierStart = malloc((*root).modifierSize * sizeof(ModifierNode));
	(*root).modifierToken = pushPointer((*root).modifierStart, "shortcut modifier list pointer", iFree);
	if(!(*root).modifierStart){
		printTitledError("memory allocation error", "could not allocate shortcut modifier memory");
		(*root).modifierSize = 1;
		jmp emergencyExit;
	}
	{
		uint32 *codeListStartCurrent = (*root).codeListStart;
		uint32 *codeListWallCurrent = (*root).codeListWall;
		uint32 *const codeListStartWall = codeListStartCurrent + SHORTCUT_CODE_AMOUNT;
		jmp initializeCodeListsLoop;
		initializeCodeListsLoop:{
			*codeListStartCurrent = 0;
			*codeListWallCurrent = 0;
			if(inc codeListStartCurrent < codeListStartWall){
				inc codeListWallCurrent;
				jmp initializeCodeListsLoop;
			}
			ret;
		}
	}
	emergencyExit:{
		(*root).modifierSize = 0;
		free((*root).modifierStart);
		popPointer((*root).modifierToken);
		ret;
	}
}
INSERTSHORTCUT(){
	ModifierNode *node;
	if((*root).modifierAllocated == (*root).modifierSize){
		void *temp;
		(*root).modifierSize += MODIFIER_DATA_BLOCK_SIZE;
		temp = realloc((*root).modifierStart, (*root).modifierSize * sizeof(ModifierNode));
		updatePointer((*root).modifierToken, temp);
		if(!temp){
			printTitledError("memory allocation error", "could not reallocate memory for shortcuts");
			(*root).modifierSize -= MODIFIER_DATA_BLOCK_SIZE;
			ret false;
		}
		(*root).modifierStart = temp;
	}
	node = (*root).modifierStart + (*root).modifierNotInUseOffset;
	(*node).inUse = true;
	(*node).command = command;
	(*node).modifier = modifier;
	(*node).nextOffset = 0;
	(*node).string = string;
	(*node).stringToken = stringToken;
	(*node).field0 = field0;
	(*node).field1 = field1;
	(*node).field2 = field2;
	(*node).field3 = field3;
	(*node).field4 = field4;
	if(!*((*root).codeListStart + code)){
		*((*root).codeListStart + code) = (*root).modifierNotInUseOffset;
	}else{
		const uint offset = *((*root).codeListWall + code);
		(*((*root).modifierStart + offset)).nextOffset = (*root).modifierNotInUseOffset - offset;
	}
	*((*root).codeListWall + code) = (*root).modifierNotInUseOffset;
	if((*root).modifierNotInUseOffset == (*root).modifierAllocated){
		inc (*root).modifierAllocated;
		inc (*root).modifierNotInUseOffset;
	}else{
		const ModifierNode *current = node + 1;
		const ModifierNode *const wall = (*root).modifierStart + (*root).modifierAllocated;
		jmp findNextAvailableModifierNodeSlotLoop;
		findNextAvailableModifierNodeSlotLoop:{
			if(current < wall and (*current).inUse){
				inc current;
				jmp findNextAvailableModifierNodeSlotLoop;
			}
			(*root).modifierNotInUseOffset = current - (*root).modifierStart;
		}
	}
	ret true;
}
GETNEXTSHORTCUT(){
	const ModifierNode *current = (*root).modifierStart;
	int offset;
	if(!*nextOffset){
		offset = *((*root).codeListStart + code);
		jmp findShortcutModifierLoop;
	}
	code = shortcutCode;
	modifier = shortcutModifier;
	offset = *nextOffset;
	jmp findShortcutModifierLoop;
	findShortcutModifierLoop:{
		if(offset){
			current += offset;
			if((*current).modifier == modifier){
				shortcutCode = code;
				shortcutModifier = modifier;
				eventModifierNode = current;
				if((*current).nextOffset){
					*nextOffset = current - (*root).modifierStart + (*current).nextOffset;
					ret true;
				}
				*nextOffset = 0;
				ret true;
			}
			offset = (*current).nextOffset;
			jmp findShortcutModifierLoop;
		}
		*nextOffset = 0;
		ret false;
	}
}
REMOVESHORTCUT(){
	ModifierNode *const modifierStart = (*root).modifierStart;
	ModifierNode *node = modifierStart + *((*root).codeListStart + code);
	bool hasRemovedShortcut = false;
	if(node > modifierStart){
		ModifierNode *previousNode = NULL;
		uint modifierAllocated = (*root).modifierAllocated;
		uint modifierNotInUseOffset = (*root).modifierNotInUseOffset;
		jmp removeModifierLoop;
		removeModifierLoop:{
			const int nextOffset = (*node).nextOffset;
			if(modifier == (*node).modifier){
				(*node).inUse = false;
				free((*node).string);
				popPointer((*node).stringToken);
				if(!previousNode){
					*((*root).codeListStart + code) = !!nextOffset * *((*root).codeListStart + code) + nextOffset;
				}else{
					(*previousNode).nextOffset = !!nextOffset * (*previousNode).nextOffset + nextOffset;
				}
				if(node == modifierStart + modifierAllocated - 1){
					if(dec modifierAllocated < modifierNotInUseOffset){
						dec modifierNotInUseOffset;
					}
				}elif(node - modifierStart < modifierNotInUseOffset){
					modifierNotInUseOffset = node - modifierStart;
				}
				hasRemovedShortcut = true;
			}
			if(nextOffset){
				previousNode = node;
				node += nextOffset;
				jmp removeModifierLoop;
			}
			(*root).modifierAllocated = modifierAllocated;
			(*root).modifierNotInUseOffset = modifierNotInUseOffset;
		}
	}
	ret hasRemovedShortcut;
}
UNSETSHORTCUTROOT(){
	if((*root).modifierAllocated > 1){
		const ModifierNode *current = (*root).modifierStart + 1;
		const ModifierNode *const wall = (*root).modifierStart + (*root).modifierAllocated;
		jmp freeStringLoop;
		freeStringLoop:{
			if(current < wall){
				if((*current).inUse){
					free((*current).string);
					popPointer((*current).stringToken);
				}
				inc current;
				jmp freeStringLoop;
			}
		}
	}
	free((*root).modifierStart);
	popPointer((*root).modifierToken);
	ret;
	#undef  MODIFIER_DATA_BLOCK_SIZE
}
UNGRABSHORTCUTS(){
	if(connection){
		if(keycodeShortcut.modifierAllocated > 1){
			xcb_ungrab_key(connection, XCB_GRAB_ANY, (*screen).root, XCB_MOD_MASK_ANY);
		}
		if(buttonShortcut.modifierAllocated > 1){
			xcb_ungrab_button(connection, XCB_BUTTON_INDEX_ANY, (*screen).root, XCB_MOD_MASK_ANY);
		}
	}
	ret;
}
SETCONFIGVARIABLES(){
	ret;
}
READCONFIG(){
	#define STATEMENT_BLOCK_SIZE /*-*/ (256)
	#define DEFAULT_CONFIG_PATH /*--*/ ("/etc/" PROGRAM_NAME "/" PROGRAM_NAME ".conf")
	const Instruction *const *currentScopeInstruction = globalScopeInstruction;
	const char *const *currentScopeInstructionList = globalInstructionList;
	const Instruction *instructionStart;
	const Instruction *instructionStartCopy;
	const Instruction *instructionCurrent;
	const Instruction *name0Instruction;
	const Instruction *name1Instruction;
	const Instruction *name2Instruction;
	const Instruction *name3Instruction;
	const Instruction *name4Instruction;
	const Instruction *nameList0Instruction;
	const Instruction *nameList1Instruction;
	const Instruction *nameList2Instruction;
	const Instruction *nameList3Instruction;
	const Instruction *nameList4Instruction;
	const Instruction *integer0Instruction;
	const Instruction *integer1Instruction;
	const Instruction *integer2Instruction;
	const Instruction *integer3Instruction;
	const Instruction *integer4Instruction;
	const Instruction *string0Instruction;
	const Instruction *string1Instruction;
	const Instruction *string2Instruction;
	const Instruction *string3Instruction;
	const Instruction *string4Instruction;
	const Instruction *execute0Instruction;
	const Instruction *execute1Instruction;
	const Instruction *execute2Instruction;
	const Instruction *execute3Instruction;
	const Instruction *execute4Instruction;
	const Instruction *image0Instruction;
	const Instruction *image1Instruction;
	const Instruction *image2Instruction;
	const Instruction *image3Instruction;
	const Instruction *image4Instruction;
	const char *imageErrorMessage;
	FILE *configFile = NULL;
	uint32 configFileToken;
	uint statementSize = STATEMENT_BLOCK_SIZE;
	char *statementStart = NULL;
	uint32 statementToken = 0;
	char *statementCurrent;
	char *statementWall = NULL;
	char *statementConcreteWall;
	uint8 name0Return;
	uint8 name1Return;
	uint8 name2Return;
	uint8 name3Return;
	uint8 name4Return;
	uint8 nameList0Return;
	uint8 nameList1Return;
	uint8 nameList2Return;
	uint8 nameList3Return;
	uint8 nameList4Return;
	int64 integer0Return;
	int64 integer1Return;
	int64 integer2Return;
	int64 integer3Return;
	int64 integer4Return;
	char *string0Return = NULL;
	uint32 string0Token = 0;
	char *string1Return = NULL;
	uint32 string1Token = 0;
	char *string2Return = NULL;
	uint32 string2Token = 0;
	char *string3Return = NULL;
	uint32 string3Token = 0;
	char *string4Return = NULL;
	uint32 string4Token = 0;
	char *execute0Return = NULL;
	uint32 execute0Token = 0;
	char *execute1Return = NULL;
	uint32 execute1Token = 0;
	char *execute2Return = NULL;
	uint32 execute2Token = 0;
	char *execute3Return = NULL;
	uint32 execute3Token = 0;
	char *execute4Return = NULL;
	uint32 execute4Token = 0;
	Image image0Return;
	Image image1Return;
	Image image2Return;
	Image image3Return;
	Image image4Return;
	JmpPoint jmpPoint;
	uint fileLine = 1;
	uint statementLine = 0;
	char fileChar;
	uint itemAmount;
	char quote = '\0';
	uint currentScopeInstructionListSize = lengthof(globalInstructionList);
	StringNodeRoot *const *const *currentScopeInstructionData = globalScopeInstructionData;
	StringNodeRoot *const *instructionDataStart;
	StringNodeRoot *const *instructionDataStartCopy;
	StringNodeRoot *const *instructionDataCurrent;
	StringNodeRoot *currentScopeInstructionRoot = &globalInstructionRoot;
	image0Return.data = NULL;
	image0Return.dataToken = 0;
	image1Return.data = NULL;
	image1Return.dataToken = 0;
	image2Return.data = NULL;
	image2Return.dataToken = 0;
	image3Return.data = NULL;
	image3Return.dataToken = 0;
	image4Return.data = NULL;
	image4Return.dataToken = 0;
	jmp setupPointers;
	setupPointers:{
		if(getConfigChar == fgetc){
			if(!createConfigFile){
				DIR *const dir = opendir(configPath);
				uint32 token = pushPointer(dir, "config directory argument", closedir);
				if(dir){
					closedir(dir);
					popPointer(token);
					printConfigError("config error", "config file is directory", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
					jmp configEmergencyExit;
				}
			}
			configFile = fopen(configPath, "r");
			configFileToken = pushPointer(configFile, "config file", fclose);
			if(!configFile){
				#define BUFFER_SIZE /*-*/ (4096)
				FILE *defaultConfigFile;
				uint32 defaultConfigFileToken;
				if(!createConfigFile){
					printConfigError("config error", "could not open config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
					jmp configEmergencyExit;
				}
				configFile = fopen(configPath, "w");
				configFileToken = pushPointer(configFile, "config file", fclose);
				if(!configFile){
					printConfigError("config error", "could not create config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
					jmp configEmergencyExit;
				}
				defaultConfigFile = fopen(DEFAULT_CONFIG_PATH, "r");
				defaultConfigFileToken = pushPointer(defaultConfigFile, "default config file", fclose);
				if(!defaultConfigFile){
					remove(configPath);
					printTitledNamedError("config file error", "could not copy default configuration file from", DEFAULT_CONFIG_PATH);
					jmp configEmergencyExit;
				}
				copyConfigFileLoop:{
					char buffer[BUFFER_SIZE];
					size_t bytesRead;
					if((bytesRead = fread(buffer, sizeof(*buffer), sizeof(buffer), defaultConfigFile))){
						if(fwrite(buffer, sizeof(*buffer), bytesRead, configFile) != bytesRead){
							fclose(defaultConfigFile);
							popPointer(defaultConfigFileToken);
							remove(configPath);
							printTitledError("config copying error", "could not copy default config file correctly");
							jmp configEmergencyExit;
						}
						jmp copyConfigFileLoop;
					}
				}
				fclose(defaultConfigFile);
				popPointer(defaultConfigFileToken);
				fclose(configFile);
				popPointer(configFileToken);
				if(!(configFile = fopen(configPath, "r"))){
					printTitledError("config error", "could not open newly written file");
					jmp configEmergencyExit;
				}
				#undef  BUFFER_SIZE
			}
		}
		statementStart = malloc(statementSize * sizeof(char));
		statementToken = pushPointer(statementStart, "statement pointer", iFree);
		if(!statementStart){
			printTitledError("config error", "could not store user data");
			jmp configEmergencyExit;
		}
		jmp getStatementStart;
	}
	getStatementStart:{
		#define EOF_N1 /*----------------------------*/ (EOF)
		#define ZER_00 /*----------------------------*/ ('\0')
		#define EOT_04 /*----------------------------*/ (0x04)
		#define ALR_07 /*----------------------------*/ ('\a')
		#define BSP_08 /*----------------------------*/ ('\b')
		#define TAB_09 /*----------------------------*/ ('\t')
		#define NLN_10 /*----------------------------*/ ('\n')
		#define VTB_11 /*----------------------------*/ ('\v')
		#define FFD_12 /*----------------------------*/ ('\f')
		#define CRE_13 /*----------------------------*/ ('\r')
		#define ESC_27 /*----------------------------*/ ('\e')
		#define SPC_32 /*----------------------------*/ (' ')
		#define DQT_34 /*----------------------------*/ ('\"')
		#define SQT_39 /*----------------------------*/ ('\'')
		#define AST_42 /*----------------------------*/ ('*')
		#define FSL_47 /*----------------------------*/ ('/')
		#define ZER_48 /*----------------------------*/ ('0')
		#define SCL_59 /*----------------------------*/ (';')
		#define QMK_63 /*----------------------------*/ ('?')
		#define BSL_92 /*----------------------------*/ ('\\')
		#define LOA_97 /*----------------------------*/ ('a')
		#define LOB_98 /*----------------------------*/ ('b')
		#define LOF_102 /*---------------------------*/ ('f')
		#define LON_110 /*---------------------------*/ ('n')
		#define LOR_114 /*---------------------------*/ ('r')
		#define LOT_116 /*---------------------------*/ ('t')
		#define LOV_118 /*---------------------------*/ ('v')
		#define OCB_123 /*---------------------------*/ ('{')
		#define BAR_124 /*---------------------------*/ ('|')
		#define CCB_125 /*---------------------------*/ ('}')
		#define GET_STATEMENT_JMP_POINT /*-----------*/ (0)
		#define STORE_WHITESPACE_JMP_POINT /*--------*/ (1)
		#define CHECK_COMMENT_JMP_POINT /*-----------*/ (2)
		#define STORE_BAR_JMP_POINT /*---------------*/ (3)
		#define GET_DOUBLE_QUOTATION_JMP_POINT /*----*/ (4)
		#define GET_SINGLE_QUOTATION_JMP_POINT /*----*/ (5)
		#define HANDLE_ESCAPE_CHARACTER_JMP_POINT /*-*/ (6)
		#define ENTER_SCOPE_JMP_POINT /*-------------*/ (7)
		#define GET_STATEMENT_END_JMP_POINT /*-------*/ (8)
		statementCurrent = statementStart;
		statementConcreteWall = statementStart + statementSize * sizeof(char);
		statementLine = 0;
		itemAmount = 0;
		free(string0Return);
		popPointer(string0Token);
		free(string1Return);
		popPointer(string1Token);
		free(string2Return);
		popPointer(string2Token);
		free(string3Return);
		popPointer(string3Token);
		free(string4Return);
		popPointer(string4Token);
		free(execute0Return);
		popPointer(execute0Token);
		free(execute1Return);
		popPointer(execute1Token);
		free(execute2Return);
		popPointer(execute2Token);
		free(execute3Return);
		popPointer(execute3Token);
		free(execute4Return);
		popPointer(execute4Token);
		free(image0Return.data);
		popPointer(image0Return.dataToken);
		free(image1Return.data);
		popPointer(image1Return.dataToken);
		free(image2Return.data);
		popPointer(image2Return.dataToken);
		free(image3Return.data);
		popPointer(image3Return.dataToken);
		free(image4Return.data);
		popPointer(image4Return.dataToken);
		name0Instruction = NULL;
		name1Instruction = NULL;
		name2Instruction = NULL;
		name3Instruction = NULL;
		name4Instruction = NULL;
		nameList0Instruction = NULL;
		nameList1Instruction = NULL;
		nameList2Instruction = NULL;
		nameList3Instruction = NULL;
		nameList4Instruction = NULL;
		integer0Instruction = NULL;
		integer1Instruction = NULL;
		integer2Instruction = NULL;
		integer3Instruction = NULL;
		integer4Instruction = NULL;
		string0Instruction = NULL;
		string1Instruction = NULL;
		string2Instruction = NULL;
		string3Instruction = NULL;
		string4Instruction = NULL;
		execute0Instruction = NULL;
		execute1Instruction = NULL;
		execute2Instruction = NULL;
		execute3Instruction = NULL;
		execute4Instruction = NULL;
		image0Instruction = NULL;
		image1Instruction = NULL;
		image2Instruction = NULL;
		image3Instruction = NULL;
		image4Instruction = NULL;
		string0Return = NULL;
		string0Token = 0;
		string1Return = NULL;
		string1Token = 0;
		string2Return = NULL;
		string2Token = 0;
		string3Return = NULL;
		string3Token = 0;
		string4Return = NULL;
		string4Token = 0;
		execute0Return = NULL;
		execute0Token = 0;
		execute1Return = NULL;
		execute1Token = 0;
		execute2Return = NULL;
		execute2Token = 0;
		execute3Return = NULL;
		execute3Token = 0;
		execute4Return = NULL;
		execute4Token = 0;
		image0Return.data = NULL;
		image0Return.dataToken = 0;
		image1Return.data = NULL;
		image1Return.dataToken = 0;
		image2Return.data = NULL;
		image2Return.dataToken = 0;
		image3Return.data = NULL;
		image3Return.dataToken = 0;
		image4Return.data = NULL;
		image4Return.dataToken = 0;
		jmp getStatement;
	}
	getStatement: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*--*/ /*---------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*---------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*---------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*---------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; jmp storeWhitespace;
		to VTB_11: /*--*/ /*---------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*---------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*---------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*---------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; jmp getSingleQuotation;
		to FSL_47: /*--*/ /*---------*/ jmp checkCommentStoreCharacter;
		to SCL_59: /*--*/ /*---------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*---------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*---------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*---------*/ jmp handleClosingBracket;
		off: /*--------*/ /*---------*/ jmp getStatementStoreCharacter;
	end
	getDoubleQuotation: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*-*/ /*----------------------------------*/ jmp completeStatement;
		to ZER_00: /*-*/ fileChar = ' '; /*------------------*/ jmp getDoubleQuotationStoreCharacter;
		to EOT_04: /*-*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*-*/ inc fileLine; /*--------------------*/ jmp getDoubleQuotationStoreCharacter;
		to DQT_34: /*-*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*-*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*-------*/ /*----------------------------------*/ jmp getDoubleQuotationStoreCharacter;
	end
	getSingleQuotation: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*-*/ /*----------------------------------*/ jmp completeStatement;
		to ZER_00: /*-*/ fileChar = ' '; /*------------------*/ jmp getSingleQuotationStoreCharacter;
		to EOT_04: /*-*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*-*/ inc fileLine; /*--------------------*/ jmp getSingleQuotationStoreCharacter;
		to SQT_39: /*-*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*-*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*-------*/ /*----------------------------------*/ jmp getSingleQuotationStoreCharacter;
	end
	handleEscapeCharacter: switch fileChar = getConfigChar(configFile) over
		to DQT_34: /*--*/ fileChar = '\"'; jmp storeEscapedCharacter;
		to SQT_39: /*--*/ fileChar = '\''; jmp storeEscapedCharacter;
		to ZER_48: /*--*/ fileChar = '\0'; jmp storeEscapedCharacter;
		to QMK_63: /*--*/ fileChar = '\?'; jmp storeEscapedCharacter;
		to BSL_92: /*--*/ fileChar = '\\'; jmp storeEscapedCharacter;
		to LOA_97: /*--*/ fileChar = '\a'; jmp storeEscapedCharacter;
		to LOB_98: /*--*/ fileChar = '\b'; jmp storeEscapedCharacter;
		to LOF_102: /*-*/ fileChar = '\f'; jmp storeEscapedCharacter;
		to LON_110: /*-*/ fileChar = '\n'; jmp storeEscapedCharacter;
		to LOR_114: /*-*/ fileChar = '\r'; jmp storeEscapedCharacter;
		to LOT_116: /*-*/ fileChar = '\t'; jmp storeEscapedCharacter;
		to LOV_118: /*-*/ fileChar = '\v'; jmp storeEscapedCharacter;
		off: /*--------*/ /*------------*/ jmp getStatementStoreCharacter;
	end
	checkComment: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*--*/ /*-----------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*-----------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*---------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*---------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*---------*/ jmp getSingleQuotation;
		to AST_42: /*--*/ dec statementCurrent; /*-*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ dec statementCurrent; /*-*/ jmp ignoreSingleLineComment;
		to SCL_59: /*--*/ /*-----------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*-----------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*-----------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*-----------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*-----------------------*/ jmp getStatementStoreCharacter;
	end
	ignoreMultipleLineComment: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*-*/ /*---------*/ jmp endOfFile;
		to EOT_04: /*-*/ /*---------*/ jmp endOfFile;
		to NLN_10: /*-*/ inc fileLine; jmp ignoreMultipleLineComment;
		to AST_42: /*-*/ /*---------*/ jmp checkMultipleLineCommentEnd;
		off: /*-------*/ /*---------*/ jmp ignoreMultipleLineComment;
	end
	checkMultipleLineCommentEnd: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*-*/ /*---------*/ jmp endOfFile;
		to EOT_04: /*-*/ /*---------*/ jmp endOfFile;
		to NLN_10: /*-*/ inc fileLine; jmp ignoreMultipleLineComment;
		to FSL_47: /*-*/ /*---------*/ jmp storeWhitespace;
		off: /*-------*/ /*---------*/ jmp ignoreMultipleLineComment;
	end
	ignoreSingleLineComment: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*-*/ /*---------*/ jmp endOfFile;
		to EOT_04: /*-*/ /*---------*/ jmp endOfFile;
		to NLN_10: /*-*/ inc fileLine; jmp storeWhitespace;
		off: /*-------*/ /*---------*/ jmp ignoreSingleLineComment;
	end
	endOfFile:{
		if(statementCurrent == statementStart){
			jmp successfulConfig;
		}
		dec sharedCurrent;
		jmp completeStatement;
	}
	storeWhitespace:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp getStatement;
		}
		inc itemAmount;
		fileChar = '\0';
		jmp getStatementStoreCharacter;
	}
	completeStatement:{
		if(statementCurrent <= statementStart){
			jmp getStatement;
		}
		if(!*(statementCurrent - 1)){
			jmp getStatementEnd;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = GET_STATEMENT_END_JMP_POINT;
		jmp storeCharacter;
	}
	handleOpeningBracket:{
		if(statementCurrent <= statementStart){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray opening bracket error", "could not enter nameless scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		if(*(statementCurrent - 1)){
			inc itemAmount;
			fileChar = '\0';
			jmpPoint = ENTER_SCOPE_JMP_POINT;
			jmp storeCharacter;
		}
		jmp enterScope;
	}
	enterScope:{
		StringNodeRoot *root;
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(currentScopeInstruction == globalScopeInstruction){
			root = &globalScopesInstructionRoot;
		}else{
			printConfigError("invalid scope error", "no scopes inside current scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		if(!findString(root, &statementCurrent)){
			printConfigError("invalid scope error", "invalid scope name", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		if(itemAmount > 1){
			/*!
				missing space between final argument and scope imminent
			*/
			printConfigError("scope argument error", "too many arguments", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, (void *)1, (void *)1, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		currentScopeInstruction = scope1ScopeInstruction;
		currentScopeInstructionData = scope1ScopeInstructionData;
		currentScopeInstructionList = scope1ScopeInstructionList;
		currentScopeInstructionRoot = &scope1ScopeInstructionRoot;
		currentScopeInstructionListSize = lengthof(scope1ScopeInstructionList);
		jmp getStatementStart;
	}
	attemptStoreBar:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp storeBar;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = STORE_BAR_JMP_POINT;
		jmp storeCharacter;
	}
	storeBar:{
		fileChar = '|';
		jmpPoint = STORE_WHITESPACE_JMP_POINT;
		jmp storeCharacter;
	}
	handleClosingBracket:{
		if(statementCurrent > statementStart){
			if(processingSignal){
				dec sharedCurrent;
				jmp completeStatement;
			}
			fseek(configFile, -1, SEEK_CUR);
			jmp completeStatement;
		}
		if(currentScopeInstruction == globalScopeInstruction){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray closing bracket error", "could not drop to previous config scope", '}', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		if(currentScopeInstruction == scope1ScopeInstruction){
			currentScopeInstruction = globalScopeInstruction;
			currentScopeInstructionData = globalScopeInstructionData;
			currentScopeInstructionList = globalInstructionList;
			currentScopeInstructionRoot = &globalInstructionRoot;
			currentScopeInstructionListSize = lengthof(globalInstructionList);
		}
		jmp getStatementStart;
	}
	storeEscapedCharacter:{
		*(statementCurrent - 1) = fileChar;
		if(quote == '\"'){
			jmp getDoubleQuotation;
		}
		jmp getSingleQuotation;
	}
	getStatementStoreCharacter:{
		jmpPoint = GET_STATEMENT_JMP_POINT;
		jmp storeCharacter;
	}
	getDoubleQuotationStoreCharacter:{
		jmpPoint = GET_DOUBLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	getSingleQuotationStoreCharacter:{
		jmpPoint = GET_SINGLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	handleEscapeCharacterStoreCharacter:{
		jmpPoint = HANDLE_ESCAPE_CHARACTER_JMP_POINT;
		jmp storeCharacter;
	}
	checkCommentStoreCharacter:{
		jmpPoint = CHECK_COMMENT_JMP_POINT;
		jmp storeCharacter;
	}
	storeCharacter:{
		if(statementCurrent >= statementConcreteWall){
			const uint offset = statementCurrent - statementStart;
			void *temp;
			statementSize += STATEMENT_BLOCK_SIZE;
			temp = realloc(statementStart, statementSize * sizeof(char));
			updatePointer(statementToken, temp);
			if(!temp){
				printConfigError("memory allocation error", "could not reallocate memory for config statement", ';', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
				statementSize -= STATEMENT_BLOCK_SIZE;
				jmp getStatementStart;
			}
			statementStart = temp;
			statementCurrent = statementStart + offset;
			statementConcreteWall = statementStart + statementSize * sizeof(char);
		}
		if(jmpPoint != CHECK_COMMENT_JMP_POINT and !statementLine){
			statementLine = fileLine;
		}
		*statementCurrent = fileChar;
		inc statementCurrent;
		switch jmpPoint over
			to GET_STATEMENT_JMP_POINT: /*-----------*/ jmp getStatement;
			to STORE_WHITESPACE_JMP_POINT: /*--------*/ jmp storeWhitespace;
			to CHECK_COMMENT_JMP_POINT: /*-----------*/ jmp checkComment;
			to STORE_BAR_JMP_POINT: /*---------------*/ jmp storeBar;
			to GET_DOUBLE_QUOTATION_JMP_POINT: /*----*/ jmp getDoubleQuotation;
			to GET_SINGLE_QUOTATION_JMP_POINT: /*----*/ jmp getSingleQuotation;
			to HANDLE_ESCAPE_CHARACTER_JMP_POINT: /*-*/ jmp handleEscapeCharacter;
			to ENTER_SCOPE_JMP_POINT: /*-------------*/ jmp enterScope;
			off: /*----------------------------------*/ jmp getStatementEnd;
		end
	}
	getStatementEnd:{
		if(statementCurrent > statementStart) /*-*/ jmp findStatement;
		if(!feof(configFile)) /*-----------------*/ jmp getStatementStart;
		/*---------------------------------------*/ jmp successfulConfig;
		#undef  GET_STATEMENT_END_JMP_POINT
		#undef  ENTER_SCOPE_JMP_POINT
		#undef  HANDLE_ESCAPE_CHARACTER_JMP_POINT
		#undef  GET_SINGLE_QUOTATION_JMP_POINT
		#undef  GET_DOUBLE_QUOTATION_JMPPOINT
		#undef  STORE_BAR_JMP_POINT
		#undef  CHECK_COMMENT_JMP_POINT
		#undef  STORE_WHITESPACE_JMP_POINT
		#undef  GET_STATEMENT_JMP_POINT
		#undef  CCB_125
		#undef  BAR_124
		#undef  OCB_123
		#undef  LOV_118
		#undef  LOT_116
		#undef  LOR_114
		#undef  LON_110
		#undef  LOF_102
		#undef  LOB_98
		#undef  LOA_97
		#undef  BSL_92
		#undef  QMK_63
		#undef  SCL_59
		#undef  ZER_48
		#undef  FSL_47
		#undef  AST_42
		#undef  SQT_39
		#undef  DQT_34
		#undef  SPC_32
		#undef  ESC_27
		#undef  CRE_13
		#undef  FFD_12
		#undef  VTB_11
		#undef  NLN_10
		#undef  TAB_09
		#undef  BSP_08
		#undef  ALR_07
		#undef  EOT_04
		#undef  ZER_00
		#undef  EOF_N1
	}
	findStatement:{
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(!findString(currentScopeInstructionRoot, &statementCurrent)){
			printConfigError("config error", "unrecognized instruction", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp printAllInstructionPatterns;
		}
		instructionStart = *(currentScopeInstruction + (*currentScopeInstructionRoot).returnedCounter);
		instructionStartCopy = instructionStart;
		instructionCurrent = instructionStart;
		instructionDataStart = *(currentScopeInstructionData + (*currentScopeInstructionRoot).returnedCounter);
		instructionDataStartCopy = instructionDataStart;
		instructionDataCurrent = instructionDataStart;
		if(*instructionCurrent == NONE_INSTRUCTION_TYPE){
			jmp unimplementedInstruction;
		}
		if(statementCurrent >= statementWall and *instructionCurrent != END_INSTRUCTION_TYPE){
			printConfigError("config error", "missing instruction body", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		inc statementCurrent;
		jmp switchInstructionLoop;
	}
	switchInstructionLoop: switch *instructionCurrent over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp unimplementedInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp matchName;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp matchNameList;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp matchInteger;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp matchString;
		to EXECUTE_INSTRUCTION_TYPE: /*---*/ jmp matchExecuteString;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp matchImageString;
		off: /*---------------------------*/ jmp endOfInstruction;
	end
	unimplementedInstruction:{
		printConfigError("implementation error", "using unimplemented instruction", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	matchName:{
		char *s;
		uint8 *namePointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!name0Instruction){
			namePointer = &name0Return;
			name0Instruction = instructionCurrent;
		}elif(!name1Instruction){
			namePointer = &name1Return;
			name1Instruction = instructionCurrent;
		}elif(!name2Instruction){
			namePointer = &name2Return;
			name2Instruction = instructionCurrent;
		}elif(!name3Instruction){
			namePointer = &name3Return;
			name3Instruction = instructionCurrent;
		}else{
			namePointer = &name4Return;
			name4Instruction = instructionCurrent;
		}
		s = statementCurrent;
		if(!findString(*instructionDataCurrent, &s)){
			printConfigError("match string error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		statementCurrent = s;
		inc statementCurrent;
		*namePointer = (**instructionDataCurrent).returnedCounter;
		jmp advanceDataInstruction;
	}
	matchNameList:{
		uint8 *nameListPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!nameList0Instruction){
			nameListPointer = &nameList0Return;
			nameList0Instruction = instructionCurrent;
		}elif(!nameList1Instruction){
			nameListPointer = &nameList1Return;
			nameList1Instruction = instructionCurrent;
		}elif(!nameList2Instruction){
			nameListPointer = &nameList2Return;
			nameList2Instruction = instructionCurrent;
		}elif(!nameList3Instruction){
			nameListPointer = &nameList3Return;
			nameList3Instruction = instructionCurrent;
		}else{
			nameListPointer = &nameList4Return;
			nameList4Instruction = instructionCurrent;
		}
		switch matchNameList(*instructionDataCurrent, statementWall, &statementCurrent, nameListPointer) over
			to INVALID_NAME_NAME_LIST: /*--*/ jmp invalidNameNameList;
			to PREMATURE_END_NAME_LIST: /*-*/ jmp prematureEndNameList;
			off: /*------------------------*/ jmp advanceDataInstruction;
		end
	}
	invalidNameNameList:{
		printConfigError("bar list error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	prematureEndNameList:{
		printConfigError("bar list error", "missing final name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	matchInteger:{
		int64 *integerPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!integer0Instruction){
			integerPointer = &integer0Return;
			integer0Instruction = instructionCurrent;
		}elif(!integer1Instruction){
			integerPointer = &integer1Return;
			integer1Instruction = instructionCurrent;
		}elif(!integer2Instruction){
			integerPointer = &integer2Return;
			integer2Instruction = instructionCurrent;
		}elif(!integer3Instruction){
			integerPointer = &integer3Return;
			integer3Instruction = instructionCurrent;
		}else{
			integerPointer = &integer4Return;
			integer4Instruction = instructionCurrent;
		}
		switch matchInteger(&statementCurrent, statementWall, integerPointer) over
			to NON_NUMBER_NUMBER: /*-------*/ jmp printNonNumberError;
			to OVERFLOWN_NUMBER_NUMBER: /*-*/ jmp printOverflownNumberError;
			to DIVIDED_BY_ZERO_NUMBER: /*--*/ jmp printDividedByZeroNumberError;
			off: /*------------------------*/ jmp advanceInstruction;
		end
	}
	printNonNumberError:{
		printConfigError("match integer error", "not a number", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printOverflownNumberError:{
		printConfigError("match integer error", "integer overflow", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printDividedByZeroNumberError:{
		printConfigError("match integer error", "integer divided by zero", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	matchString:{
		char **stringPointer;
		uint32 *stringTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!string0Instruction){
			stringPointer = &string0Return;
			stringTokenPointer = &string0Token;
			string0Instruction = instructionCurrent;
		}elif(!string1Instruction){
			stringPointer = &string1Return;
			stringTokenPointer = &string1Token;
			string1Instruction = instructionCurrent;
		}elif(!string2Instruction){
			stringPointer = &string2Return;
			stringTokenPointer = &string2Token;
			string2Instruction = instructionCurrent;
		}elif(!string3Instruction){
			stringPointer = &string3Return;
			stringTokenPointer = &string3Token;
			string3Instruction = instructionCurrent;
		}else{
			stringPointer = &string4Return;
			stringTokenPointer = &string4Token;
			string4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, stringPointer, stringTokenPointer)){
			printConfigError("match string error", "could not allocate string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchExecuteString:{
		char **executePointer;
		uint32 *executeTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!execute0Instruction){
			executePointer = &execute0Return;
			executeTokenPointer = &execute0Token;
			execute0Instruction = instructionCurrent;
		}elif(!execute1Instruction){
			executePointer = &execute1Return;
			executeTokenPointer = &execute1Token;
			execute1Instruction = instructionCurrent;
		}elif(!execute2Instruction){
			executePointer = &execute2Return;
			executeTokenPointer = &execute2Token;
			execute2Instruction = instructionCurrent;
		}elif(!execute3Instruction){
			executePointer = &execute3Return;
			executeTokenPointer = &execute3Token;
			execute3Instruction = instructionCurrent;
		}else{
			executePointer = &execute4Return;
			executeTokenPointer = &execute4Token;
			execute4Instruction = instructionCurrent;
		}
		if(!matchExecute(&statementCurrent, executePointer, executeTokenPointer)){
			printConfigError("match execute error", "could not allocate execute string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchImageString:{
		char *string = NULL;
		uint32 token = 0;
		Image *imagePointer;
		uint8 readImageReturn;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!image0Instruction){
			imagePointer = &image0Return;
			image0Instruction = instructionCurrent;
		}elif(!image1Instruction){
			imagePointer = &image1Return;
			image1Instruction = instructionCurrent;
		}elif(!image2Instruction){
			imagePointer = &image2Return;
			image2Instruction = instructionCurrent;
		}elif(!image3Instruction){
			imagePointer = &image3Return;
			image3Instruction = instructionCurrent;
		}else{
			imagePointer = &image4Return;
			image4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, &string, &token)){
			printConfigError("match image error", "could not allocate image string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		readImageReturn = readImage(string, &imageErrorMessage, &image0Return);
		free(string);
		popPointer(token);
		switch readImageReturn over
			to CANNOT_OPEN_READ_CONFIG: /*--------*/ jmp printCannotOpenReadConfig;
			to CANNOT_READ_READ_CONFIG: /*--------*/ jmp printCannotReadReadConfig;
			to UNSUPPORTED_FORMAT_READ_CONFIG: /*-*/ jmp printUnsupportedFormatReadConfig;
			to BAD_HEADER_READ_CONFIG: /*---------*/ jmp printBadHeaderReadConfig;
			to BAD_DEPTH_READ_CONFIG: /*----------*/ jmp printBadDepthReadConfig;
			to BAD_COMPRESSION_READ_CONFIG: /*----*/ jmp printBadCompressionReadConfig;
			to UNSUPPORTED_HEIGHT_READ_CONFIG: /*-*/ jmp printUnsupportedHeightReadConfig;
			to BAD_SIZE_READ_CONFIG: /*-----------*/ jmp printBadSizeReadConfig;
			to FAILED_READ_CONFIG: /*-------------*/ jmp printFailedReadConfig;
			to BAD_PIXELS_READ_CONFIG: /*---------*/ jmp printBadPixelsReadConfig;
			to BAD_IMAGE_READ_CONFIG: /*----------*/ jmp printBadImageReadConfig;
			off: /*-------------------------------*/ jmp advanceInstruction;
		end
	}
	printCannotOpenReadConfig:{
		printConfigError("match image error", "could not open image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printCannotReadReadConfig:{
		printConfigError("match image error", "could not read image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printUnsupportedFormatReadConfig:{
		printConfigError("match image error", "image file not bmp", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadHeaderReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadDepthReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadCompressionReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printUnsupportedHeightReadConfig:{
		printConfigError("match image error", "negative height is not supported", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadSizeReadConfig:{
		printConfigError("match image error", "could not traverse image past the header", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printFailedReadConfig:{
		printConfigError("match image error", "could not allocate pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadPixelsReadConfig:{
		printConfigError("match image error", "could not read pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadImageReadConfig:{
		printConfigError("match image error", "image is broken", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	endOfInstruction:{
		if(instructionStart == doInstruction){
			#define applySubinstruction(s, i) /*-*/ instructionStart = s##i##Subinstruction; instructionDataStart = s##i##SubinstructionData
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, Do); jmp assessSubinstruction;
				off: /*----------------*/ /*-----------------------------*/ brk;
			}
		}
		if(instructionStart == setInstruction){
			switch name0Return over
				/*!*/
				off: /*-*/ brk;
			end
		}
		if(instructionStart == grabKeycodeInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabKeycode); jmp assessSubinstruction;
				off: /*----------------*/ /*--------------------------------------*/ brk;
			}
		}
		if(instructionStart == grabButtonInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabButton); jmp assessSubinstruction;
				off: /*----------------*/ /*-------------------------------------*/ brk;
			}
			#undef  useSubinstruction
		}
		if(statementCurrent < statementWall){
			printConfigError("config error", "extra parameters error", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		if(instructionStartCopy == helpInstruction){
			printError("%s%s: %s: line %u: %s%s:%s %s:\n", colorStart, programName, configPath, statementLine, colorError, "config help menu", colorEnd, displaySimpleConfigErrors? "contracted" : "expanded");
			jmp printAllInstructionPatterns;
		}
		if(instructionStartCopy == expandInstruction){
			displaySimpleConfigErrors = false;
			jmp getStatementStart;
		}
		if(instructionStartCopy == contractInstruction){
			displaySimpleConfigErrors = true;
			jmp getStatementStart;
		}
		if(instructionStartCopy == readConfigInstruction){
			readConfig(false, string0Return, fgetc);
			jmp getStatementStart;
		}
		if(instructionStartCopy == useMessengerInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(shmRunning){
						printConfigError("config error", "shared memory messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					shmConnect();
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!shmRunning){
						printConfigError("config error", "shared memory messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					shmDisconnect();
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == doInstruction){
			switch name0Return over
				to EXECUTE_COMMAND:{
					exec(execute0Return);
					jmp getStatementStart;
				}
				to RESTART_COMMAND:{
					if(getConfigChar == getSharedCharacter){
						/*! undo what needs to be undone, restartCommand(), continue execution */
						jmp getStatementStart;
					}
					jmp getStatementStart;
				}
				to EXIT_COMMAND:{
					exitCommand();
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
			jmp printDoSubinstructionNotImplemented;
			printDoSubinstructionNotImplemented:{
				printConfigError("config error", "do subinstruction not implemented yet", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionStart, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
				jmp getStatementStart;
			}
		}
		if(instructionStartCopy == setInstruction){
			switch name0Return over
				/*!*/
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == grabKeycodeInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			if(!insertShortcut(&keycodeShortcut, integer0Return, nameList0Return, name0Return, execute0Return, execute0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
				jmp getStatementStart;
			}
			execute0Return = NULL;
			execute0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_key_checked(connection, true, (*screen).root, nameList0Return, integer0Return, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab key on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == grabButtonInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			if(!insertShortcut(&buttonShortcut, integer0Return, nameList0Return, name0Return, execute0Return, execute0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
				jmp getStatementStart;
			}
			execute0Return = NULL;
			execute0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_button_checked(connection, true, (*screen).root, XCB_EVENT_MASK_NO_EVENT, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, integer0Return, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab button on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabKeycodeInstruction){
			if(!removeShortcut(&keycodeShortcut, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find key to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_key_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab key from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabButtonInstruction){
			if(!removeShortcut(&buttonShortcut, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find button to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_button_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab button from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == stopInstruction){
			jmp successfulConfig;
		}
		jmp getStatementStart;
	}
	advanceInstruction:{
		inc instructionCurrent;
		jmp switchInstructionLoop;
	}
	advanceDataInstruction:{
		inc instructionCurrent;
		inc instructionDataCurrent;
		jmp switchInstructionLoop;
	}
	assessSubinstruction:{
		instructionCurrent = instructionStart + (instructionCurrent - instructionStartCopy);
		instructionDataCurrent = instructionDataStart + (instructionDataCurrent - instructionDataStartCopy);
		if(statementCurrent < statementWall){
			jmp switchInstructionLoop;
		}
		jmp printMissingArgumentError;
	}
	printMissingArgumentError:{
		printConfigError("config error", "missing argument error", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printAllInstructionPatterns:{
		const char *const *const wall = currentScopeInstructionList + currentScopeInstructionListSize;
		const char *const *current = currentScopeInstructionList;
		const Instruction *const *in = currentScopeInstruction;
		StringNodeRoot *const *const *da = currentScopeInstructionData;
		jmp printExpandedHelpInstructions;
		printExpandedHelpInstructions:{
			const Instruction *n = *in - 1;
			StringNodeRoot *const *d = *da;
			printError("\tpattern | %s", *current);
			jmp printHelpInstructionParametersLoop;
			printHelpInstructionParametersLoop: switch *(inc n) over
				to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
				to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
				to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
				to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
				to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
				to EXECUTE_INSTRUCTION_TYPE: /*---*/ jmp executeInstruction;
				to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
				off: /*---------------------------*/ jmp printHelpInstructionParametersLoopExit;
			end
			noneInstruction:{
				printError(" <unimplemented>");
				jmp printHelpInstructionParametersLoopExit;
			}
			nameInstruction:{
				const char *const *stringArray;
				if(displaySimpleConfigErrors){
					printError(" name");
					jmp printHelpInstructionParametersLoop;
				}
				stringArray = (**d).stringArray;
				printError(" (%s", *stringArray);
				inc stringArray;
				printNameLoop:{
					if(*stringArray){
						printError("|%s", *stringArray);
						inc stringArray;
						jmp printNameLoop;
					}
				}
				printError(")");
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			nameListInstruction:{
				const char *const *stringArray;
				if(displaySimpleConfigErrors){
					printError(" list");
					jmp printHelpInstructionParametersLoop;
				}
				stringArray = (**d).stringArray;
				printError(" ((%s", *stringArray);
				inc stringArray;
				printNameListOnceLoop:{
					if(*stringArray){
						printError("|%s", *stringArray);
						inc stringArray;
						jmp printNameListOnceLoop;
					}
				}
				stringArray = (**d).stringArray;
				printError(")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
				inc stringArray;
				printNameListTwiceLoop:{
					if(*stringArray){
						printError("|%s", *stringArray);
						inc stringArray;
						jmp printNameListTwiceLoop;
					}
				}
				printError("))*(?![\\s]*[|]))");
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			numberInstruction:{
				if(displaySimpleConfigErrors){
					printError(" number");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
				jmp printHelpInstructionParametersLoop;
			}
			stringInstruction:{
				if(displaySimpleConfigErrors){
					printError(" string");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			executeInstruction:{
				if(displaySimpleConfigErrors){
					printError(" execute");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			imageInstruction:{
				if(displaySimpleConfigErrors){
					printError(" image");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
		}
		printHelpInstructionParametersLoopExit:{
			inc in;
			inc da;
			if(displaySimpleConfigErrors){
				printError("\n");
			}else{
				printError(" $\n");
			}
			if(inc current < wall){
				jmp printExpandedHelpInstructions;
			}
			printError("\n");
		}
		jmp getStatementStart;
	}
	successfulConfig:{
		if(currentScopeInstruction != globalScopeInstruction){
			*statementCurrent = '\0';
			statementWall = statementCurrent;
			statementLine = fileLine;
			if(fileLine != 1){
				dec statementLine;
			}
			printConfigError("config error", "missing closing scope bracket", '\0', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
		}
		jmp configEmergencyExit;
	}
	configEmergencyExit:{
		if(configFile and fileLine == 1 and !statementLine){
			printConfigError("config error", "empty config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
		}
		free(statementStart);
		popPointer(statementToken);
		if(configFile){
			fclose(configFile);
			popPointer(configFileToken);
		}
		jmp postReadConfig;
	}
	postReadConfig:{
		xcb_flush(connection);
		ret;
	}
	#undef  DEFAULT_CONFIG_PATH
	#undef  STATEMENT_BLOCK_SIZE
}
MATCHNAMELIST(){
	char *current = *statementCurrentReturn;
	uint value = 0;
	jmp matchNameLoop;
	matchNameLoop:{
		if(!findString(root, &current)){
			ret INVALID_NAME_NAME_LIST;
		}
		value |= !!(*root).returnedCounter * (1 << ((*root).returnedCounter - 1));
		jmp matchBar;
	}
	matchBar: switch *(inc current) over
		to '\0': /*-*/ jmp endCheck;
		to '|': /*--*/ jmp advance;
		off: /*-----*/ jmp successful;
	end
	endCheck:{
		if(current >= statementWall){
			jmp successful;
		}
		jmp matchBar;
	}
	advance:{
		if(inc current >= statementWall){
			ret PREMATURE_END_NAME_LIST;
		}
		inc current;
		jmp matchNameLoop;
	}
	successful:{
		*valueReturn = value;
		*statementCurrentReturn = current;
		ret SUCCESS_NAME_LIST;
	}
}
MATCHINTEGER(){
	#define LEVEL0_JMP_POINT /*-*/ (0)
	#define LEVEL1_JMP_POINT /*-*/ (1)
	#define LEVEL2_JMP_POINT /*-*/ (2)
	char *current = *statementCurrent - 1;
	int64 number = 0;
	char op = '\0';
	JmpPoint jmpPoint;
	int64 i0 = 0;
	int64 i1 = 0;
	char o0 = '\0';
	char o1 = '\0';
	jmpPoint = LEVEL0_JMP_POINT;
	jmp matchWhitespace0Loop;
	matchWhitespace0Loop:{
		if(inc current >= statementWall){
			number = 0;
			op = '\0';
			jmp matchOperationReturnPoint;
		}
		switch *current over
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace0Loop;
			to '\n': /*-*/ jmp matchWhitespace0Loop;
			to '\v': /*-*/ jmp matchWhitespace0Loop;
			to '\f': /*-*/ jmp matchWhitespace0Loop;
			to '\r': /*-*/ jmp matchWhitespace0Loop;
			to ' ': /*--*/ jmp matchWhitespace0Loop;
			off: /*-----*/ jmp matchInteger;
		end
	}
	matchInteger:{
		number = 0;
		dec current;
		jmp initialCheck;
	}
	initialCheck: switch *(inc current) over
		to '0': /*-*/ /*--------*/ jmp formatCheck;
		to '1': /*-*/ dec current; jmp matchDecimalLoop;
		to '2': /*-*/ dec current; jmp matchDecimalLoop;
		to '3': /*-*/ dec current; jmp matchDecimalLoop;
		to '4': /*-*/ dec current; jmp matchDecimalLoop;
		to '5': /*-*/ dec current; jmp matchDecimalLoop;
		to '6': /*-*/ dec current; jmp matchDecimalLoop;
		to '7': /*-*/ dec current; jmp matchDecimalLoop;
		to '8': /*-*/ dec current; jmp matchDecimalLoop;
		to '9': /*-*/ dec current; jmp matchDecimalLoop;
		to '+': /*-*/ /*--------*/ jmp matchOperation;
		to '-': /*-*/ /*--------*/ jmp matchOperation;
		to '*': /*-*/ /*--------*/ jmp matchOperation;
		to '/': /*-*/ /*--------*/ jmp matchOperation;
		off: /*----*/ /*--------*/ jmp matchMacro;
	end
	formatCheck: switch *(inc current) over
		to '\0': /*-*/ /*--------*/ jmp matchOperation;
		to '\t': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ /*--------*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ dec current; jmp matchOctalLoop;
		to '1': /*--*/ dec current; jmp matchOctalLoop;
		to '2': /*--*/ dec current; jmp matchOctalLoop;
		to '3': /*--*/ dec current; jmp matchOctalLoop;
		to '4': /*--*/ dec current; jmp matchOctalLoop;
		to '5': /*--*/ dec current; jmp matchOctalLoop;
		to '6': /*--*/ dec current; jmp matchOctalLoop;
		to '7': /*--*/ dec current; jmp matchOctalLoop;
		to 'B': /*--*/ /*--------*/ jmp matchBinaryLoop;
		to 'b': /*--*/ /*--------*/ jmp matchBinaryLoop;
		to 'X': /*--*/ /*--------*/ jmp matchHexadecimalLoop;
		to 'x': /*--*/ /*--------*/ jmp matchHexadecimalLoop;
		to '+': /*--*/ /*--------*/ jmp matchOperation;
		to '-': /*--*/ /*--------*/ jmp matchOperation;
		to '*': /*--*/ /*--------*/ jmp matchOperation;
		to '/': /*--*/ /*--------*/ jmp matchOperation;
		off: /*-----*/ /*--------*/ jmp nonNumber;
	end
	matchBinaryLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateBinary;
		to '1': /*--*/ jmp calculateBinary;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchOctalLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateOctal;
		to '1': /*--*/ jmp calculateOctal;
		to '2': /*--*/ jmp calculateOctal;
		to '3': /*--*/ jmp calculateOctal;
		to '4': /*--*/ jmp calculateOctal;
		to '5': /*--*/ jmp calculateOctal;
		to '6': /*--*/ jmp calculateOctal;
		to '7': /*--*/ jmp calculateOctal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchDecimalLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateDecimal;
		to '1': /*--*/ jmp calculateDecimal;
		to '2': /*--*/ jmp calculateDecimal;
		to '3': /*--*/ jmp calculateDecimal;
		to '4': /*--*/ jmp calculateDecimal;
		to '5': /*--*/ jmp calculateDecimal;
		to '6': /*--*/ jmp calculateDecimal;
		to '7': /*--*/ jmp calculateDecimal;
		to '8': /*--*/ jmp calculateDecimal;
		to '9': /*--*/ jmp calculateDecimal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchHexadecimalLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateHexadecimal;
		to '1': /*--*/ jmp calculateHexadecimal;
		to '2': /*--*/ jmp calculateHexadecimal;
		to '3': /*--*/ jmp calculateHexadecimal;
		to '4': /*--*/ jmp calculateHexadecimal;
		to '5': /*--*/ jmp calculateHexadecimal;
		to '6': /*--*/ jmp calculateHexadecimal;
		to '7': /*--*/ jmp calculateHexadecimal;
		to '8': /*--*/ jmp calculateHexadecimal;
		to '9': /*--*/ jmp calculateHexadecimal;
		to 'A': /*--*/ jmp calculateHexadecimal;
		to 'B': /*--*/ jmp calculateHexadecimal;
		to 'C': /*--*/ jmp calculateHexadecimal;
		to 'D': /*--*/ jmp calculateHexadecimal;
		to 'E': /*--*/ jmp calculateHexadecimal;
		to 'F': /*--*/ jmp calculateHexadecimal;
		to 'a': /*--*/ jmp calculateHexadecimal;
		to 'b': /*--*/ jmp calculateHexadecimal;
		to 'c': /*--*/ jmp calculateHexadecimal;
		to 'd': /*--*/ jmp calculateHexadecimal;
		to 'e': /*--*/ jmp calculateHexadecimal;
		to 'f': /*--*/ jmp calculateHexadecimal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchMacro:{
		if(!findString(&macroRoot, &current)){
			jmp nonNumber;
		}
		if(macroRoot.returnedCounter < 5){
			number = macroRoot.returnedCounter;
			inc number;
		}elif(macroRoot.returnedCounter < 9){
			number = macroRoot.returnedCounter - 5;
		}elif(macroRoot.returnedCounter < 11){
			number = macroRoot.returnedCounter - 9;
		}elif(macroRoot.returnedCounter < 15){
			number = macroRoot.returnedCounter - 11;
		}elif(macroRoot.returnedCounter < 17){
			number = macroRoot.returnedCounter - 15;
		}else{
			number = 0;
		}
		switch *current over
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace1Loop;
			to '\n': /*-*/ jmp matchWhitespace1Loop;
			to '\v': /*-*/ jmp matchWhitespace1Loop;
			to '\f': /*-*/ jmp matchWhitespace1Loop;
			to '\r': /*-*/ jmp matchWhitespace1Loop;
			to ' ': /*--*/ jmp matchWhitespace1Loop;
			to '+': /*--*/ jmp matchOperation;
			to '-': /*--*/ jmp matchOperation;
			to '*': /*--*/ jmp matchOperation;
			to '/': /*--*/ jmp matchOperation;
			off: /*-----*/ jmp nonNumber;
		end
	}
	calculateBinary:{
		const int copy = number;
		number = number * 2 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchBinaryLoop;
	}
	calculateOctal:{
		const int copy = number;
		number = number * 8 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchOctalLoop;
	}
	calculateDecimal:{
		const int copy = number;
		number = number * 10 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchDecimalLoop;
	}
	calculateHexadecimal:{
		const int copy = number;
		number = number * 16 + *current - (*current >= '0') * 48 - (*current >= 'A') * 7 - (*current >= 'a') * 32;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchHexadecimalLoop;
	}
	matchWhitespace1Loop:{
		if(inc current >= statementWall){
			op = '\0';
			jmp matchOperationReturnPoint;
		}
		switch *current over
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace1Loop;
			to '\n': /*-*/ jmp matchWhitespace1Loop;
			to '\v': /*-*/ jmp matchWhitespace1Loop;
			to '\f': /*-*/ jmp matchWhitespace1Loop;
			to '\r': /*-*/ jmp matchWhitespace1Loop;
			to ' ': /*--*/ jmp matchWhitespace1Loop;
			off: /*-----*/ jmp matchOperation;
		end
	}
	matchOperation: switch *current over
		to '+': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '-': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '*': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '/': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		off: /*----*/ op = '\0'; /*-----*/ jmp matchOperationReturnPoint;
	end
	matchOperationReturnPoint: switch jmpPoint over
		to LEVEL0_JMP_POINT: /*-*/ jmp switchOperation0;
		to LEVEL1_JMP_POINT: /*-*/ jmp switchOperation1;
		off: /*-----------------*/ jmp switchOperation2;
	end
	switchOperation0: switch op over
		to '\0': /*-*/ jmp level0;
		to '+': /*--*/ jmp level1;
		to '-': /*--*/ jmp level1;
		to '*': /*--*/ jmp level2;
		to '/': /*--*/ jmp level2;
	end
	switchOperation1: switch op over
		to '\0': /*-*/ jmp level1End;
		to '+': /*--*/ jmp level1FoundLevel1;
		to '-': /*--*/ jmp level1FoundLevel1;
		to '*': /*--*/ jmp level2;
		to '/': /*--*/ jmp level2;
	end
	switchOperation2: switch op over
		to '\0': /*-*/ jmp level2End;
		to '+': /*--*/ jmp level2FoundLevel1;
		to '-': /*--*/ jmp level2FoundLevel1;
		to '*': /*--*/ jmp level2FoundLevel2;
		to '/': /*--*/ jmp level2FoundLevel2;
	end
	level0:{
		i0 = number;
		jmp validNumber;
	}
	level1:{
		i0 = number;
		o0 = op;
		jmpPoint = LEVEL1_JMP_POINT;
		jmp matchWhitespace0Loop;
	}
	level2:{
		i1 = number;
		o1 = op;
		jmpPoint = LEVEL2_JMP_POINT;
		jmp matchWhitespace0Loop;
	}
	level1End:{
		if(o0 == '+'){
			i0 += number;
		}else{
			i0 -= number;
		}
		o0 = op;
		jmp validNumber;
	}
	level1FoundLevel1:{
		if(o0 == '+'){
			i0 += number;
		}else{
			i0 -= number;
		}
		o0 = op;
		jmp matchWhitespace0Loop;
	}
	level2End:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		switch o0 over
			to '\0': /*-*/ i0  = i1; jmp validNumber;
			to '+': /*--*/ i0 += i1; jmp validNumber;
			to '-': /*--*/ i0 -= i1; jmp validNumber;
		end
	}
	level2FoundLevel1:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		switch o0 over
			to '\0': /*-*/ o1 = '\0'; /*-*/ number = i1; jmp level1;
			to '+': /*--*/ i0 += i1; /*--*/ number = i0; jmp level1;
			to '-': /*--*/ i0 -= i1; /*--*/ number = i0; jmp level1;
		end
	}
	level2FoundLevel2:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		o1 = op;
		jmp matchWhitespace0Loop;
	}
	validNumber:{
		*statementCurrent = current + 1;
		*returnValue = i0;
		ret VALID_NUMBER_NUMBER;
	}
	nonNumber:{
		*statementCurrent = current + 1;
		ret NON_NUMBER_NUMBER;
	}
	overflownNumber:{
		*statementCurrent = current + 1;
		ret OVERFLOWN_NUMBER_NUMBER;
	}
	dividedByZeroNumber:{
		*statementCurrent = current + 1;
		ret DIVIDED_BY_ZERO_NUMBER;
	}
	#undef  LEVEL2_JMP_POINT
	#undef  LEVEL1_JMP_POINT
	#undef  LEVEL0_JMP_POINT
}
MATCHSTRING(){
	#define STRING_BLOCK_SIZE /*-*/ (1024)
	uint size = STRING_BLOCK_SIZE;
	char *dataStart = malloc(size * sizeof(char));
	uint32 dataToken = pushPointer(dataStart, "matched string pointer", iFree);
	uint allocated = 0;
	char *dataCurrent = dataStart;
	char *current = *statementCurrent;
	jmp validateMalloc;
	validateMalloc:{
		if(!dataStart){
			ret false;
		}
		jmp copyStringLoop;
	}
	copyStringLoop:{
		if(allocated == size){
			const uint offset = dataCurrent - dataStart;
			void *temp;
			size += STRING_BLOCK_SIZE;
			temp = realloc(dataStart, size * sizeof(char));
			updatePointer(dataToken, temp);
			if(!temp){
				free(dataStart);
				popPointer(dataToken);
				ret false;
			}
			dataStart = temp;
			dataCurrent = dataStart + offset;
		}
		*dataCurrent = *current;
		inc allocated;
		if(*current){
			inc current;
			inc dataCurrent;
			jmp copyStringLoop;
		}
		inc current;
		jmp trimMemory;
	}
	trimMemory:{
		void *temp = realloc(dataStart, allocated * sizeof(char));
		updatePointer(dataToken, temp);
		if(!temp){
			jmp returnValidString;
		}
		dataStart = temp;
		jmp returnValidString;
	}
	returnValidString:{
		*statementCurrent = current;
		*stringReturn = dataStart;
		*stringToken = dataToken;
		ret true;
	}
	#undef  STRING_BLOCK_SIZE
}
MATCHEXECUTE(){
	#define EXECUTE_BLOCK_SIZE /*-------*/ (1024)
	#define ROOT_UID /*-----------------*/ (0)
	#define PREPEND_STRING_OPERATION /*-*/ (0)
	#define GIVEN_STRING_OPERATION /*---*/ (1)
	#define APPEND_STRING_OPERATION /*--*/ (2)
	const uid_t uid = geteuid();
	char *current = *statementCurrent;
	uint allocated = 0;
	uint size = EXECUTE_BLOCK_SIZE;
	char *dataStart = malloc(size * sizeof(char));
	uint32 dataToken = pushPointer(dataStart, "matched execute pointer", iFree);
	char *dataCurrent = dataStart;
	char *string = current;
	bool operation = APPEND_STRING_OPERATION;
	jmp validateMalloc;
	validateMalloc:{
		if(!dataStart){
			ret false;
		}
		jmp pickPrivilegedUnprivilegedPath;
	}
	pickPrivilegedUnprivilegedPath:{
		if(uid == ROOT_UID){
			string = "su $(logname) -c \'";
			operation = PREPEND_STRING_OPERATION;
		}
		jmp matchStringLoop;
	}
	matchStringLoop:{
		if(allocated == size){
			const uint offset = dataCurrent - dataStart;
			void *temp;
			size += EXECUTE_BLOCK_SIZE;
			temp = realloc(dataStart, size * sizeof(char));
			updatePointer(dataToken, temp);
			if(!temp){
				free(dataStart);
				popPointer(dataToken);
				ret false;
			}
			dataStart = temp;
			dataCurrent = dataStart + offset;
		}
		*dataCurrent = *string;
		inc allocated;
		inc dataCurrent;
		if(*(inc string)){
			jmp matchStringLoop;
		}
		jmp nextString;
	}
	nextString: switch operation over
		to PREPEND_STRING_OPERATION:{
			operation = GIVEN_STRING_OPERATION;
			string = current;
			jmp matchStringLoop;
		}
		to GIVEN_STRING_OPERATION:{
			operation = APPEND_STRING_OPERATION;
			current = inc string;
			string = "\'";
			jmp matchStringLoop;
		}
		off:{
			if(allocated == size){
				const uint offset = dataCurrent - dataStart;
				void *temp;
				size += EXECUTE_BLOCK_SIZE;
				temp = realloc(dataStart, size * sizeof(char));
				updatePointer(dataToken, temp);
				if(!temp){
					free(dataStart);
					popPointer(dataToken);
					ret false;
				}
				dataStart = temp;
				dataCurrent = dataStart + offset;
			}
			*dataCurrent = '\0';
			inc allocated;
			jmp trimMemory;
		}
	end
	trimMemory:{
		void *temp = realloc(dataStart, allocated * sizeof(char));
		updatePointer(dataToken, temp);
		if(!temp){
			jmp returnValidString;
		}
		dataStart = temp;
		jmp returnValidString;
	}
	returnValidString:{
		if(uid != ROOT_UID){
			current = inc string;
		}
		*statementCurrent = current;
		*executeReturn = dataStart;
		*executeToken = dataToken;
		ret true;
	}
	#undef  APPEND_STRING_OPERATION
	#undef  GIVEN_STRING_OPERATION
	#undef  PREPEND_STRING_OPERATION
	#undef  ROOT_UID
	#undef  EXECUTE_BLOCK_SIZE
}
READIMAGE(){
	#define FILE_HEADER_SIZE /*---*/ (14)
	#define BITMAPCOREHEADER /*---*/ (12)
	#define OS22XBITMAPHEADER /*--*/ (64)
	#define BITMAPINFOHEADER /*---*/ (40)
	#define BITMAPV2INFOHEADER /*-*/ (52)
	#define BITMAPV3INFOHEADER /*-*/ (56)
	#define BITMAPV4HEADER /*-----*/ (108)
	#define BITMAPV5HEADER /*-----*/ (124)
	#define BI_RGB /*-------------*/ (0)
	#define BI_RLE8 /*------------*/ (1)
	#define BI_RLE4 /*------------*/ (2)
	#define BI_BITFIELDS /*-------*/ (3)
	#define BI_JPEG /*------------*/ (4)
	#define BI_PNG /*-------------*/ (5)
	#define BI_ALPHABITFIELDS /*--*/ (6)
	#define BI_CMYK /*------------*/ (11)
	#define BI_CMYKRLE8 /*--------*/ (12)
	#define BI_CMYKRLE4 /*--------*/ (13)
	FILE *file = NULL;
	uint32 fileToken = 0;
	uint8 b;
	uint8 m;
	uint32 headerSize;
	int32 width;
	int32 height;
	uint16 depth;
	uint32 compression;
	uint32 *data = NULL;
	uint32 dataToken = 0;
	uint8 returnValue;
	*errorMessage = NULL;
	jmp openFile;
	openFile:{
		file = fopen(path, "rb");
		fileToken = pushPointer(file, "image file", fclose);
		if(!file){
			returnValue = CANNOT_OPEN_READ_CONFIG;
			jmp failedImage;
		}
		jmp readHeaders;
	}
	readHeaders:{
		uint8 header[FILE_HEADER_SIZE + BITMAPINFOHEADER];
		if(fread(header, sizeof(uint8), FILE_HEADER_SIZE + 34, file) != FILE_HEADER_SIZE + 34){
			returnValue = CANNOT_READ_READ_CONFIG;
			jmp failedImage;
		}
		b /*-----------*/ = *(uint8  *)(header + 0);
		m /*-----------*/ = *(uint8  *)(header + 1);
		headerSize /*--*/ = *(uint32 *)(header + 14);
		width /*-------*/ = *( int32 *)(header + 18);
		height /*------*/ = *( int32 *)(header + 22);
		depth /*-------*/ = *(uint16 *)(header + 28);
		compression /*-*/ = *(uint32 *)(header + 30);
		jmp queryFileFormat;
	}
	queryFileFormat:{
		if(b != 'B' or m != 'M'){
			returnValue = UNSUPPORTED_FORMAT_READ_CONFIG;
			jmp failedImage;
		}
		jmp queryHeaderSupport;
	}
	queryHeaderSupport: switch headerSize over
		to BITMAPCOREHEADER: /*---*/ *errorMessage = "BITMAPCOREHEADER header not supported"; /*--*/ jmp printHeaderError;
		to OS22XBITMAPHEADER: /*--*/ *errorMessage = "OS22XBITMAPHEADER header not supported"; /*-*/ jmp printHeaderError;
		to BITMAPINFOHEADER: /*---*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV2INFOHEADER: /*-*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV3INFOHEADER: /*-*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV4HEADER: /*-----*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV5HEADER: /*-----*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		off: /*-------------------*/ *errorMessage = "unrecognized header"; /*--------------------*/ jmp printHeaderError;
	end
	printHeaderError:{
		returnValue = BAD_HEADER_READ_CONFIG;
		jmp failedImage;
	}
	queryDepth: switch depth over
		to 1: /*--*/ *errorMessage = "1 bit depth not supported"; /*---*/ jmp printDepthError;
		to 4: /*--*/ *errorMessage = "4 bit depth not supported"; /*---*/ jmp printDepthError;
		to 8: /*--*/ *errorMessage = "8 bit depth not supported"; /*---*/ jmp printDepthError;
		to 16: /*-*/ *errorMessage = "16 bit depth not supported"; /*--*/ jmp printDepthError;
		to 24: /*-*/ /*------------------------------------------------*/ jmp queryCompression;
		to 32: /*-*/ /*------------------------------------------------*/ jmp queryCompression;
		off: /*---*/ *errorMessage = "unknown depth not supported"; /*-*/ jmp printDepthError;
	end
	printDepthError:{
		returnValue = BAD_DEPTH_READ_CONFIG;
		jmp failedImage;
	}
	queryCompression: switch compression over
		to BI_RGB: /*------------*/ /*----------------------------------------------------------------*/ jmp queryHeight;
		to BI_RLE8: /*-----------*/ *errorMessage = "BI_RLE8 compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_RLE4: /*-----------*/ *errorMessage = "BI_RLE4 compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_BITFIELDS: /*------*/ /*----------------------------------------------------------------*/ jmp queryHeight;
		to BI_JPEG: /*-----------*/ *errorMessage = "BI_JPEG compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_PNG: /*------------*/ *errorMessage = "BI_PNG compression not supported"; /*------------*/ jmp printCompressionError;
		to BI_ALPHABITFIELDS: /*-*/ *errorMessage = "BI_ALPHABITFIELDS compression not supported"; /*-*/ jmp printCompressionError;
		to BI_CMYK: /*-----------*/ *errorMessage = "BI_CMYK compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_CMYKRLE8: /*-------*/ *errorMessage = "BI_CMYKRLE8 compression not supported"; /*-------*/ jmp printCompressionError;
		to BI_CMYKRLE4: /*-------*/ *errorMessage = "BI_CMYKRLE4 compression not supported"; /*-------*/ jmp printCompressionError;
		off: /*------------------*/ *errorMessage = "unrecognized compression used"; /*---------------*/ jmp printCompressionError;
	end
	printCompressionError:{
		returnValue = BAD_COMPRESSION_READ_CONFIG;
		jmp failedImage;
	}
	queryHeight:{
		if(height < 0){
			returnValue = UNSUPPORTED_HEIGHT_READ_CONFIG;
			jmp failedImage;
		}
		jmp setupImage;
	}
	setupImage:{
		if(fseek(file, FILE_HEADER_SIZE + headerSize, SEEK_SET)){
			returnValue = BAD_SIZE_READ_CONFIG;
			jmp failedImage;
		}
		(*image).width = width;
		(*image).height = height;
		(*image).size = width * height * sizeof(uint32);
		data = malloc((*image).size * sizeof(uint8));
		dataToken = pushPointer(data, "image data pointer", iFree);
		if(!data){
			returnValue = FAILED_READ_CONFIG;
			jmp failedImage;
		}
		jmp readPixels;
	}
	readPixels:{
		const uint32 amount = (depth * width + 31) / 8 / width;
		const uint widthTwice = 2 * width;
		uint32 *const start = data + (height - 1) * width;
		uint32 *current = start;
		uint multipleCounter = 0;
		uint32 *currentWall = current + width;
		jmp readRowLoop;
		readRowLoop:{
			if(fread(current, sizeof(uint8), amount, file) != amount){
				if(current == start){
					returnValue = BAD_PIXELS_READ_CONFIG;
					jmp failedImage;
				}
				returnValue = BAD_IMAGE_READ_CONFIG;
				jmp failedImage;
			}
			if(depth == 24){
				*current |= 0xFF000000;
			}
			multipleCounter += amount;
			multipleCounter -= (multipleCounter > 4) * 4;
			if(inc current < currentWall){
				jmp readRowLoop;
			}
			if((current -= widthTwice) >= data){
				fseek(file, 4 - multipleCounter, SEEK_CUR);
				multipleCounter = 0;
				currentWall -= width;
				jmp readRowLoop;
			}
			jmp successfulImage;
		}
	}
	successfulImage:{
		fclose(file);
		popPointer(fileToken);
		(*image).data = data;
		(*image).dataToken = dataToken;
		ret SUCCESS_READ_CONFIG;
	}
	failedImage:{
		free(data);
		popPointer(dataToken);
		if(file){
			fclose(file);
			popPointer(fileToken);
		}
		ret returnValue;
	}
	#undef  BI_CMYKRLE4
	#undef  BI_CMYKRLE8
	#undef  BI_CMYK
	#undef  BI_ALPHABITFIELDS
	#undef  BI_PNG
	#undef  BI_JPEG
	#undef  BI_BITFIELDS
	#undef  BI_RLE4
	#undef  BI_RLE8
	#undef  BI_RGB
	#undef  BITMAPV5HEADER
	#undef  BITMAPV4HEADER
	#undef  BITMAPV3INFOHEADER
	#undef  BITMAPV2INFOHEADER
	#undef  BITMAPINFOHEADER
	#undef  OS22XBITMAPHEADER
	#undef  BITMAPCOREHEADER
	#undef  FILE_HEADER_SIZE
}
FREECONFIGVARIABLES(){
	ret;
}
EXEC(){
	#define FORK_FAILURE /*-------*/ (-1)
	#define CHILD_FORK_PROCESS /*-*/ (0)
	switch fork() over
		to FORK_FAILURE:{
			printTitledError("fork error", "could not execute shell command");
			ret;
		}
		to CHILD_FORK_PROCESS:{
			setsid();
			execl("/bin/sh", "sh", "-c", string, NULL);
			printTitledError("fork error", "shell command returned an error");
			exit(EXIT_SUCCESS);
		}
		off:{
			ret;
		}
	end
	#undef  CHILD_FORK_PROCESS
	#undef  FORK_FAILURE
}
SETMEMORY(){
	switch perByteAmount over
		to sizeof(uint8): /*--*/ jmp perByte;
		to sizeof(uint16): /*-*/ jmp perTwoBytes;
		to sizeof(uint32): /*-*/ jmp perFourBytes;
		to sizeof(uint64): /*-*/ jmp perEightBytes;
		off: /*---------------*/ ret;
	end
	perByte:{
		const uint8 value8 = value;
		uint8 *current = destinationStart;
		uint8 *const wall = current + itemAmount;
		jmp perByteLoop;
		perByteLoop:{
			if(current < wall){
				*current = value8;
				inc current;
				jmp perByteLoop;
			}
			ret;
		}
	}
	perTwoBytes:{
		const uint16 value16 = value;
		uint16 *current = destinationStart;
		uint16 *const wall = current + itemAmount;
		jmp perTwoBytesLoop;
		perTwoBytesLoop:{
			if(current < wall){
				*current = value16;
				inc current;
				jmp perTwoBytesLoop;
			}
			ret;
		}
	}
	perFourBytes:{
		const uint32 value32 = value;
		uint32 *current = destinationStart;
		uint32 *const wall = current + itemAmount;
		jmp perFourBytesLoop;
		perFourBytesLoop:{
			if(current < wall){
				*current = value32;
				inc current;
				jmp perFourBytesLoop;
			}
			ret;
		}
	}
	perEightBytes:{
		const uint64 value64 = value;
		uint64 *current = destinationStart;
		uint64 *const wall = current + itemAmount;
		jmp perEightBytesLoop;
		perEightBytesLoop:{
			if(current < wall){
				*current = value64;
				inc current;
				jmp perEightBytesLoop;
			}
			ret;
		}
	}
}
COPYMEMORY(){
	const uint largeAmount = byteAmount / sizeof(uint64);
	const uint smallAmount = byteAmount % sizeof(uint64);
	void *sourceCurrent = sourceStart;
	void *destinationCurrent = destinationStart;
	void *sourceWall = (uint64 *)sourceCurrent + largeAmount;
	jmp largeLoop;
	largeLoop:{
		if((uint64 *)sourceCurrent < (uint64 *)sourceWall){
			*(uint64 *)destinationCurrent = *(uint64 *)sourceCurrent;
			sourceCurrent = (uint64 *)sourceCurrent + 1;
			destinationCurrent = (uint64 *)destinationCurrent + 1;
			jmp largeLoop;
		}
		sourceWall = (uint8 *)sourceCurrent + smallAmount;
		jmp smallLoop;
	}
	smallLoop:{
		if((uint8 *)sourceCurrent < (uint8 *)sourceWall){
			*(uint8 *)destinationCurrent = *(uint8 *)sourceCurrent;
			sourceCurrent = (uint8 *)sourceCurrent + 1;
			destinationCurrent = (uint8 *)destinationCurrent + 1;
			jmp smallLoop;
		}
		ret;
	}
}
FINDSTRINGLENGTH(){
	const uint8 *current = string;
	jmp advanceStringPointerLoop;
	advanceStringPointerLoop:{
		if(*current){
			inc current;
			jmp advanceStringPointerLoop;
		}
		ret current - (uint8 *)string;
	}
}
UTF8TOUCS2(){
	uint16 *ucs2Current = ucs2Start;
	uint16 *const ucs2Wall = ucs2Current + ucs2Length;
	jmp loop;
	loop:{
		if(*utf8 and ucs2Current < ucs2Wall){
			uint16 newUCS2;
			uint8 byte1 = *utf8;
			if(byte1 < b(10000000)){
				newUCS2 = byte1;
				byte1 = '\0';
				inc utf8;
			}elif((byte1 & b(11100000)) == b(11000000)){
				const uint8 byte2 = *(utf8 + 1);
				if((byte2 & b(11000000)) == b(10000000)){
					newUCS2 = ((byte1 & b(00011111)) << 6) | (byte2 & b(00111111));
					byte1 = '\0';
					utf8 += 2;
				}else{
					inc utf8;
				}
			}elif((byte1 & b(11110000)) == b(11100000)){
				const uint8 byte2 = *(utf8 + 1);
				const uint8 byte3 = *(utf8 + 2);
				if((byte2 & b(11000000)) == b(10000000) and (byte3 & b(11000000)) == b(10000000)){
					newUCS2 = ((byte1 & b(00001111)) << 12) | ((byte2 & b(00111111)) << 6) | (byte3 & b(00111111));
					byte1 = '\0';
					utf8 += 3;
				}else{
					inc utf8;
				}
			}elif((byte1 & b(11111000)) == b(11110000)){
				const uint8 byte2 = *(utf8 + 1);
				const uint8 byte3 = *(utf8 + 2);
				const uint8 byte4 = *(utf8 + 3);
				if((byte2 & b(11000000)) == b(10000000) and (byte3 & b(11000000)) == b(10000000) and (byte4 & b(11000000)) == b(10000000)){
					utf8 += 4;
				}else{
					inc utf8;
				}
			}else{
				inc utf8;
			}
			if(!byte1){
				*ucs2Current = (newUCS2 << 8) | (newUCS2 >> 8);
				inc ucs2Current;
			}
			jmp loop;
		}
		ret ucs2Current - ucs2Start;
	}
}
GETTIMESTAMP(){
	uint offset;
	if(!event){
		jmp invalidTimestamp;
	}
	offset = 0;
	jmp checkEventValidity;
	checkEventValidity: switch (*event).response_type over
		to XCB_KEY_PRESS: /*---------*/ /*-------*/ jmp validTimestamp;
		to XCB_KEY_RELEASE: /*-------*/ /*-------*/ jmp validTimestamp;
		to XCB_BUTTON_PRESS: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_BUTTON_RELEASE: /*----*/ /*-------*/ jmp validTimestamp;
		to XCB_MOTION_NOTIFY: /*-----*/ /*-------*/ jmp validTimestamp;
		to XCB_ENTER_NOTIFY: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_LEAVE_NOTIFY: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_PROPERTY_NOTIFY: /*---*/ offset = 2; jmp validTimestamp;
		to XCB_SELECTION_CLEAR: /*---*/ /*-------*/ jmp validTimestamp;
		to XCB_SELECTION_REQUEST: /*-*/ /*-------*/ jmp validTimestamp;
		to XCB_SELECTION_NOTIFY: /*--*/ /*-------*/ jmp validTimestamp;
		off: /*----------------------*/ /*-------*/ jmp invalidTimestamp;
	end
	invalidTimestamp:{
		ret XCB_CURRENT_TIME;
	}
	validTimestamp:{
		ret *(xcb_timestamp_t *)((*event).pad + offset);
	}
}
GETPOINTERMONITOR(){
	if(monitorAllocated > 1){
		xcb_query_pointer_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_pointer_unchecked(connection, (*screen).root), NULL);
		uint32 token = pushPointer(reply, "get pointer monitor reply", iFree);
		if(reply){
			const int x = (*reply).root_x;
			const int y = (*reply).root_y;
			Monitor *current = monitorStart;
			Monitor *const wall = current + monitorAllocated;
			free(reply);
			popPointer(token);
			jmp loop;
			loop:{
				if(x >= (*current).leftX and x < (*current).rightX and y >= (*current).topY and y < (*current).bottomY){
					ret current;
				}
				if(inc current < wall){
					jmp loop;
				}
			}
		}
	}
	ret monitorStart;
}
GETWINDOWMONITOR(){
	if(monitorAllocated > 0){
		const xcb_get_geometry_cookie_t geometryCookie = xcb_get_geometry_unchecked(connection, window);
		const xcb_translate_coordinates_cookie_t translateCoordinatesCookie = xcb_translate_coordinates_unchecked(connection, window, (*screen).root, 0, 0);
		xcb_get_geometry_reply_t *const getGeometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);
		uint32 getGeometryToken = pushPointer(getGeometryReply, "getWindowMonitor() get geometry reply", iFree);
		xcb_translate_coordinates_reply_t *const translateCoordinatesReply = xcb_wait_for_reply(connection, translateCoordinatesCookie, NULL);
		uint32 translateCoordinatesToken = pushPointer(translateCoordinatesReply, "getWindowMonitor() translate coordinates reply", iFree);
		Monitor *monitor = NULL;
		if(getGeometryReply and translateCoordinatesReply){
			const int width = (*getGeometryReply).width + 2 * (*getGeometryReply).border_width;
			const int height = (*getGeometryReply).height + 2 * (*getGeometryReply).border_width;
			const int leftX = (*translateCoordinatesReply).dst_x;
			const int topY = (*translateCoordinatesReply).dst_y;
			const int rightX = leftX + width;
			const int bottomY = topY + height;
			Monitor *current = monitorStart;
			Monitor *const wall = current + monitorAllocated;
			int mostPixels = 0;
			jmp loop;
			loop:{
				if((*current).leftX < rightX and (*current).rightX > leftX and (*current).topY < bottomY and (*current).bottomY > topY){
					const int w = ((*current). rightX <  rightX? (*current). rightX :  rightX) - ((*current).leftX > leftX? (*current).leftX : leftX);
					const int h = ((*current).bottomY < bottomY? (*current).bottomY : bottomY) - ((*current). topY >  topY? (*current). topY :  topY);
					const int pixels = w * h;
					if(pixels > mostPixels){
						mostPixels = pixels;
						monitor = current;
					}
				}
				if(inc current < wall){
					jmp loop;
				}
			}
		}
		free(getGeometryReply);
		popPointer(getGeometryToken);
		free(translateCoordinatesReply);
		popPointer(translateCoordinatesToken);
		ret monitor;
	}
	ret NULL;
}
COMPOSITEIMAGES(){
	int intersectionWidth;
	int intersectionHeight;
	uint32 *sourceCurrent;
	uint32 *sourceWidthWall;
	uint32 *sourceWall;
	uint32 *destinationCurrent;
	if(sourceX < 0 or sourceY < 0 or sourceX >= (*source).width or sourceY >= (*source).height){
		ret;
	}
	{
		const int b1lx = 0;
		const int b1ty = 0;
		const int b1rx = (*destination).width;
		const int b1by = (*destination).height;
		const int b2lx = destinationX;
		const int b2ty = destinationY;
		const int b2rx = b2lx + (*source).width - sourceX;
		const int b2by = b2ty + (*source).height - sourceY;
		intersectionWidth = (b1rx < b2rx? b1rx : b2rx) - (b1lx > b2lx? b1lx : b2lx);
		intersectionHeight = (b1by < b2by? b1by : b2by) - (b1ty > b2ty? b1ty : b2ty);
		if(intersectionWidth < 1 or intersectionWidth < 1){
			ret;
		}
	}
	sourceCurrent = (uint32 *)(*source).data + sourceY * (*source).width + sourceX;
	if(destinationX < 0){
		sourceCurrent -= destinationX;
		destinationX = 0;
	}
	if(destinationY < 0){
		sourceCurrent -= destinationY * (*source).width;
		destinationY = 0;
	}
	sourceWidthWall = sourceCurrent + intersectionWidth;
	sourceWall = sourceCurrent + intersectionHeight * (*source).width;
	destinationCurrent = (uint32 *)(*destination).data + destinationY * (*destination).width + destinationX;
	jmp yLoop;
	yLoop:{
		if(sourceCurrent < sourceWall){
			jmp xLoop;
			xLoop:{
				if(sourceCurrent < sourceWidthWall){
					operation(sourceCurrent, destinationCurrent);
					inc sourceCurrent;
					inc destinationCurrent;
					jmp xLoop;
				}
				sourceCurrent += (*source).width - intersectionWidth;
				sourceWidthWall += (*source).width;
				destinationCurrent += (*destination).width - intersectionWidth;
				jmp yLoop;
			}
		}
		ret;
	}
}
COMPOSITEIMAGESOVER(){
	const uint32 s = *source;
	const uint32 d = *destination;
	const uint64 a_a = s >> 24;
	if(a_a == 0xFF){
		*destination = s;
		ret;
	}
	if(a_a){
		const uint32 r_a = (s & 0x00FF0000) >> 16;
		const uint32 g_a = (s & 0x0000FF00) >> 8;
		const uint32 b_a = (s & 0x000000FF) >> 0;
		const uint32 a_b = d >> 24;
		const uint32 r_b = (d & 0x00FF0000) >> 16;
		const uint32 g_b = (d & 0x0000FF00) >> 8;
		const uint32 b_b = (d & 0x000000FF) >> 0;
		const uint32 a_0 = a_a + a_b * (0xFF - a_a) / 0xFF;
		const uint32 r = (r_a * a_a + r_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		const uint32 g = (g_a * a_a + g_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		const uint32 b = (b_a * a_a + b_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		*destination = (a_0 << 24) + ((r & 0x000000FF) << 16) + ((g & 0x000000FF) << 8) + ((b & 0x000000FF) << 0);
		ret;
	}
	ret;
}
COMPOSITEIMAGESAND(){
	if(!(*source >> 24)){
		*destination = 0x00000000;
		ret;
	}
	ret;
}
TWOPASSBOXBLUR(){
	uint32 *intermediateData;
	uint32 *kernelColumnRStart;
	uint32 *kernelColumnGStart;
	uint32 *kernelColumnBStart;
	uint32 *pixelRStart;
	uint32 *pixelGStart;
	uint32 *pixelBStart;
	if(boxSize == 1){
		ret;
	}
	intermediateData = malloc(width * height * sizeof(uint32));
	kernelColumnRStart = malloc(boxSize + 2 * width * sizeof(uint32));
	kernelColumnGStart = malloc(boxSize + 2 * width * sizeof(uint32));
	kernelColumnBStart = malloc(boxSize + 2 * width * sizeof(uint32));
	pixelRStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	pixelGStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	pixelBStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	{
		const int divisor = boxSize * boxSize;
		const int boxDistanceFromZero = boxSize >> 1;
		const int nBoxDistanceFromZero = -boxDistanceFromZero;
		const int widthMinusOne = width - 1;
		const int heightMinusOne = height - 1;
		const int heightMinusBoxSize = height - boxSize;
		uint32 *tx = destinationData;
		uint32 *txCopy = tx;
		uint32 *rx = intermediateData;
		uint32 r;
		uint32 g;
		uint32 b;
		jmp loop;
		loop:{
			uint32 *kernelColumnRCurrent = kernelColumnRStart;
			uint32 *kernelColumnGCurrent = kernelColumnGStart;
			uint32 *kernelColumnBCurrent = kernelColumnBStart;
			uint32 *kernelColumnRCurrentCopy = kernelColumnRStart;
			uint32 *kernelColumnGCurrentCopy = kernelColumnGStart;
			uint32 *kernelColumnBCurrentCopy = kernelColumnBStart;
			uint32 *pixelRCurrent = pixelRStart;
			uint32 *pixelGCurrent = pixelGStart;
			uint32 *pixelBCurrent = pixelBStart;
			uint32 *pixelRCurrentCopy = pixelRStart;
			uint32 *pixelGCurrentCopy = pixelGStart;
			uint32 *pixelBCurrentCopy = pixelBStart;
			int x = 0;
			int y = 0;
			{
				int kx = nBoxDistanceFromZero;
				r = 0;
				g = 0;
				b = 0;
				while(kx <= boxDistanceFromZero){
					int ky = nBoxDistanceFromZero;
					int usedX = x + kx;
					if(usedX < 0){
						usedX = 0;
					}
					*kernelColumnRCurrent = 0;
					*kernelColumnGCurrent = 0;
					*kernelColumnBCurrent = 0;
					tx += usedX;
					while(ky <= boxDistanceFromZero){
						int usedY = y + ky;
						uint32 color;
						if(usedY < 0){
							usedY = 0;
						}
						color = *(tx + usedY * width);
						*pixelRCurrent = (color & 0xFF0000) >> 16;
						*pixelGCurrent = (color & 0x00FF00) >>  8;
						*pixelBCurrent =  color & 0x0000FF;
						*kernelColumnRCurrent += *pixelRCurrent;
						*kernelColumnGCurrent += *pixelGCurrent;
						*kernelColumnBCurrent += *pixelBCurrent;
						inc pixelRCurrent;
						inc pixelGCurrent;
						inc pixelBCurrent;
						inc ky;
					}
					tx -= usedX;
					r += *kernelColumnRCurrent;
					g += *kernelColumnGCurrent;
					b += *kernelColumnBCurrent;
					pixelRCurrent += heightMinusBoxSize;
					pixelGCurrent += heightMinusBoxSize;
					pixelBCurrent += heightMinusBoxSize;
					inc kernelColumnRCurrent;
					inc kernelColumnGCurrent;
					inc kernelColumnBCurrent;
					inc kx;
				}
				*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
				inc rx;
			}
			inc x;
			xFirstLoop:{
				int kx = boxDistanceFromZero;
				int ky = nBoxDistanceFromZero;
				int usedX = x + kx;
				if(usedX < 0){
					usedX = 0;
				}elif(usedX >= width){
					usedX = widthMinusOne;
				}
				r -= *kernelColumnRCurrentCopy;
				g -= *kernelColumnGCurrentCopy;
				b -= *kernelColumnBCurrentCopy;
				kernelColumnRCurrent = kernelColumnRCurrentCopy + boxSize;
				kernelColumnGCurrent = kernelColumnGCurrentCopy + boxSize;
				kernelColumnBCurrent = kernelColumnBCurrentCopy + boxSize;
				inc kernelColumnRCurrentCopy;
				inc kernelColumnGCurrentCopy;
				inc kernelColumnBCurrentCopy;
				{
					uint32 lr = 0;
					uint32 lg = 0;
					uint32 lb = 0;
					tx += usedX;
					while(ky <= boxDistanceFromZero){
						int usedY = y + ky;
						uint32 color;
						if(usedY < 0){
							usedY = 0;
						}elif(usedY >= height){
							usedY = heightMinusOne;
						}
						color = *(tx + usedY * width);
						*pixelRCurrent = (color & 0xFF0000) >> 16;
						*pixelGCurrent = (color & 0x00FF00) >>  8;
						*pixelBCurrent =  color & 0x0000FF;
						lr += *pixelRCurrent;
						lg += *pixelGCurrent;
						lb += *pixelBCurrent;
						inc pixelRCurrent;
						inc pixelGCurrent;
						inc pixelBCurrent;
						inc ky;
					}
					tx -= usedX;
					r += lr;
					g += lg;
					b += lb;
					*kernelColumnRCurrent = lr;
					*kernelColumnGCurrent = lg;
					*kernelColumnBCurrent = lb;
					pixelRCurrent += heightMinusBoxSize;
					pixelGCurrent += heightMinusBoxSize;
					pixelBCurrent += heightMinusBoxSize;
				}
				*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
				inc rx;
				if(inc x < width){
					jmp xFirstLoop;
				}
			}
			inc y;
			yLoop:{
				uint32 *pr;
				uint32 *pg;
				uint32 *pb;
				int ky = boxDistanceFromZero;
				int usedY = y + ky;
				if(usedY < 0){
					usedY = 0;
				}elif(usedY >= height){
					usedY = heightMinusOne;
				}
				x = 0;
				{
					int kx = nBoxDistanceFromZero;
					kernelColumnRCurrent = kernelColumnRStart;
					kernelColumnGCurrent = kernelColumnGStart;
					kernelColumnBCurrent = kernelColumnBStart;
					kernelColumnRCurrentCopy = kernelColumnRStart;
					kernelColumnGCurrentCopy = kernelColumnGStart;
					kernelColumnBCurrentCopy = kernelColumnBStart;
					pixelRCurrent = pixelRCurrentCopy;
					pixelGCurrent = pixelGCurrentCopy;
					pixelBCurrent = pixelBCurrentCopy;
					pr = pixelRCurrent + boxSize;
					pg = pixelGCurrent + boxSize;
					pb = pixelBCurrent + boxSize;
					r = 0;
					g = 0;
					b = 0;
					tx += usedY * width;
					while(kx <= boxDistanceFromZero){
						int usedX = x + kx;
						uint32 color;
						if(usedX < 0){
							usedX = 0;
						}elif(usedX >= width){
							usedX = widthMinusOne;
						}
						color = *(tx + usedX);
						*pr = (color & 0xFF0000) >> 16;
						*pg = (color & 0x00FF00) >>  8;
						*pb =  color & 0x0000FF;
						*kernelColumnRCurrent += *pr - *pixelRCurrent;
						*kernelColumnGCurrent += *pg - *pixelGCurrent;
						*kernelColumnBCurrent += *pb - *pixelBCurrent;
						r += *kernelColumnRCurrent;
						g += *kernelColumnGCurrent;
						b += *kernelColumnBCurrent;
						pixelRCurrent += height;
						pixelGCurrent += height;
						pixelBCurrent += height;
						pr += height;
						pg += height;
						pb += height;
						inc kernelColumnRCurrent;
						inc kernelColumnGCurrent;
						inc kernelColumnBCurrent;
						inc kx;
					}
					tx -= usedY * width;
					*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
					inc rx;
					inc x;
				}
				{
					int usedX = x + boxDistanceFromZero;
					usedY *= width;
					tx += usedY;
					xLoop:{
						uint32 color;
						if(usedX >= width){
							usedX = widthMinusOne;
						}
						kernelColumnRCurrent = kernelColumnRCurrentCopy + boxSize;
						kernelColumnGCurrent = kernelColumnGCurrentCopy + boxSize;
						kernelColumnBCurrent = kernelColumnBCurrentCopy + boxSize;
						r -= *kernelColumnRCurrentCopy;
						g -= *kernelColumnGCurrentCopy;
						b -= *kernelColumnBCurrentCopy;
						color = *(tx + usedX);
						*pr = (color & 0xFF0000) >> 16;
						*pg = (color & 0x00FF00) >>  8;
						*pb =  color & 0x0000FF;
						*kernelColumnRCurrent += *pr - *pixelRCurrent;
						*kernelColumnGCurrent += *pg - *pixelGCurrent;
						*kernelColumnBCurrent += *pb - *pixelBCurrent;
						r += *kernelColumnRCurrent;
						g += *kernelColumnGCurrent;
						b += *kernelColumnBCurrent;
						inc kernelColumnRCurrentCopy;
						inc kernelColumnGCurrentCopy;
						inc kernelColumnBCurrentCopy;
						pixelRCurrent += height;
						pixelGCurrent += height;
						pixelBCurrent += height;
						pr += height;
						pg += height;
						pb += height;
						*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
						inc rx;
						if(inc x < width){
							inc usedX;
							jmp xLoop;
						}
					}
					tx -= usedY;
				}
				if(inc y < height){
					inc pixelRCurrentCopy;
					inc pixelGCurrentCopy;
					inc pixelBCurrentCopy;
					jmp yLoop;
				}
			}
			if(txCopy == destinationData){
				tx = intermediateData;
				txCopy = tx;
				rx = destinationData;
				jmp loop;
			}
		}
	}
	free(intermediateData);
	free(kernelColumnRStart);
	free(kernelColumnGStart);
	free(kernelColumnBStart);
	free(pixelRStart);
	free(pixelGStart);
	free(pixelBStart);
	ret;
}
ROTATEIMAGE(){
	const int oldWidth = (*image).width;
	const int oldHeight = (*image).height;
	const int oldSize = (*image).size;
	uint32 *newData;
	uint32 newDataToken;
	uint32 *current = (*image).data;
	uint32 *const yWall = (void *)((uint8 *)current + oldSize);
	uint32 *xWall = current + oldWidth;
	int newWidth;
	int newHeight;
	uint32 *newDataCurrent;
	int newDataNextX;
	int newDataNextY;
	if(!rotation){
		ret true;
	}
	newData = malloc(oldSize * sizeof(uint8));
	newDataToken = pushPointer(newData, "rotateImage() new data pointer", iFree);
	if(!newData){
		printTitledError("memory allocation error", "could not allocate rotated image color data");
		ret false;
	}
	switch rotation over
		to DEGREE_90_ROTATION: /*--*/ jmp rotate90Degrees;
		to DEGREE_180_ROTATION: /*-*/ jmp rotate180Degrees;
		to DEGREE_270_ROTATION: /*-*/ jmp rotate270Degrees;
		off: /*--------------------*/ ret false;
	end
	rotate90Degrees:{
		newWidth = oldHeight;
		newHeight = oldWidth;
		newDataCurrent = newData + newWidth - 1;
		newDataNextX = newWidth;
		newDataNextY = -newHeight * newWidth - 1;
		jmp copyYAxisLoop;
	}
	rotate180Degrees:{
		newWidth = oldWidth;
		newHeight = oldHeight;
		newDataCurrent = newData + newHeight * newWidth - 1;
		newDataNextX = -1;
		newDataNextY = 0;
		jmp copyYAxisLoop;
	}
	rotate270Degrees:{
		newWidth = oldHeight;
		newHeight = oldWidth;
		newDataCurrent = newData + newHeight * newWidth - newWidth;
		newDataNextX = -newWidth;
		newDataNextY = newHeight * newWidth + 1;
		jmp copyYAxisLoop;
	}
	copyYAxisLoop:{
		if(current < yWall){
			jmp copyXAxisLoop;
			copyXAxisLoop:{
				if(current < xWall){
					*newDataCurrent = *current;
					newDataCurrent += newDataNextX;
					inc current;
					jmp copyXAxisLoop;
				}
				newDataCurrent += newDataNextY;
				xWall += oldWidth;
				jmp copyYAxisLoop;
			}
		}
		jmp success;
	}
	success:{
		if(deletePreviousData){
			free((*image).data);
			popPointer((*image).dataToken);
		}
		(*image).data = newData;
		(*image).dataToken = newDataToken;
		(*image).width = newWidth;
		(*image).height = newHeight;
		ret true;
	}
}
FILLDRAWABLE(){
	xcb_rectangle_t rectangle;
	rectangle.x = x;
	rectangle.y = y;
	rectangle.width = width;
	rectangle.height = height;
	xcb_change_gc(connection, gc, XCB_GC_FOREGROUND, &color);
	xcb_poly_fill_rectangle(connection, drawable, gc, 1, &rectangle);
	ret;
}
RESTARTCOMMAND(){
	shmDisconnect();
	freeConfigVariables();
	ungrabShortcuts();
	unsetShortcutRoot(&buttonShortcut);
	setShortcutRoot(&buttonShortcut);
	unsetShortcutRoot(&keycodeShortcut);
	setShortcutRoot(&keycodeShortcut);
	ret;
}
EXITCOMMAND(){
	free(event);
	popPointer(eventToken);
	shmDisconnect();
	cancelThreads();
	freeConfigVariables();
	ungrabShortcuts();
	freeMonitors();
	xcb_ungrab_keyboard(connection, getTimestamp());
	if(ic){
		XDestroyIC(ic);
	}
	if(im){
		XCloseIM(im);
	}
	if(connectionToken){
		xcb_disconnect(connection);
		popPointer(connectionToken);
	}
	if(display){
		XCloseDisplay(display);
		popPointer(displayToken);
	}
	unsetShortcutRoot(&buttonShortcut);
	unsetShortcutRoot(&keycodeShortcut);
	deleteStringRoot(&macroRoot);
	deleteStringRoot(&modifierRoot);
	deleteStringRoot(&variableRoot);
	deleteStringRoot(&commandRoot);
	deleteStringRoot(&booleanRoot);
	deleteStringRoot(&scope1ScopeInstructionRoot);
	deleteStringRoot(&globalInstructionRoot);
	deleteStringRoot(&globalScopesInstructionRoot);
	if(dynamicDataSegment.allocated > 1){
		printError("%s%s: %s%s:%s %s", colorStart, programName, colorError, "warning", colorEnd, "program exited with unaccounted for data pointers, namely: ");
		printUnaccountedForPointers(dynamicDataSegment.data + 1, dynamicDataSegment.data + dynamicDataSegment.allocated);
	}
	deleteMemoryManager();
	closeErrorStream();
	exit(EXIT_SUCCESS);
}
CANCELTHREADS(){
	if(globalsLockCreated){
		if(pthread_rwlock_destroy(&globalsLock) != PTHREAD_RWLOCK_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy globals lock");
		}
		globalsLockCreated = false;
	}
	ret;
}
FREEMONITORS(){
	free(monitorStart);
	popPointer(monitorToken);
	monitorStart = NULL;
	monitorToken = 0;
	ret;
}
PRINTUNACCOUNTEDFORPOINTERS(){
	if(current < wall){
		jmp printPointedVariablesLoop;
		printPointedVariablesLoop:{
			if((*current).data){
				labelExamined = (*current).label;
				printError("%s", labelExamined);
			}
			if(inc current < wall){
				if((*(current - 1)).data){
					printError(", ");
				}
				jmp printPointedVariablesLoop;
			}
		}
	}
	printError("\n");
	ret;
}
PRINTERROR(){
	if(openErrorStream()){
		va_list arguments;
		va_start(arguments, message);
		flockfile(errorStream);
		vfprintf(errorStream, message, arguments);
		funlockfile(errorStream);
		va_end(arguments);
		closeErrorStream();
	}
	ret;
}
PRINTTITLEDERROR(){
	printError("%s%s: %s%s:%s %s\n", colorStart, programName, colorError, title, colorEnd, message);
	ret;
}
PRINTTITLEDQUOTEDERROR(){
	printError("%s%s: %s%s:%s \"%s\" %s\n", colorStart, programName, colorError, title, colorEnd, argument, message);
	ret;
}
PRINTCONNECTIONERROR(){
	const char *string;
	jmp findConnectionError;
	findConnectionError: switch xcb_connection_has_error(connection) over
		to XCB_CONN_ERROR: /*-------------------*/ string = "socket/pipe/stream error"; /*------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_EXT_NOTSUPPORTED: /*-*/ string = "extension not supported"; /*-------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_MEM_INSUFFICIENT: /*-*/ string = "insufficient memory"; /*-----------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_REQ_LEN_EXCEED: /*---*/ string = "exceeded request length"; /*-------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_PARSE_ERR: /*--------*/ string = "error parsing display string"; /*--*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_INVALID_SCREEN: /*---*/ string = "screen-display mismatch"; /*-------*/ jmp printConnectionError;
		off: /*---------------------------------*/ string = "unrecognized connection error"; /*-*/ jmp printConnectionError;
	end
	printConnectionError:{
		printTitledError("fatal X server error", string);
		ret;
	}
}
PRINTTITLEDNAMEDERROR(){
	printError("%s%s: %s%s:%s %s %s\n", colorStart, programName, colorError, title, colorEnd, message, name);
	ret;
}
PRINTXERROR(){


def struct{
	uint8_t response_type;
	uint8_t error_code;
	uint32_t resource_id;
	uint16_t minor_code;
	uint8_t major_code;
} xcb_generic_error_t;


	#define useErrorName(n0, n1) /*--------------*/ n0 == n1? *(n1 + ((*error).error_code >= countof(n1)? countof(n1) - 1 : (*error).error_code))
	#define useErrorOperationName(n0, n1, n2) /*-*/ n0 == n1? *(n2 + ((*error).major_code >= countof(n2)? countof(n2) - 1 : (*error).major_code))
	const xcb_generic_error_t *const error = (void *)event;
	printError("%s%s: %sX error event:%s %s error in %s operation using the 0x%x resource\n", colorStart, programName, colorError, colorEnd
		, useErrorName(name, errorName)
		: useErrorName(name, randrErrorName)
		: "unrecognized"
		, useErrorOperationName(name, errorName, operationName)
		: useErrorOperationName(name, randrErrorName, randrOperationName)
		: "unrecognized"
	, (*error).resource_id);
	ret;
	#undef  useErrorOperationName
	#undef  useErrorName
}
PRINTTITLEDVALUEDERROR(){
	printError("%s%s: %s%s:%s %s %u\n", colorStart, programName, colorError, title, colorEnd, message, value);
	ret;
}
PRINTCONFIGERROR(){
	const char *statementCurrent = statementStart;
	const uint itemAmountWall = instructionCurrent - instructionStart;
	uint itemAmount = 0;
	uint spaceAmount = 0;
	StringNodeRoot *const *data;
	if(!openErrorStream()){
		ret;
	}
	flockfile(errorStream);
	fprintf(errorStream, "%s%s: %s: ", colorStart, programName, configPath);
	if(printLine){
		fprintf(errorStream, "line %u: ", statementLine);
	}
	fprintf(errorStream, "%s%s:%s %s", colorError, type, colorEnd, message);
	if(printConfig){
		fprintf(errorStream, ":\n\t config |");
	}else{
		fprintf(errorStream, "\n");
		jmp emergencyExit;
	}
	jmp printStatementItemLoop;
	printStatementItemLoop:{
		if(statementCurrent < statementWall){
			fprintf(errorStream, " %s", statementCurrent);
			jmp pushOutTermLoop;
			pushOutTermLoop:{
				if(*(inc statementCurrent)){
					jmp pushOutTermLoop;
				}
				inc statementCurrent;
			}
			if(itemAmount == itemAmountWall and instructionStart){
				spaceAmount = statementCurrent - statementStart;
			}
			inc itemAmount;
			jmp printStatementItemLoop;
		}
		if(spaceAmount == 0 and finalStatementCharacter != ';'){
			fprintf(errorStream, " ");
		}
		fprintf(errorStream, "%c\n", finalStatementCharacter);
		jmp printPattern;
	}
	printPattern:{
		if(printPointer){
			if(spaceAmount == statementCurrent - statementStart){
				dec spaceAmount;
			}
			fprintf(errorStream, "\t        |%*c^\n", inc spaceAmount, ' ');
		}
		if(!printPattern or !instructionStart){
			fprintf(errorStream, "\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, "\n\tpattern | %s", *(currentScopeInstructionList + (*currentScopeInstructionRoot).returnedCounter));
		dec instructionStart;
		data = instructionDataStart;
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoop: switch *(inc instructionStart) over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
		to EXECUTE_INSTRUCTION_TYPE: /*---*/ jmp executeInstruction;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
		off: /*----------------------*/ jmp printInstructionParameterLoopExit;
	end
	noneInstruction:{
		fprintf(errorStream, " <unimplemented>");
		jmp printInstructionParameterLoopExit;
	}
	nameInstruction:{
		const char *const *stringArray;
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " name");
			jmp printInstructionParameterLoop;
		}
		stringArray = (**data).stringArray;
		fprintf(errorStream, " (%s", *stringArray);
		inc stringArray;
		printNameLoop:{
			if(*stringArray){
				fprintf(errorStream, "|%s", *stringArray);
				inc stringArray;
				jmp printNameLoop;
			}
		}
		fprintf(errorStream, ")");
		inc data;
		jmp printInstructionParameterLoop;
	}
	nameListInstruction:{
		const char *const *stringArray;
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " list");
			jmp printInstructionParameterLoop;
		}
		stringArray = (**data).stringArray;
		fprintf(errorStream, " ((%s", *stringArray);
		inc stringArray;
		printNameListOnceLoop:{
			if(*stringArray){
				fprintf(errorStream, "|%s", *stringArray);
				inc stringArray;
				jmp printNameListOnceLoop;
			}
		}
		stringArray = (**data).stringArray;
		fprintf(errorStream, ")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
		inc stringArray;
		printNameListTwiceLoop:{
			if(*stringArray){
				fprintf(errorStream, "|%s", *stringArray);
				inc stringArray;
				jmp printNameListTwiceLoop;
			}
		}
		fprintf(errorStream, "))*(?![\\s]*[|]))");
		inc data;
		jmp printInstructionParameterLoop;
	}
	numberInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " number");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
		jmp printInstructionParameterLoop;
	}
	stringInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " string");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	executeInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " execute");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	imageInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " image");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	printTilde:{
		fprintf(errorStream, " ~");
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoopExit:{
		if(displaySimpleConfigErrors){
			fprintf(errorStream, "\n\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, " $\n\n");
		jmp emergencyExit;
	}
	emergencyExit:{
		funlockfile(errorStream);
		closeErrorStream();
		ret;
	}
}
OPENERRORSTREAM(){
	if(!mustOpenErrorStream){
		ret true;
	}
	errorStream = fopen(errorPath, "a");
	errorStreamToken = pushPointer(errorStream, "error stream", fclose);
	if(errorStream){
		ret true;
	}
	mustOpenErrorStream = false;
	errorStream = DEFAULT_ERROR_STREAM;
	colorStart = MESSAGE_START;
	colorFatal = MESSAGE_FATAL;
	colorError = MESSAGE_ERROR;
	colorEvent = MESSAGE_EVENT;
	colorEnd = MESSAGE_END;
	printTitledError("stream error", "could not open error file, reverting to the default error stream");
	ret true;
}
CLOSEERRORSTREAM(){
	if(mustOpenErrorStream and errorStream){
		fclose(errorStream);
		popPointer(errorStreamToken);
		errorStreamToken = 0;
	}
	ret;
}
