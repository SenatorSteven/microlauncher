
/*!
	unhandled generic event (85).
*/

/*!
	"as" is giving only "as" and not "as" and "assistant" and a whole lot more.
*/

/*!
	future features:
		insert and match non-ascii.
		connect the copy buffer to the global text buffer.
		support getting the first n results and then the second n results and then the kth n results.
		consider different roots for each directory in path.
		support finding matches in the middle or end of a word, perhaps by using pointers to short circuit to letters.
		optimize searching.
		support utf8 in toCase().
		implement undo.
		implement redo.
		add rounded corners to input and result elements.
		allow non-vertical result element placement.
*/



























/*! microlauncher.cold

MIT License

Copyright (C) 2024 Stefanos "Steven" Tsakiris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

/*!includes:{*/
	#define _DEFAULT_SOURCE
	#include <dirent.h>
	#undef  _DEFAULT_SOURCE
	#include <limits.h>
	#include <locale.h>
	#include <pthread.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <signal.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/stat.h>
	#include <xcb/randr.h>
	#include <xcb/xcb.h>
	#include <xcb/xcbext.h>
	#include <X11/Xlib.h>
	#include <X11/Xlib-xcb.h>
	#include <X11/Xlocale.h>
	#include "cold/cold.hold"
/*!}*/

/*!defines:{*/
	#define DEBUG /*----------------------------------------*/ (true)

	#define PROGRAM_NAME /*---------------------------------*/ "microlauncher"

	#define PTHREAD_CREATE_SUCCESS /*-----------------------*/ (0)
	#define PTHREAD_SETCANCELSTATE_SUCCESS /*---------------*/ (0)
	#define PTHREAD_SETCANCELTYPE_SUCCESS /*----------------*/ (0)
	#define PTHREAD_MUTEXATTR_INIT_SUCCESS /*---------------*/ (0)
	#define PTHREAD_MUTEXATTR_SETPSHARED_SUCCESS /*---------*/ (0)
	#define PTHREAD_MUTEXATTR_DESTROY_SUCCESS /*------------*/ (0)
	#define PTHREAD_MUTEX_INIT_SUCCESS /*-------------------*/ (0)
	#define PTHREAD_MUTEX_LOCK_SUCCESS /*-------------------*/ (0)
	#define PTHREAD_MUTEX_TRYLOCK_SUCCESS /*----------------*/ (0)
	#define PTHREAD_MUTEX_UNLOCK_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_MUTEX_DESTROY_SUCCESS /*----------------*/ (0)
	#define PTHREAD_CONDATTR_INIT_SUCCESS /*----------------*/ (0)
	#define PTHREAD_CONDATTR_SETPSHARED_SUCCESS /*----------*/ (0)
	#define PTHREAD_CONDATTR_DESTROY_SUCCESS /*-------------*/ (0)
	#define PTHREAD_COND_INIT_SUCCESS /*--------------------*/ (0)
	#define PTHREAD_COND_WAIT_SUCCESS /*--------------------*/ (0)
	#define PTHREAD_COND_TIMEDWAIT_SUCCESS /*---------------*/ (0)
	#define PTHREAD_COND_SIGNAL_SUCCESS /*------------------*/ (0)
	#define PTHREAD_COND_BROADCAST_SUCCESS /*---------------*/ (0)
	#define PTHREAD_COND_DESTROY_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_RWLOCKATTR_INIT_SUCCESS /*--------------*/ (0)
	#define PTHREAD_RWLOCKATTR_SETKIND_NP_SUCCESS /*--------*/ (0)
	#define PTHREAD_RWLOCKATTR_DESTROY_SUCCESS /*-----------*/ (0)
	#define PTHREAD_RWLOCK_INIT_SUCCESS /*------------------*/ (0)
	#define PTHREAD_RWLOCK_WRLOCK_SUCCESS /*----------------*/ (0)
	#define PTHREAD_RWLOCK_RDLOCK_SUCCESS /*----------------*/ (0)
	#define PTHREAD_RWLOCK_UNLOCK_SUCCESS /*----------------*/ (0)
	#define PTHREAD_RWLOCK_DESTROY_SUCCESS /*---------------*/ (0)
	#define PTHREAD_JOIN_SUCCESS /*-------------------------*/ (0)

	#define GETHOSTNAME_SUCCESS /*--------------------------*/ (0)

	#define _STRING_NODE_CHILDREN_AMOUNT /*-----------------*/ (14)
	#define STRING_NODE_CHILDREN_AMOUNT /*------------------*/ (_STRING_NODE_CHILDREN_AMOUNT > 28? 28 : _STRING_NODE_CHILDREN_AMOUNT)
	#define SHORTCUT_CODE_AMOUNT /*-------------------------*/ (256)

	#define DEFAULT_OUTPUT_STREAM /*------------------------*/ (stdout)
	#define DEFAULT_ERROR_STREAM /*-------------------------*/ (stderr)

	#define MESSAGE_START /*--------------------------------*/ ("\x1b[1m")
	#define MESSAGE_FATAL /*--------------------------------*/ ("\x1b[91m")
	#define MESSAGE_ERROR /*--------------------------------*/ ("\x1b[33m")
	#define MESSAGE_EVENT /*--------------------------------*/ ("\x1b[32m")
	#define MESSAGE_END /*----------------------------------*/ ("\x1b[m")

	#define NONE_ARGUMENT /*--------------------------------*/ (0)
	#define UNRECOGNIZED_ARGUMENT /*------------------------*/ (1)
	#define HELP_ARGUMENT /*--------------------------------*/ (2)
	#define STDOUT_ARGUMENT /*------------------------------*/ (3)
	#define STDERR_ARGUMENT /*------------------------------*/ (4)
	#define CONFIG_ARGUMENT /*------------------------------*/ (5)
	#define ERROR_ARGUMENT /*-------------------------------*/ (6)
	#define SERVER_ARGUMENT /*------------------------------*/ (7)

	#define NONE_INSTRUCTION_TYPE /*------------------------*/ (b(0000000))
	#define NAME_INSTRUCTION_TYPE /*------------------------*/ (b(0000001))
	#define NAME_LIST_INSTRUCTION_TYPE /*-------------------*/ (b(0000010))
	#define NUMBER_INSTRUCTION_TYPE /*----------------------*/ (b(0000100))
	#define STRING_INSTRUCTION_TYPE /*----------------------*/ (b(0001000))
	#define EXECUTE_INSTRUCTION_TYPE /*---------------------*/ (b(0010000))
	#define IMAGE_INSTRUCTION_TYPE /*-----------------------*/ (b(0100000))
	#define END_INSTRUCTION_TYPE /*-------------------------*/ (b(1000000))

	#define NONE_NAME_LIST /*-------------------------------*/ (0)
	#define SUCCESS_NAME_LIST /*----------------------------*/ (1)
	#define INVALID_NAME_NAME_LIST /*-----------------------*/ (2)
	#define PREMATURE_END_NAME_LIST /*----------------------*/ (3)

	#define NONE_NUMBER /*----------------------------------*/ (0)
	#define VALID_NUMBER_NUMBER /*--------------------------*/ (1)
	#define NON_NUMBER_NUMBER /*----------------------------*/ (2)
	#define OVERFLOWN_NUMBER_NUMBER /*----------------------*/ (3)
	#define DIVIDED_BY_ZERO_NUMBER /*-----------------------*/ (4)

	#define NONE_READ_CONFIG /*-----------------------------*/ (0)
	#define CANNOT_OPEN_READ_CONFIG /*----------------------*/ (1)
	#define CANNOT_READ_READ_CONFIG /*----------------------*/ (2)
	#define UNSUPPORTED_FORMAT_READ_CONFIG /*---------------*/ (3)
	#define BAD_HEADER_READ_CONFIG /*-----------------------*/ (4)
	#define BAD_DEPTH_READ_CONFIG /*------------------------*/ (5)
	#define BAD_COMPRESSION_READ_CONFIG /*------------------*/ (6)
	#define UNSUPPORTED_HEIGHT_READ_CONFIG /*---------------*/ (7)
	#define BAD_SIZE_READ_CONFIG /*-------------------------*/ (8)
	#define FAILED_READ_CONFIG /*---------------------------*/ (9)
	#define BAD_PIXELS_READ_CONFIG /*-----------------------*/ (10)
	#define BAD_IMAGE_READ_CONFIG /*------------------------*/ (11)
	#define SUCCESS_READ_CONFIG /*--------------------------*/ (12)

	#define NONE_BOOLEAN /*---------------------------------*/ (0)
	#define TRUE_BOOLEAN /*---------------------------------*/ (1)
	#define FALSE_BOOLEAN /*--------------------------------*/ (2)

	#define NONE_COMMAND /*---------------------------------*/ (0)
	#define EXECUTE_COMMAND /*------------------------------*/ (1)
	#define TO_NEXT_LETTER_COMMAND /*-----------------------*/ (2)
	#define TO_PREVIOUS_LETTER_COMMAND /*-------------------*/ (3)
	#define TO_NEXT_WORD_COMMAND /*-------------------------*/ (4)
	#define TO_PREVIOUS_WORD_COMMAND /*---------------------*/ (5)
	#define TO_START_OF_LINE_COMMAND /*---------------------*/ (6)
	#define TO_END_OF_LINE_COMMAND /*-----------------------*/ (7)
	#define TO_NEXT_RESULT_COMMAND /*-----------------------*/ (8)
	#define TO_PREVIOUS_RESULT_COMMAND /*-------------------*/ (9)
	#define REMOVE_LEFT_LETTER_COMMAND /*-------------------*/ (10)
	#define REMOVE_RIGHT_LETTER_COMMAND /*------------------*/ (11)
	#define REMOVE_LEFT_WORD_COMMAND /*---------------------*/ (12)
	#define REMOVE_RIGHT_WORD_COMMAND /*--------------------*/ (13)
	#define SELECT_LEFT_LETTER_COMMAND /*-------------------*/ (14)
	#define SELECT_RIGHT_LETTER_COMMAND /*------------------*/ (15)
	#define SELECT_LEFT_WORD_COMMAND /*---------------------*/ (16)
	#define SELECT_RIGHT_WORD_COMMAND /*--------------------*/ (17)
	#define SELECT_TO_START_OF_LINE_COMMAND /*--------------*/ (18)
	#define SELECT_TO_END_OF_LINE_COMMAND /*----------------*/ (19)
	#define SELECT_ALL_COMMAND /*---------------------------*/ (20)
	#define COPY_SELECTION_COMMAND /*-----------------------*/ (21)
	#define CUT_SELECTION_COMMAND /*------------------------*/ (22)
	#define PASTE_SELECTION_COMMAND /*----------------------*/ (23)
	#define UPPERCASE_SELECTION_COMMAND /*------------------*/ (24)
	#define LOWERCASE_SELECTION_COMMAND /*------------------*/ (25)
	#define TOGGLE_INSERT_MODE_COMMAND /*-------------------*/ (26)
	#define PICK_RESULT_COMMAND /*--------------------------*/ (27)
	#define LAUNCH_COMMAND /*-------------------------------*/ (28)
	#define RESTART_COMMAND /*------------------------------*/ (29)
	#define EXIT_COMMAND /*---------------------------------*/ (30)

	#define NONE_VARIABLE /*--------------------------------*/ (0)
	#define WINDOW_X_VARIABLE /*----------------------------*/ (1)
	#define WINDOW_Y_VARIABLE /*----------------------------*/ (2)
	#define WINDOW_X_OFFSET_VARIABLE /*---------------------*/ (3)
	#define WINDOW_Y_OFFSET_VARIABLE /*---------------------*/ (4)
	#define WINDOW_WIDTH_VARIABLE /*------------------------*/ (5)
	#define WINDOW_HEIGHT_VARIABLE /*-----------------------*/ (6)
	#define WINDOW_HORIZONTAL_ALIGNMENT_VARIABLE /*---------*/ (7)
	#define WINDOW_VERTICAL_ALIGNMENT_VARIABLE /*-----------*/ (8)
	#define WINDOW_CORNER_RADIUS_VARIABLE /*----------------*/ (9)
	#define WINDOW_BACKGROUND_VARIABLE /*-------------------*/ (10)
	#define INPUT_X_VARIABLE /*-----------------------------*/ (11)
	#define INPUT_Y_VARIABLE /*-----------------------------*/ (12)
	#define INPUT_X_OFFSET_VARIABLE /*----------------------*/ (13)
	#define INPUT_Y_OFFSET_VARIABLE /*----------------------*/ (14)
	#define INPUT_WIDTH_VARIABLE /*-------------------------*/ (15)
	#define INPUT_HEIGHT_VARIABLE /*------------------------*/ (16)
	#define INPUT_HORIZONTAL_ALIGNMENT_VARIABLE /*----------*/ (17)
	#define INPUT_VERTICAL_ALIGNMENT_VARIABLE /*------------*/ (18)
	#define INPUT_PADDING_VARIABLE /*-----------------------*/ (19)
	#define INPUT_MARGIN_VARIABLE /*------------------------*/ (20)
	#define INPUT_BACKGROUND_VARIABLE /*--------------------*/ (21)
	#define INPUT_CONTENT_X_VARIABLE /*---------------------*/ (22)
	#define INPUT_CONTENT_Y_VARIABLE /*---------------------*/ (23)
	#define INPUT_CONTENT_X_OFFSET_VARIABLE /*--------------*/ (24)
	#define INPUT_CONTENT_Y_OFFSET_VARIABLE /*--------------*/ (25)
	#define INPUT_CONTENT_HORIZONTAL_ALIGNMENT_VARIABLE /*--*/ (26)
	#define INPUT_CONTENT_VERTICAL_ALIGNMENT_VARIABLE /*----*/ (27)
	#define INPUT_CONTENT_FOREGROUND_VARIABLE /*------------*/ (28)
	#define INPUT_CONTENT_BACKGROUND_VARIABLE /*------------*/ (29)
	#define INPUT_CONTENT_SELECTED_FOREGROUND_VARIABLE /*---*/ (30)
	#define INPUT_CONTENT_SELECTED_BACKGROUND_VARIABLE /*---*/ (31)
	#define RESULT_X_VARIABLE /*----------------------------*/ (32)
	#define RESULT_Y_VARIABLE /*----------------------------*/ (33)
	#define RESULT_X_OFFSET_VARIABLE /*---------------------*/ (34)
	#define RESULT_Y_OFFSET_VARIABLE /*---------------------*/ (35)
	#define RESULT_WIDTH_VARIABLE /*------------------------*/ (36)
	#define RESULT_HEIGHT_VARIABLE /*-----------------------*/ (37)
	#define RESULT_HORIZONTAL_ALIGNMENT_VARIABLE /*---------*/ (38)
	#define RESULT_VERTICAL_ALIGNMENT_VARIABLE /*-----------*/ (39)
	#define RESULT_PADDING_VARIABLE /*----------------------*/ (40)
	#define RESULT_MARGIN_VARIABLE /*-----------------------*/ (41)
	#define RESULT_GAP_VARIABLE /*--------------------------*/ (42)
	#define RESULT_BACKGROUND_VARIABLE /*-------------------*/ (43)
	#define RESULT_SELECTED_BACKGROUND_VARIABLE /*----------*/ (44)
	#define RESULT_CONTENT_X_VARIABLE /*--------------------*/ (45)
	#define RESULT_CONTENT_Y_VARIABLE /*--------------------*/ (46)
	#define RESULT_CONTENT_X_OFFSET_VARIABLE /*-------------*/ (47)
	#define RESULT_CONTENT_Y_OFFSET_VARIABLE /*-------------*/ (48)
	#define RESULT_CONTENT_HORIZONTAL_ALIGNMENT_VARIABLE /*-*/ (49)
	#define RESULT_CONTENT_VERTICAL_ALIGNMENT_VARIABLE /*---*/ (50)
	#define RESULT_CONTENT_FOREGROUND_VARIABLE /*-----------*/ (51)
	#define RESULT_CONTENT_BACKGROUND_VARIABLE /*-----------*/ (52)
	#define RESULT_CONTENT_SELECTED_FOREGROUND_VARIABLE /*--*/ (53)
	#define RESULT_CONTENT_SELECTED_BACKGROUND_VARIABLE /*--*/ (54)
	#define WHICH_MONITOR_VARIABLE /*-----------------------*/ (55)
	#define FONT_VARIABLE /*--------------------------------*/ (56)
	#define MAXIMUM_RESULT_AMOUNT_VARIABLE /*---------------*/ (57)
	#define RESULT_ALLOW_CIRCULAR_NAVIGATION_VARIABLE /*----*/ (58)

	#define EMPTY_SHARED_STATUS /*--------------------------*/ (0)
	#define FULL_SHARED_STATUS /*---------------------------*/ (1)

	#define NONE_SWITCH_COMMAND_ORIGIN /*-------------------*/ (0)
	#define PRESS_SWITCH_COMMAND_ORIGIN /*------------------*/ (1)
	#define RELEASE_SWITCH_COMMAND_ORIGIN /*----------------*/ (2)
	#define CONFIG_SWITCH_COMMAND_ORIGIN /*-----------------*/ (3)
	#define STDIN_SWITCH_COMMAND_ORIGIN /*------------------*/ (4)
	#define TRANSMITTER_SWITCH_COMMAND_ORIGIN /*------------*/ (5)

	#define NONE_SWITCH_COMMAND /*--------------------------*/ (0)
	#define TYPICAL_SWITCH_COMMAND /*-----------------------*/ (1)
	#define RESTART_SWITCH_COMMAND /*-----------------------*/ (2)
	#define EXIT_SWITCH_COMMAND /*--------------------------*/ (3)

	#define NONE_ROTATION /*--------------------------------*/ (0)
	#define DEGREE_90_ROTATION /*---------------------------*/ (1)
	#define DEGREE_180_ROTATION /*--------------------------*/ (2)
	#define DEGREE_270_ROTATION /*--------------------------*/ (3)

	#define NONE_NORMAL_HINT /*-----------------------------*/ (b(0000000000))
	#define USER_POSITION_NORMAL_HINT /*--------------------*/ (b(0000000001))
	#define USER_SIZE_NORMAL_HINT /*------------------------*/ (b(0000000010))
	#define PROGRAM_POSITION_NORMAL_HINT /*-----------------*/ (b(0000000100))
	#define PROGRAM_SIZE_NORMAL_HINT /*---------------------*/ (b(0000001000))
	#define PROGRAM_MINIMUM_SIZE_NORMAL_HINT /*-------------*/ (b(0000010000))
	#define PROGRAM_MAXIMUM_SIZE_NORMAL_HINT /*-------------*/ (b(0000100000))
	#define PROGRAM_RESIZE_INCREMENT_NORMAL_HINT /*---------*/ (b(0001000000))
	#define PROGRAM_ASPECT_NORMAL_HINT /*-------------------*/ (b(0010000000))
	#define PROGRAM_BASE_SIZE_NORMAL_HINT /*----------------*/ (b(0100000000))
	#define PROGRAM_WINDOW_GRAVITY_NORMAL_HINT /*-----------*/ (b(1000000000))

	#define NONE_HINT /*------------------------------------*/ (b(000000000))
	#define INPUT_HINT /*-----------------------------------*/ (b(000000001))
	#define STATE_HINT /*-----------------------------------*/ (b(000000010))
	#define ICON_PIXMAP_HINT /*-----------------------------*/ (b(000000100))
	#define ICON_WINDOW_HINT /*-----------------------------*/ (b(000001000))
	#define ICON_POSITION_HINT /*---------------------------*/ (b(000010000))
	#define ICON_MASK_HINT /*-------------------------------*/ (b(000100000))
	#define WINDOW_GROUP_HINT /*----------------------------*/ (b(001000000))
	#define URGENCY_HINT /*---------------------------------*/ (b(100000000))

	#define WITHDRAWN_STATE /*------------------------------*/ (0)
	#define NORMAL_STATE /*---------------------------------*/ (1)
	#define ICON_STATE /*-----------------------------------*/ (3)

	#define QUIT() /*---------------------------------------*/ local void               quit(int signal)
	#define GETSHAREDCHARACTER() /*-------------------------*/ local int                getSharedCharacter(FILE *const configFile)
	#define INITMEMORYMANAGER() /*--------------------------*/ local bool               initMemoryManager(void)
	#define PUSHPOINTER() /*--------------------------------*/ local uint32            _pushPointer(const char *const file, const int line, void *const pointer, const char *const label, int (*const freeFunction)(void *))
	#define POPPOINTER() /*---------------------------------*/ local void               popPointer(const uint32 token)
	#define UPDATEPOINTER() /*------------------------------*/ local void               updatePointer(const uint32 token, void *const pointer)
	#define DELETEMEMORYMANAGER() /*------------------------*/ local void               deleteMemoryManager(void)
	#define IFREE() /*--------------------------------------*/ local int                iFree(void *const pointer)
	#define ISHMCTL() /*------------------------------------*/ local int                ishmctl(void *const pointer)
	#define IXCBDISCONNECT() /*-----------------------------*/ local int                iXCBDisconnect(void *const pointer)
	#define SHMINIT() /*------------------------------------*/ local void               shmInit(void)
	#define SHMCONNECT() /*---------------------------------*/ local void               shmConnect(void)
	#define SHMMAIN() /*------------------------------------*/ local void *             shmMain(void *const arg)
	#define SHMDISCONNECT() /*------------------------------*/ local void               shmDisconnect(void)
	#define IDENTIFYARGUMENT() /*---------------------------*/ local uint8              identifyArgument(const char *p)
	#define INSENSITIVESTRINGCOMPARE() /*-------------------*/ local bool               insensitiveStringCompare(const char *s0, const char *s1)
	#define SENSITIVESTRINGCOMPARE() /*---------------------*/ local bool               sensitiveStringCompare(const char *s0, const char *s1)
	#define SETSTRINGROOT() /*------------------------------*/ local void               setStringRoot(StringNodeRoot *const root)
	#define BULKINSERTSTRING() /*---------------------------*/ local void               bulkInsertString(StringNodeRoot *const root, const char *const *current)
	#define INSERTSTRING() /*-------------------------------*/ local bool               insertString(StringNodeRoot *const root, const char *string)
	#define GETSTRINGNODE() /*------------------------------*/ local StringNode *       getStringNode(StringNodeRoot *const root, const char **const stringReturn)
	#define DELETESTRINGROOT() /*---------------------------*/ local void               deleteStringRoot(StringNodeRoot *const root)
	#define SETSHORTCUTROOT() /*----------------------------*/ local void               setShortcutRoot(ShortcutNodeRoot *const root)
	#define INSERTSHORTCUT() /*-----------------------------*/ local bool               insertShortcut(ShortcutNodeRoot *const root, const uint8 code, const uint16 modifier, const uint8 command, char *const string, const uint stringToken, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define GETNEXTSHORTCUT() /*----------------------------*/ local bool               getNextShortcut(const ShortcutNodeRoot *const root, uint8 code, uint16 modifier, int *const nextOffset)
	#define REMOVESHORTCUT() /*-----------------------------*/ local bool               removeShortcut(ShortcutNodeRoot *const root, const uint8 code, const uint16 modifier)
	#define UNSETSHORTCUTROOT() /*--------------------------*/ local void               unsetShortcutRoot(ShortcutNodeRoot *const root)
	#define UNGRABSHORTCUTS() /*----------------------------*/ local void               ungrabShortcuts(void)
	#define RANDRQUERYVERSIONUNCHECKED() /*-----------------*/ local xcb_void_cookie_t  randrQueryVersionUnchecked(xcb_connection_t *const connection, const uint32 majorVersion, const uint32 minorVersion)
	#define SETASCIISTRINGROOT() /*-------------------------*/ local void               setASCIIStringRoot(ASCIIStringNodeRoot *const root)
	#define PATHINSERTSTRING() /*---------------------------*/ local void               pathInsertString(ASCIIStringNodeRoot *const root, const char *const path)
	#define ISASCIISTRING() /*------------------------------*/ local bool               isASCIIString(const void *string)
	#define INSERTASCIISTRING() /*--------------------------*/ local bool               insertASCIIString(ASCIIStringNodeRoot *const root, const char *string)
	#define GETASCIISTRINGNODE() /*-------------------------*/ local uint8              getASCIIStringNode(ASCIIStringNodeRoot *const root, const bool findExact, const char **const stringReturn, ASCIIStringNode **nodeReturn)
	#define GETMULTIPLEASCIISTRINGNODES() /*----------------*/ local bool               getMultipleASCIIStringNodes(ASCIIStringNodeRoot *const root, const uint amount, const char *prefix)
	#define DELETEASCIISTRINGROOT() /*----------------------*/ local void               deleteASCIIStringRoot(ASCIIStringNodeRoot *const root)
	#define SETCONFIGVARIABLES() /*-------------------------*/ local void               setConfigVariables(void)
	#define SETELEMENTPREFERENCES() /*----------------------*/ local void               setElementPreferences(ElementPreferences *const preferences)
	#define READCONFIG() /*---------------------------------*/ local void               readConfig(const bool createConfigFile, const char *const configPath, int (*getConfigChar)(FILE *file))
	#define MATCHNAMELIST() /*------------------------------*/ local uint8              matchNameList(StringNodeRoot *const root, const char *const statementWall, char **statementCurrentReturn, uint8 *const valueReturn)
	#define MATCHINTEGER() /*-------------------------------*/ local uint8              matchInteger(char **statementCurrent, const char *const statementWall, int64 *const returnValue)
	#define MATCHSTRING() /*--------------------------------*/ local bool               matchString(char **statementCurrent, char **stringReturn, uint32 *stringToken)
	#define MATCHEXECUTE() /*-------------------------------*/ local bool               matchExecute(char **statementCurrent, char **executeReturn, uint32 *executeToken)
	#define READIMAGE() /*----------------------------------*/ local uint8              readImage(const char *const path, const char **errorMessage, Image *image)
	#define FREECONFIGVARIABLES() /*------------------------*/ local void               freeConfigVariables(void)
	#define MATCHCOMMAND() /*-------------------------------*/ local uint8              matchCommand(const Command command, const uint8 origin)
	#define EXEC() /*---------------------------------------*/ local void               exec(const void *const string)
	#define SETMEMORY() /*----------------------------------*/ local void               setMemory(void *const destinationStart, const uint64 value, const uint itemAmount, const uint8 perByteAmount)
	#define COPYMEMORY() /*---------------------------------*/ local void               copyMemory(void *const sourceStart, void *const destinationStart, const uint byteAmount)
	#define FINDSTRINGLENGTH() /*---------------------------*/ local uint               findStringLength(const void *string)
	#define UTF8TOUCS2() /*---------------------------------*/ local uint               UTF8ToUCS2(const uint8 *utf8, uint16 *const ucs2Start, const int ucs2Length)
	#define GETTIMESTAMP() /*-------------------------------*/ local xcb_timestamp_t    getTimestamp(void)
	#define GETPOINTERMONITOR() /*--------------------------*/ local Monitor *          getPointerMonitor(void)
	#define GETWINDOWMONITOR() /*---------------------------*/ local Monitor *          getWindowMonitor(const xcb_window_t window)
	#define CREATECIRCLE() /*-------------------------------*/ local bool               createCircle(const int radius, const uint32 foreground, const uint32 background, Image *image)
	#define COMPOSITEIMAGES() /*----------------------------*/ local void               compositeImages(void (*operation)(const uint32 *const, uint32 *const), const int sourceX, const int sourceY, Image *const source, int destinationX, int destinationY, Image *const destination)
	#define COMPOSITEIMAGESOVER() /*------------------------*/ local void               compositeImagesOver(const uint32 *const source, uint32 *const destination)
	#define COMPOSITEIMAGESAND() /*-------------------------*/ local void               compositeImagesAnd(const uint32 *const source, uint32 *const destination)
	#define TWOPASSBOXBLUR() /*-----------------------------*/ local void               twoPassBoxBlur(const int width, const int height, const int boxSize, uint32 *destinationData)
	#define ROTATEIMAGE() /*--------------------------------*/ local bool               rotateImage(const uint8 rotation, Image *const image, const bool deletePreviousData)
	#define FILLDRAWABLE() /*-------------------------------*/ local void               fillDrawable(const xcb_drawable_t drawable, const xcb_gcontext_t gc, const int16 x, const int16 y, const uint16 width, const uint16 height, const uint32 color)
	#define RESTARTCOMMAND() /*-----------------------------*/ local void               restartCommand(const bool isInsideConfig)
	#define EXITCOMMAND() /*--------------------------------*/ local void               exitCommand(void)
	#define CANCELTHREADS() /*------------------------------*/ local void               cancelThreads(void)
	#define FREEMONITORS() /*-------------------------------*/ local void               freeMonitors(void)
	#define PRINTUNACCOUNTEDFORPOINTERS() /*----------------*/ local void               printUnaccountedForPointers(const Pointer *current, const Pointer *wall)
	#define PRINTERROR() /*---------------------------------*/ local void               printError(const char *const message, ...)
	#define PRINTTITLEDERROR() /*---------------------------*/ local void               printTitledError(const char *const title, const char *const message)
	#define PRINTTITLEDQUOTEDERROR() /*---------------------*/ local void               printTitledQuotedError(const char *const title, const char *const argument, const char *const message)
	#define PRINTCONNECTIONERROR() /*-----------------------*/ local void               printConnectionError(void)
	#define PRINTTITLEDNAMEDERROR() /*----------------------*/ local void               printTitledNamedError(const char *const title, const char *const message, const char *const name)
	#define PRINTXERROR() /*--------------------------------*/ local void               printXError(const char *const *const name)
	#define PRINTTITLEDVALUEDERROR() /*---------------------*/ local void               printTitledValuedError(const char *const title, const char *const message, const uint value)
	#define PRINTCONFIGERROR() /*---------------------------*/ local void               printConfigError(const char *const type, const char *const message, const char finalStatementCharacter, const bool printLine, const bool printConfig, const bool printPointer, const bool printPattern, const char *const configPath, const uint statementLine, const char *const statementStart, const char *const statementWall, const Instruction *instructionStart, const Instruction *instructionCurrent, StringNodeRoot *const *const instructionDataStart, const char *const *currentScopeInstructionList, const StringNodeRoot *const currentScopeInstructionRoot)
	#define OPENERRORSTREAM() /*----------------------------*/ local bool               openErrorStream(void)
	#define CLOSEERRORSTREAM() /*---------------------------*/ local void               closeErrorStream(void)

	#define xcb_wait_for_reply(a, b, c) /*------------------*/ (xcb_wait_for_reply(a, (b).sequence, c))
	#define xcb_discard_reply(a, b) /*----------------------*/ (xcb_discard_reply(a, (b).sequence))
	#define xcb_send_event(a, b, c, d, e) /*----------------*/ (xcb_send_event(a, b, c, d, (void *)(e)))
	#define xcb_send_event_checked(a, b, c, d, e) /*--------*/ (xcb_send_event_checked(a, b, c, d, (void *)(e)))

	#define SELF(self) /*-----------------------------------*/ self
	#define ASCII_TO_UCS2(c) /*-----------------------------*/ (c << 8)

	#define pushPointer(a, b, c) /*-------------------------*/ (_pushPointer(__FILE__, __LINE__, a, b, (int (*const)(void *))(c)))
	#define findString(a, b) /*-----------------------------*/ (!getStringNode(a, (const char **const)(b)))
	#define findASCIIString(a, b) /*------------------------*/ (getASCIIStringNode(a, true, b, NULL) == COMPLETE_ASCII_STRING_NODE)

	#if DEBUG
		#define printXEvent(n) /*--------*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %sX event:%s %s\n", colorStart, programName, colorEvent, colorEnd \
			, useXEventName(n, eventName) \
			: useXEventName(n, randrEventName) \
			: "unhandled extension event" \
		))
		#define useXEventName(n0, n1) /*-*/ n0 == n1? *(n1 + (((*event).response_type & ~b(10000000)) >= countof(n1)? countof(n1) - 1 : (*event).response_type & ~b(10000000)))
		#define printCommand(s) /*-------*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %scommand " s ":%s %s\n", colorStart, programName, colorEvent, colorEnd, *(commandList + ((*eventModifierNode).command >= countof(commandList)? countof(commandList) - 1 : (*eventModifierNode).command))))
	#else
		#define printXEvent(void) /*-----*/ EMPTY_MACRO
		#define printCommand(void) /*----*/ EMPTY_MACRO
	#endif
/*!}*/

/*!defs:{*/
	def uint8 /*-*/ Command;
	def uint8 /*-*/ Instruction;
	def uint8 /*-*/ JmpPoint;

	def struct{
		const char * /*--------*/ label;
		uint64 * /*------------*/ data;
		uint32 /*--------------*/ token;
		uint32 /*--------------*/ line;
		const char * /*--------*/ file;
		int /*-----------------*/ (*free)(void *);
	} Pointer;

	def struct{
		Pointer * /*-----------*/ data;
		uint16 /*--------------*/ size;
		uint16 /*--------------*/ allocated;
		uint8 /*---------------*/ pad0[4];
	} DynamicDataSegment;

	def struct{
		int32 /*---------------*/ leftX;
		int32 /*---------------*/ rightX;
		int32 /*---------------*/ topY;
		int32 /*---------------*/ bottomY;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		uint32 /*--------------*/ millimeterWidth;
		uint32 /*--------------*/ millimeterHeight;
	} Monitor;

	def struct{
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint16 /*--------------*/ offset[STRING_NODE_CHILDREN_AMOUNT];
	} StringNode;

	def struct{
		StringNode * /*--------*/ dataStart;
		const char *const * /*-*/ stringArray;
		uint32 /*--------------*/ dataToken;
		uint16 /*--------------*/ dataSize;
		uint16 /*--------------*/ dataAllocated;
		uint8 /*---------------*/ pad0[4];
		uint8 /*---------------*/ counter;
		uint8 /*---------------*/ returnedCounter;
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint16 /*--------------*/ offset[28];
	} StringNodeRoot;

	def struct{
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint8 /*---------------*/ counter;
		uint8 /*---------------*/ pad0[1];
		uint32 /*--------------*/ childOffset[128];
		uint32 /*--------------*/ parentOffset;
	} ASCIIStringNode;

	def struct{
		uint32 /*--------------*/ dataSize;
		uint32 /*--------------*/ dataAllocated;
		ASCIIStringNode * /*---*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint32 /*--------------*/ stringsFoundAmount;
		uint32 /*--------------*/ stringsFoundSize;
		uint32 /*--------------*/ stringsFoundAllocated;
		uint8 * /*-------------*/ stringsFoundStart;
		uint32 /*--------------*/ stringsFoundToken;
		uint32 /*--------------*/ utf8StringAmount;
		uint32 /*--------------*/ utf8StringSize;
		uint32 /*--------------*/ utf8StringAllocated;
		uint8 * /*-------------*/ utf8StringStart;
		uint32 /*--------------*/ utf8StringToken;
		uint8 /*---------------*/ pad0[4];
	} ASCIIStringNodeRoot;

	def struct{
		bool /*----------------*/ inUse;
		Command /*-------------*/ command;
		uint16 /*--------------*/ modifier;
		int32 /*---------------*/ nextOffset;
		char * /*--------------*/ string;
		uint32 /*--------------*/ stringToken;
		int32 /*---------------*/ field0;
		int32 /*---------------*/ field1;
		int32 /*---------------*/ field2;
		int32 /*---------------*/ field3;
		int32 /*---------------*/ field4;
	} ModifierNode;

	def struct{
		uint32 /*--------------*/ codeListStart[SHORTCUT_CODE_AMOUNT];
		uint32 /*--------------*/ codeListWall[SHORTCUT_CODE_AMOUNT];
		ModifierNode * /*------*/ modifierStart;
		uint32 /*--------------*/ modifierToken;
		uint32 /*--------------*/ modifierSize;
		uint32 /*--------------*/ modifierAllocated;
		uint32 /*--------------*/ modifierNotInUseOffset;
	} ShortcutNodeRoot;

	def struct{
		void * /*--------------*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint32 /*--------------*/ size;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
	} Image;

	def struct{
		xcb_atom_t /*----------*/ WM_NAME;
		xcb_atom_t /*----------*/ WM_ICON_NAME;
		xcb_atom_t /*----------*/ WM_NORMAL_HINTS;
		xcb_atom_t /*----------*/ WM_SIZE_HINTS;
		xcb_atom_t /*----------*/ WM_HINTS;
		xcb_atom_t /*----------*/ WM_CLASS;
		xcb_atom_t /*----------*/ WM_TRANSIENT_FOR;
		xcb_atom_t /*----------*/ WM_PROTOCOLS;
		xcb_atom_t /*----------*/ WM_TAKE_FOCUS;
		xcb_atom_t /*----------*/ WM_DELETE_WINDOW;
		xcb_atom_t /*----------*/ WM_COLORMAP_WINDOWS;
		xcb_atom_t /*----------*/ WM_COLORMAP_NOTIFY;
		xcb_atom_t /*----------*/ WM_CLIENT_MACHINE;
		xcb_atom_t /*----------*/ WM_LOCALE_NAME;
		xcb_atom_t /*----------*/ WM_WINDOW_ROLE;
		xcb_atom_t /*----------*/ WM_COMMAND;
		xcb_atom_t /*----------*/ WM_CLIENT_LEADER;
		xcb_atom_t /*----------*/ WM_STATE;
		xcb_atom_t /*----------*/ WM_CHANGE_STATE;
		xcb_atom_t /*----------*/ WM_ICON_SIZE;
		xcb_atom_t /*----------*/ UTF8_STRING;
		xcb_atom_t /*----------*/ _NET_SUPPORTED;
		xcb_atom_t /*----------*/ _NET_CLIENT_LIST;
		xcb_atom_t /*----------*/ _NET_CLIENT_LIST_STACKING;
		xcb_atom_t /*----------*/ _NET_NUMBER_OF_DESKTOPS;
		xcb_atom_t /*----------*/ _NET_DESKTOP_GEOMETRY;
		xcb_atom_t /*----------*/ _NET_DESKTOP_VIEWPORT;
		xcb_atom_t /*----------*/ _NET_CURRENT_DESKTOP;
		xcb_atom_t /*----------*/ _NET_DESKTOP_NAMES;
		xcb_atom_t /*----------*/ _NET_ACTIVE_WINDOW;
		xcb_atom_t /*----------*/ _NET_WORKAREA;
		xcb_atom_t /*----------*/ _NET_SUPPORTING_WM_CHECK;
		xcb_atom_t /*----------*/ _NET_VIRTUAL_ROOTS;
		xcb_atom_t /*----------*/ _NET_DESKTOP_LAYOUT;
		xcb_atom_t /*----------*/ _NET_SHOWING_DESKTOP;
		xcb_atom_t /*----------*/ _NET_CLOSE_WINDOW;
		xcb_atom_t /*----------*/ _NET_MOVERESIZE_WINDOW;
		xcb_atom_t /*----------*/ _NET_WM_MOVERESIZE;
		xcb_atom_t /*----------*/ _NET_RESTACK_WINDOW;
		xcb_atom_t /*----------*/ _NET_REQUEST_FRAME_EXTENTS;
		xcb_atom_t /*----------*/ _NET_WM_NAME;
		xcb_atom_t /*----------*/ _NET_WM_VISIBLE_NAME;
		xcb_atom_t /*----------*/ _NET_WM_ICON_NAME;
		xcb_atom_t /*----------*/ _NET_WM_VISIBLE_ICON_NAME;
		xcb_atom_t /*----------*/ _NET_WM_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DOCK;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_TOOLBAR;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_MENU;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_UTILITY;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_SPLASH;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DIALOG;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_NORMAL;
		xcb_atom_t /*----------*/ _NET_WM_STATE;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MODAL;
		xcb_atom_t /*----------*/ _NET_WM_STATE_STICKY;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MAXIMIZED_VERT;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MAXIMIZED_HORZ;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SHADED;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SKIP_TASKBAR;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SKIP_PAGER;
		xcb_atom_t /*----------*/ _NET_WM_STATE_HIDDEN;
		xcb_atom_t /*----------*/ _NET_WM_STATE_FULLSCREEN;
		xcb_atom_t /*----------*/ _NET_WM_STATE_ABOVE;
		xcb_atom_t /*----------*/ _NET_WM_STATE_BELOW;
		xcb_atom_t /*----------*/ _NET_WM_STATE_DEMANDS_ATTENTION;
		xcb_atom_t /*----------*/ _NET_WM_ALLOWED_ACTIONS;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MOVE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_RESIZE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MINIMIZE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_SHADE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_STICK;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MAXIMIZE_HORZ;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MAXIMIZE_VERT;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_FULLSCREEN;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_CHANGE_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_CLOSE;
		xcb_atom_t /*----------*/ _NET_WM_STRUT;
		xcb_atom_t /*----------*/ _NET_WM_STRUT_PARTIAL;
		xcb_atom_t /*----------*/ _NET_WM_ICON_GEOMETRY;
		xcb_atom_t /*----------*/ _NET_WM_ICON;
		xcb_atom_t /*----------*/ _NET_WM_PID;
		xcb_atom_t /*----------*/ _NET_WM_HANDLED_ICONS;
		xcb_atom_t /*----------*/ _NET_WM_USER_TIME;
		xcb_atom_t /*----------*/ _NET_FRAME_EXTENTS;
		xcb_atom_t /*----------*/ _NET_WM_PING;
		xcb_atom_t /*----------*/ _NET_WM_SYNC_REQUEST;
		xcb_atom_t /*----------*/ _NET_WM_SYNC_REQUEST_COUNTER;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_ORIENTATION;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_OPCODE;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_MESSAGE_DATA;
		xcb_atom_t /*----------*/ _XEMBED_INFO;
		xcb_atom_t /*----------*/ _XEMBED;
		xcb_atom_t /*----------*/ _XROOTPMAP_ID;
	} CommonAtoms;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ xOffset;
		int32 /*---------------*/ yOffset;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		uint8 /*---------------*/ xType;
		uint8 /*---------------*/ yType;
		uint8 /*---------------*/ xOffsetType;
		uint8 /*---------------*/ yOffsetType;
		uint8 /*---------------*/ widthType;
		uint8 /*---------------*/ heightType;
		uint8 /*---------------*/ horizontalAlignment;
		uint8 /*---------------*/ verticalAlignment;
		uint32 /*--------------*/ padding;
		uint32 /*--------------*/ margin;
		uint32 /*--------------*/ gap;
		uint32 /*--------------*/ cornerRadius;
		uint8 /*---------------*/ cornerUsed;
		uint8 /*---------------*/ pad0[3];
		uint32 /*--------------*/ foreground;
		uint32 /*--------------*/ background;
		uint32 /*--------------*/ selectedForeground;
		uint32 /*--------------*/ selectedBackground;
	} ElementPreferences;

	def struct{
		const Monitor * /*-----*/ monitor;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
	} ElementRectangle;
/*!}*/

/*!globals:{*/
	local const char * /*-----------------*/ programName;
	local const char * /*-----------------*/ localeName;
	local const char * /*-----------------*/ configPath;
	local const char * /*-----------------*/ errorPath;
	local const char * /*-----------------*/ connectionName;
	local const char * /*-----------------*/ colorStart;
	local const char * /*-----------------*/ colorFatal;
	local const char * /*-----------------*/ colorError;
	local const char * /*-----------------*/ colorEvent;
	local const char * /*-----------------*/ colorEnd;
	local const char * /*-----------------*/ labelExamined;
	local const ModifierNode * /*---------*/ eventModifierNode;
	local bool /*-------------------------*/ memorySegmentMutexCreated;
	local pthread_mutex_t /*--------------*/ memorySegmentMutex;
	local bool /*-------------------------*/ mustOpenErrorStream;
	local FILE * /*-----------------------*/ errorStream;
	local uint32 /*-----------------------*/ errorStreamToken;
	local volatile bool /*----------------*/ processingSignal;
	local bool /*-------------------------*/ quitting;
	local DynamicDataSegment /*-----------*/ dynamicDataSegment;
	local bool /*-------------------------*/ globalsLockCreated;
	local pthread_rwlock_t /*-------------*/ globalsLock;
	local bool /*-------------------------*/ shmRunning;
	local int /*--------------------------*/ shmid;
	local uint32 /*-----------------------*/ shmidToken;
	local uint8 * /*----------------------*/ sharedStart;
	local uint32 /*-----------------------*/ sharedToken;
	local uint8 * /*----------------------*/ sharedCurrent;
	local bool /*-------------------------*/ sharedMutexCreated;
	local pthread_mutex_t * /*------------*/ sharedMutex;
	local bool /*-------------------------*/ sharedCondCreated;
	local pthread_cond_t * /*-------------*/ sharedCond;
	local bool /*-------------------------*/ sharedThreadCreated;
	local pthread_t /*--------------------*/ sharedThread;
	local bool /*-------------------------*/ sharedQuittingThread;
	local int /*--------------------------*/ screenNumber;
	local xcb_connection_t * /*-----------*/ connection;
	local uint32 /*-----------------------*/ connectionToken;
	local xcb_screen_t * /*---------------*/ screen;
	local Display * /*--------------------*/ display;
	local uint32 /*-----------------------*/ displayToken;
	local XIM /*--------------------------*/ im;
	local XIC /*--------------------------*/ ic;
	local uint8 /*------------------------*/ randrMajorOpcode;
	local uint8 /*------------------------*/ randrBaseEvent;
	local uint8 /*------------------------*/ randrBaseError;
	local xcb_visualid_t /*---------------*/ visual;
	local uint8 /*------------------------*/ depth;
	local CommonAtoms /*------------------*/ atom;
	local uint /*-------------------------*/ monitorAllocated;
	local Monitor * /*--------------------*/ monitorStart;
	local uint32 /*-----------------------*/ monitorToken;
	local xcb_colormap_t /*---------------*/ colormap;
	local bool /*-------------------------*/ displaySimpleConfigErrors;
	local StringNodeRoot /*---------------*/ globalScopesInstructionRoot;
	local StringNodeRoot /*---------------*/ globalInstructionRoot;
	local StringNodeRoot /*---------------*/ scope1ScopeInstructionRoot;
	local StringNodeRoot /*---------------*/ booleanRoot;
	local StringNodeRoot /*---------------*/ commandRoot;
	local StringNodeRoot /*---------------*/ variableRoot;
	local StringNodeRoot /*---------------*/ modifierRoot;
	local StringNodeRoot /*---------------*/ macroRoot;



	/*!*/

	local StringNodeRoot /*---------------*/ horizontalAlignmentRoot;
	local StringNodeRoot /*---------------*/ verticalAlignmentRoot;
	local StringNodeRoot /*---------------*/ numberTypeRoot;
	local StringNodeRoot /*---------------*/ whichMonitorRoot;
	local StringNodeRoot /*---------------*/ cornerRoot;



	local ShortcutNodeRoot /*-------------*/ keycodeShortcut;
	local ShortcutNodeRoot /*-------------*/ buttonShortcut;
	local int /*--------------------------*/ keyPressNextOffset;
	local int /*--------------------------*/ keyReleaseNextOffset;
	local int /*--------------------------*/ buttonPressNextOffset;
	local int /*--------------------------*/ buttonReleaseNextOffset;
	local xcb_generic_event_t * /*--------*/ event;
	local uint32 /*-----------------------*/ eventToken;
	local uint8 /*------------------------*/ shortcutCode;
	local uint16 /*-----------------------*/ shortcutModifier;









	/*!*/









	local const char *const /*------------*/ errorName[] = {"unrecognized", "request", "value", "window", "pixmap", "atom", "cursor", "font", "match", "drawable", "access", "allocation", "colormap", "graphics context", "id choice", "name", "length", "implementation", "unrecognized"};
	local const char *const /*------------*/ operationName[] = {"unrecognized", "create window", "change window attributes", "get window attributes", "destroy window", "destroy subwindows", "change save set", "reparent window", "map window", "map subwindows", "unmap window", "unmap subwindows", "configure window", "circulate window", "get geometry", "query tree", "intern atom", "get atom name", "change property", "delete property", "get property", "list properties", "set selection owner", "get selection owner", "convert selection", "send event", "grab pointer", "ungrab pointer", "grab button", "ungrab button", "change active pointer grab", "grab keyboard", "ungrab keyboard", "grab key", "ungrab key", "allow events", "grab server", "ungrab server", "query pointer", "get motion events", "translate coordinates", "warp pointer", "set input focus", "get input focus", "query keymap", "open font", "close font", "query font", "query text extents", "list fonts", "list fonts with info", "set font path", "get font path", "create pixmap", "free pixmap", "create graphics context", "change graphics context", "copy graphics context", "set dashes", "set clip rectangles", "free graphics context", "clear area", "copy area", "copy plane", "poly point", "poly line", "poly segment", "poly rectangle", "poly arc", "fill poly", "poly fill rectangle", "poly fill arc", "put image", "get image", "poly text (8)", "poly text (16)", "image text (8)", "image text (16)", "create colormap", "free colormap", "copy colormap and free", "install colormap", "uninstall colormap", "list installed colormaps", "allocate color", "allocate named color", "allocate color cells", "allocate color planes", "free colors", "store colors", "store named color", "query colors", "lookup color", "create cursor", "create glyph cursor", "free cursor", "recolor cursor", "query best size", "query extension", "list extensions", "change keyboard mapping", "get keyboard mapping", "change keyboard control", "get keyboard control", "bell", "change pointer control", "get pointer control", "set screen saver", "get screen saver", "change hosts", "list hosts", "set access control", "set close down mode", "kill client", "rotate properties", "force screen saver", "set pointer mapping", "get pointer mapping", "set modifier mapping", "get modifier mapping", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "no", "unrecognized"};
	local const char *const /*------------*/ randrErrorName[] = {"bad output", "bad crtc", "bad mode", "bad provider", "unrecognized"};
	local const char *const /*------------*/ randrOperationName[] = {"query version", "unrecognized", "set screen config", "unrecognized", "select input", "get screen info", "get screen size range", "set screen size", "get screen resources", "get output info", "list output properties", "query output property", "configure output property", "change output property", "delete output property", "get output property", "create mode", "destroy mode", "add output mode", "delete output mode", "get crtc info", "set crtc config", "get crtc gamma size", "get crtc gamma", "set crtc gamma", "get screen resources current", "set crtc transform", "get crtc transform", "get panning", "set panning", "set output primary", "get output primary", "get providers", "get provider info", "set provider offload sink", "set provider output source", "list provider properties", "query provider property", "configure provider property", "change provider property", "delete provider property", "get provider property", "get monitors", "set monitor", "delete monitor", "create lease", "free lease", "unrecognized"};

	local const char *const /*------------*/ globalScopesInstructionList[] = {
		  "scope1"
		, NULL
	};
	local const char *const /*------------*/ globalInstructionList[] = {
		  "help"
		, "expand"
		, "contract"
		, "read-config"
		, "use-messenger"
		, "do"
		, "set"
		, "grab-keycode"
		, "grab-button"
		, "grab-gesture"
		, "ungrab-keycode"
		, "ungrab-button"
		, "ungrab-gesture"
		, "stop"
		, NULL
	};
	local const char *const /*------------*/ scope1ScopeInstructionList[] = {
		  "help"
		, "expand"
		, "contract"
		, "stop"
		, NULL
	};
	local const char *const /*------------*/ booleanList[] = {
		  "none"
		, "true"
		, "false"
		, NULL
	};
	local const char *const /*------------*/ commandList[] = {
		  "none"
		, "execute"
		, "to-next-letter"
		, "to-previous-letter"
		, "to-next-word"
		, "to-previous-word"
		, "to-start-of-line"
		, "to-end-of-line"
		, "to-next-result"
		, "to-previous-result"
		, "remove-left-letter"
		, "remove-right-letter"
		, "remove-left-word"
		, "remove-right-word"
		, "select-left-letter"
		, "select-right-letter"
		, "select-left-word"
		, "select-right-word"
		, "select-to-start-of-line"
		, "select-to-end-of-line"
		, "select-all"
		, "copy-selection"
		, "cut-selection"
		, "paste-selection"
		, "uppercase-selection"
		, "lowercase-selection"
		, "toggle-insert-mode"
		, "pick-result"
		, "launch"
		, "restart"
		, "exit"
		, NULL
	};
	local const char *const /*------------*/ variableList[] = {
		  "none"
		, "window-x"
		, "window-y"
		, "window-x-offset"
		, "window-y-offset"
		, "window-width"
		, "window-height"
		, "window-horizontal-alignment"
		, "window-vertical-alignment"
		, "window-corner-radius"
		, "window-background"
		, "input-x"
		, "input-y"
		, "input-x-offset"
		, "input-y-offset"
		, "input-width"
		, "input-height"
		, "input-horizontal-alignment"
		, "input-vertical-alignment"
		, "input-padding"
		, "input-margin"
		, "input-background"
		, "input-content-x"
		, "input-content-y"
		, "input-content-x-offset"
		, "input-content-y-offset"
		, "input-content-horizontal-alignment"
		, "input-content-vertical-alignment"
		, "input-content-foreground"
		, "input-content-background"
		, "input-content-selected-foreground"
		, "input-content-selected-background"
		, "result-x"
		, "result-y"
		, "result-x-offset"
		, "result-y-offset"
		, "result-width"
		, "result-height"
		, "result-horizontal-alignment"
		, "result-vertical-alignment"
		, "result-padding"
		, "result-margin"
		, "result-gap"
		, "result-background"
		, "result-selected-background"
		, "result-content-x"
		, "result-content-y"
		, "result-content-x-offset"
		, "result-content-y-offset"
		, "result-content-horizontal-alignment"
		, "result-content-vertical-alignment"
		, "result-content-foreground"
		, "result-content-background"
		, "result-content-selected-foreground"
		, "result-content-selected-background"
		, "which-monitor"
		, "font"
		, "maximum-result-amount"
		, "result-allow-circular-navigation"
		, NULL
	};
	local const char *const /*------------*/ modifierList[] = {
		  "none"
		, "shift"
		, "caps"
		, "control"
		, "mod-1"
		, "mod-2"
		, "mod-3"
		, "mod-4"
		, "mod-5"
		, "button-1"
		, "button-2"
		, "button-3"
		, "button-4"
		, "button-5"
		, NULL
	};
	local const char *const /*------------*/ macroList[] = {
		  "button-1"
		, "button-2"
		, "button-3"
		, "button-4"
		, "button-5"
		, NULL
	};



	/*!*/

	local const char *const /*------------*/ numberTypeList[] = {
		  "none"
		, "integer"
		, "percentage"
		, "millimeter"
		, NULL
	};
	local const char *const /*------------*/ horizontalAlignmentList[] = {
		  "none"
		, "left"
		, "center"
		, "right"
		, NULL
	};
	local const char *const /*------------*/ verticalAlignmentList[] = {
		  "none"
		, "top"
		, "center"
		, "bottom"
		, NULL
	};
	local const char *const /*------------*/ whichMonitorList[] = {
		  "none"
		, "pointer"
		, "focused-window"
		, NULL
	};
	local const char *const /*------------*/ cornerList[] = {
		  "none"
		, "top-left"
		, "top-right"
		, "bottom-left"
		, "bottom-right"
		, NULL
	};



	local const Instruction /*------------*/ helpInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ expandInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ contractInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ readConfigInstruction[] = {STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ useMessengerInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ doInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ setInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ grabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ grabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ ungrabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ ungrabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ stopInstruction[] = {END_INSTRUCTION_TYPE};

	local const Instruction /*------------*/ executeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, EXECUTE_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ windowXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ windowYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ windowXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ windowYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ windowWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ windowHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ windowHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ windowVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ windowCornerRadiusSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ windowBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputPaddingSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputMarginSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputContentXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputContentYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputContentXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputContentYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputContentHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputContentVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputContentForegroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputContentBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputContentSelectedForegroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ inputContentSelectedBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultPaddingSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultMarginSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultGapSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultSelectedBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultContentXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultContentYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultContentXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultContentYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultContentHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultContentVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultContentForegroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultContentBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultContentSelectedForegroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultContentSelectedBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ whichMonitorSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ fontSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ maximumResultAmountSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ resultAllowCircularNavigationSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ executeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, EXECUTE_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*------------*/ executeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, EXECUTE_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};

	local StringNodeRoot *const *const /*-*/ helpInstructionData = NULL;
	local StringNodeRoot *const *const /*-*/ expandInstructionData = NULL;
	local StringNodeRoot *const *const /*-*/ contractInstructionData = NULL;
	local StringNodeRoot *const *const /*-*/ readConfigInstructionData = NULL;
	local StringNodeRoot *const /*--------*/ useMessengerInstructionData[] = {&booleanRoot};
	local StringNodeRoot *const /*--------*/ doInstructionData[] = {&commandRoot};
	local StringNodeRoot *const /*--------*/ setInstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ grabKeycodeInstructionData[] = {&modifierRoot, &commandRoot};
	local StringNodeRoot *const /*--------*/ grabButtonInstructionData[] = {&modifierRoot, &commandRoot};
	local StringNodeRoot *const /*--------*/ ungrabKeycodeInstructionData[] = {&modifierRoot};
	local StringNodeRoot *const /*--------*/ ungrabButtonInstructionData[] = {&modifierRoot};
	local StringNodeRoot *const *const /*-*/ stopInstructionData = NULL;

	local StringNodeRoot *const /*--------*/ executeDoSubinstructionData[] = {&commandRoot};
	local StringNodeRoot *const /*--------*/ windowXSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ windowYSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ windowXOffsetSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ windowYOffsetSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ windowWidthSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ windowHeightSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ windowHorizontalAlignmentSetSubinstructionData[] = {&variableRoot, &horizontalAlignmentRoot};
	local StringNodeRoot *const /*--------*/ windowVerticalAlignmentSetSubinstructionData[] = {&variableRoot, &verticalAlignmentRoot};
	local StringNodeRoot *const /*--------*/ windowCornerRadiusSetSubinstructionData[] = {&variableRoot, &cornerRoot};
	local StringNodeRoot *const /*--------*/ windowBackgroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ inputXSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ inputYSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ inputXOffsetSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ inputYOffsetSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ inputWidthSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ inputHeightSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ inputHorizontalAlignmentSetSubinstructionData[] = {&variableRoot, &horizontalAlignmentRoot};
	local StringNodeRoot *const /*--------*/ inputVerticalAlignmentSetSubinstructionData[] = {&variableRoot, &verticalAlignmentRoot};
	local StringNodeRoot *const /*--------*/ inputPaddingSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ inputMarginSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ inputBackgroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ inputContentXSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ inputContentYSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ inputContentXOffsetSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ inputContentYOffsetSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ inputContentHorizontalAlignmentSetSubinstructionData[] = {&variableRoot, &horizontalAlignmentRoot};
	local StringNodeRoot *const /*--------*/ inputContentVerticalAlignmentSetSubinstructionData[] = {&variableRoot, &verticalAlignmentRoot};
	local StringNodeRoot *const /*--------*/ inputContentForegroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ inputContentBackgroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ inputContentSelectedForegroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ inputContentSelectedBackgroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ resultXSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ resultYSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ resultXOffsetSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ resultYOffsetSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ resultWidthSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ resultHeightSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ resultHorizontalAlignmentSetSubinstructionData[] = {&variableRoot, &horizontalAlignmentRoot};
	local StringNodeRoot *const /*--------*/ resultVerticalAlignmentSetSubinstructionData[] = {&variableRoot, &verticalAlignmentRoot};
	local StringNodeRoot *const /*--------*/ resultPaddingSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ resultMarginSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ resultGapSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ resultBackgroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ resultSelectedBackgroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ resultContentXSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ resultContentYSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ resultContentXOffsetSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ resultContentYOffsetSetSubinstructionData[] = {&variableRoot, &numberTypeRoot};
	local StringNodeRoot *const /*--------*/ resultContentHorizontalAlignmentSetSubinstructionData[] = {&variableRoot, &horizontalAlignmentRoot};
	local StringNodeRoot *const /*--------*/ resultContentVerticalAlignmentSetSubinstructionData[] = {&variableRoot, &verticalAlignmentRoot};
	local StringNodeRoot *const /*--------*/ resultContentForegroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ resultContentBackgroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ resultContentSelectedForegroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ resultContentSelectedBackgroundSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ whichMonitorSetSubinstructionData[] = {&variableRoot, &whichMonitorRoot};
	local StringNodeRoot *const /*--------*/ fontSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ maximumResultAmountSetSubinstructionData[] = {&variableRoot};
	local StringNodeRoot *const /*--------*/ resultAllowCircularNavigationSetSubinstructionData[] = {&variableRoot, &booleanRoot};
	local StringNodeRoot *const /*--------*/ executeGrabKeycodeSubinstructionData[] = {&modifierRoot, &commandRoot};
	local StringNodeRoot *const /*--------*/ executeGrabButtonSubinstructionData[] = {&modifierRoot, &commandRoot};

	#define getInstruction(i) /*-----*/ (i##Instruction)
	#define getInstructionData(i) /*-*/ (i##InstructionData)
	#define getGlobalScope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(readConfig) \
		, get##i(useMessenger) \
		, get##i(do) \
		, get##i(set) \
		, get##i(grabKeycode) \
		, get##i(grabButton) \
		, get##i(ungrabKeycode) \
		, get##i(ungrabButton) \
		, get##i(stop) \
	}
	#define getScope1Scope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(stop) \
	}
	local const Instruction *const /*-----*/ globalScopeInstruction[] = getGlobalScope(Instruction);
	local const Instruction *const /*-----*/ scope1ScopeInstruction[] = getScope1Scope(Instruction);

	local StringNodeRoot *const *const /*-*/ globalScopeInstructionData[] = getGlobalScope(InstructionData);
	local StringNodeRoot *const *const /*-*/ scope1ScopeInstructionData[] = getScope1Scope(InstructionData);
	#undef  getScope1Scope
	#undef  getGlobalScope
	#undef  getInstructionData
	#undef  getInstruction

	#if DEBUG
	local const char *const /*------------*/ eventName[] = {"error", "unrecognized", "key press", "key release", "button press", "button release", "motion notify", "enter notify", "leave notify", "focus in", "focus out", "keymap notify", "expose", "graphics expose", "no expose", "visibility notify", "create notify", "destroy notify", "unmap notify", "map notify", "map request", "reparent notify", "configure notify", "configure request", "gravity notify", "resize request", "circulate notify", "circulate request", "property notify", "selection clear", "selection request", "selection notify", "colormap notify", "client message", "mapping notify", "generic event"};
	local const char *const /*------------*/ randrEventName[] = {"screen change notify", "notify", "unrecognized"};
	#endif
/*!}*/

/*!functions:{*/
	QUIT();
	GETSHAREDCHARACTER();
	INITMEMORYMANAGER();
	PUSHPOINTER();
	POPPOINTER();
	UPDATEPOINTER();
	DELETEMEMORYMANAGER();
	IFREE();
	ISHMCTL();
	IXCBDISCONNECT();
	SHMINIT();
	SHMCONNECT();
	SHMMAIN();
	SHMDISCONNECT();
	IDENTIFYARGUMENT();
	INSENSITIVESTRINGCOMPARE();
	SENSITIVESTRINGCOMPARE();
	SETSTRINGROOT();
	BULKINSERTSTRING();
	INSERTSTRING();
	GETSTRINGNODE();
	DELETESTRINGROOT();
	SETSHORTCUTROOT();
	INSERTSHORTCUT();
	GETNEXTSHORTCUT();
	REMOVESHORTCUT();
	UNSETSHORTCUTROOT();
	UNGRABSHORTCUTS();
	RANDRQUERYVERSIONUNCHECKED();
	SETASCIISTRINGROOT();
	PATHINSERTSTRING();
	ISASCIISTRING();
	INSERTASCIISTRING();
	GETASCIISTRINGNODE();
	GETMULTIPLEASCIISTRINGNODES();
	DELETEASCIISTRINGROOT();
	SETCONFIGVARIABLES();
	SETELEMENTPREFERENCES();
	READCONFIG();
	MATCHNAMELIST();
	MATCHINTEGER();
	MATCHSTRING();
	MATCHEXECUTE();
	READIMAGE();
	FREECONFIGVARIABLES();
	MATCHCOMMAND();
	EXEC();
	SETMEMORY();
	COPYMEMORY();
	FINDSTRINGLENGTH();
	UTF8TOUCS2();
	GETTIMESTAMP();
	GETPOINTERMONITOR();
	GETWINDOWMONITOR();
	CREATECIRCLE();
	COMPOSITEIMAGES();
	COMPOSITEIMAGESOVER();
	COMPOSITEIMAGESAND();
	TWOPASSBOXBLUR();
	ROTATEIMAGE();
	FILLDRAWABLE();
	RESTARTCOMMAND();
	EXITCOMMAND();
	CANCELTHREADS();
	FREEMONITORS();
	PRINTUNACCOUNTEDFORPOINTERS();
	PRINTERROR();
	PRINTTITLEDERROR();
	PRINTTITLEDQUOTEDERROR();
	PRINTCONNECTIONERROR();
	PRINTTITLEDNAMEDERROR();
	PRINTXERROR();
	PRINTTITLEDVALUEDERROR();
	PRINTCONFIGERROR();
	OPENERRORSTREAM();
	CLOSEERRORSTREAM();
/*!}*/









#define NONE_HORIZONTAL_ALIGNMENT /*-------------*/ (0)
#define LEFT_HORIZONTAL_ALIGNMENT /*-------------*/ (1)
#define CENTER_HORIZONTAL_ALIGNMENT /*-----------*/ (2)
#define RIGHT_HORIZONTAL_ALIGNMENT /*------------*/ (3)

#define NONE_VERTICAL_ALIGNMENT /*---------------*/ (0)
#define TOP_VERTICAL_ALIGNMENT /*----------------*/ (1)
#define CENTER_VERTICAL_ALIGNMENT /*-------------*/ (2)
#define BOTTOM_VERTICAL_ALIGNMENT /*-------------*/ (3)

#define NONE_NUMBER_TYPE /*----------------------*/ (0)
#define INTEGER_NUMBER_TYPE /*-------------------*/ (1)
#define PERCENTAGE_NUMBER_TYPE /*----------------*/ (2)
#define MILLIMETER_NUMBER_TYPE /*----------------*/ (3)

#define NONE_WHICH_MONITOR /*--------------------*/ (0)
#define POINTER_WHICH_MONITOR /*-----------------*/ (1)
#define FOCUSED_WINDOW_WHICH_MONITOR /*----------*/ (2)

#define NONE_AXIS /*-----------------------------*/ (0)
#define HORIZONTAL_AXIS /*-----------------------*/ (1)
#define VERTICAL_AXIS /*-------------------------*/ (2)

#define NONE_CORNER_USED /*----------------------*/ (b(0000))
#define TOP_LEFT_CORNER_USED /*------------------*/ (b(0001))
#define TOP_RIGHT_CORNER_USED /*-----------------*/ (b(0010))
#define BOTTOM_LEFT_CORNER_USED /*---------------*/ (b(0100))
#define BOTTOM_RIGHT_CORNER_USED /*--------------*/ (b(1000))

#define NONE_INPUT_MODE /*-----------------------*/ (0)
#define NORMAL_INPUT_MODE /*---------------------*/ (1)
#define INSERT_INPUT_MODE /*---------------------*/ (2)

#define NONE_MATCH_LENGTH /*---------------------*/ (0)
#define CHARACTER_MATCH_LENGTH /*----------------*/ (1)
#define WORD_MATCH_LENGTH /*---------------------*/ (2)

#define NONE_DIRECTION /*------------------------*/ (0)
#define LEFT_DIRECTION /*------------------------*/ (1)
#define RIGHT_DIRECTION /*-----------------------*/ (2)

#define NONE_CASE /*-----------------------------*/ (0)
#define UPPER_CASE /*----------------------------*/ (1)
#define LOWER_CASE /*----------------------------*/ (2)

#define CONFIGUREWINDOW() /*---------------------*/ local void             configureWindow(void)
#define UPDATEWINDOW() /*------------------------*/ local void             updateWindow(void)
#define MAPWINDOW() /*---------------------------*/ local void             mapWindow(void)
#define GETWHICHMONITOR() /*---------------------*/ local Monitor *        getWhichMonitor(void)
#define GETFOCUSEDWINDOW() /*--------------------*/ local xcb_window_t     getFocusedWindow(void)
#define SETWINDOWPROPERTIES() /*-----------------*/ local void             setWindowProperties(const xcb_window_t window, const Monitor *const monitor, const int x, const int y, const uint width, const uint height)
#define DRAWWINDOW() /*--------------------------*/ local void             drawWindow(const xcb_window_t window, const Monitor *const monitor, ElementRectangle *windowRectangle)
#define GETRECTANGLE() /*------------------------*/ local bool             getRectangle(const Monitor *const _monitor, const xcb_query_text_extents_reply_t *const reply, const ElementRectangle *const parentRectangle, const ElementPreferences *const preferences, ElementRectangle *const rectangle)
#define GETTYPEDNUMBER() /*----------------------*/ local int              getTypedNumber(const int number, const uint8 type, const uint8 axis, const int size, const Monitor *const monitor)
#define DRAWSEGMENTEDUTF8() /*-------------------*/ local void             drawSegmentedUTF8(const uint8 *current, int *const x, const int y, const uint32 foreground, const uint32 background)
#define SETCLIPPINGRECTANGLE() /*----------------*/ local void             setClippingRectangle(const xcb_gcontext_t gc, const int x, const int y, const uint width, const uint height)
#define UNSETCLIPPINGRECTANGLE() /*--------------*/ local void             unsetClippingRectangle(const xcb_gcontext_t gc)

#define SETINPUTBUFFER() /*----------------------*/ local void             setInputBuffer(InputBuffer *const inputBuffer)
#define RESIZEINPUTBUFFER() /*-------------------*/ local bool             resizeInputBuffer(InputBuffer *const inputBuffer, const uint count)
#define UNSETINPUTBUFFER() /*--------------------*/ local void             unsetInputBuffer(InputBuffer *const inputBuffer)
#define SETCLIPBOARDBUFFER() /*------------------*/ local void             setClipboardBuffer(ClipboardBuffer *const clipboardBuffer)
#define ALLOCATECLIPBOARDBUFFER() /*-------------*/ local bool             allocateClipboardBuffer(ClipboardBuffer *const clipboardBuffer, const uint length)
#define UBSETCLIPBOARDBUFFER() /*----------------*/ local void             unsetClipboardBuffer(ClipboardBuffer *const clipboardBuffer)

#define INSERTCHARACTER() /*---------------------*/ local void             insertCharacter(InputBuffer *const inputBuffer, const xcb_key_press_event_t *const e)









#define GETCHARACTERLENGTH() /*------------------*/ local uint             getCharacterLength(const uint8 direction, const uint8 *const p)
#define GETWORDLENGTH() /*-----------------------*/ local uint             getWordLength(InputBuffer *const inputBuffer, const uint8 direction, const uint8 *const p)
#define CHANGEMODE() /*--------------------------*/ local void             changeMode(void)

#define GOTOLEFT() /*----------------------------*/ local void             gotoLeft(InputBuffer *const inputBuffer, const uint8 matchLength)
#define GOTORIGHT() /*---------------------------*/ local void             gotoRight(InputBuffer *const inputBuffer, const uint8 matchLength)
#define GOTOSTART() /*---------------------------*/ local void             gotoStart(InputBuffer *const inputBuffer)
#define GOTOEND() /*-----------------------------*/ local void             gotoEnd(InputBuffer *const inputBuffer)
#define SELECTTEXT() /*--------------------------*/ local void             selectText(InputBuffer *const inputBuffer, const uint8 direction, const uint8 matchLength)
#define SELECTSTART() /*-------------------------*/ local void             selectStart(InputBuffer *const inputBuffer)
#define SELECTEND() /*---------------------------*/ local void             selectEnd(InputBuffer *const inputBuffer)
#define SELECTALL() /*---------------------------*/ local void             selectAll(InputBuffer *const inputBuffer)
#define TOCASE() /*------------------------------*/ local void             toCase(InputBuffer *const inputBuffer, const uint8 newCase)
#define COPYSELECTED() /*------------------------*/ local void             copySelected(InputBuffer *const inputBuffer)
#define REMOVESELECTED() /*----------------------*/ local void             removeSelected(InputBuffer *const inputBuffer)
#define PASTECLIPBOARD() /*----------------------*/ local void             pasteClipboard(InputBuffer *const inputBuffer)
#define REMOVETEXT() /*--------------------------*/ local void             removeText(InputBuffer *const inputBuffer, const uint8 direction, const uint8 matchLength)
#define GETRESULTS() /*--------------------------*/ local void             getResults(InputBuffer *const inputBuffer)
#define PICKRESULT() /*--------------------------*/ local void             pickResult(InputBuffer *const inputBuffer)
#define LAUNCH() /*------------------------------*/ local void             launch(InputBuffer *const inputBuffer)
#define SHIFTLEFTWARDS() /*----------------------*/ local void             shiftLeftwards(InputBuffer *const inputBuffer, const uint distance)
#define SHIFTRIGHTWARDS() /*---------------------*/ local void             shiftRightwards(InputBuffer *const inputBuffer, const uint distance)

def struct{
	uint8 * /*-*/ dataStart;
	uint8 * /*-*/ dataCurrent;
	uint32 /*--*/ dataToken;
	uint32 /*--*/ dataLength;
	uint32 /*--*/ dataSize;
	uint32 /*--*/ dataAllocated;
	uint8 * /*-*/ selectedDataCurrent;
	uint32 /*--*/ selectedDataLength;
	uint8 /*---*/ pad0[4];
} InputBuffer;

def struct{
	uint32 /*--*/ dataLength;
	uint32 /*--*/ dataSize;
	uint8 * /*-*/ dataStart;
	uint32 /*--*/ dataToken;
} ClipboardBuffer;

/*! needed */
	local xcb_window_t /*--------*/ window;
	local xcb_pixmap_t /*--------*/ pixmap;
	local xcb_gcontext_t /*------*/ gc;
	local bool /*----------------*/ mapped;

/*! input */
	local ASCIIStringNodeRoot /*-*/ asciiRoot;

	InputBuffer /*---------------*/ inputBuffer;
	ClipboardBuffer /*-----------*/ clipboardBuffer;

	local uint8 /*---------------*/ inputMode;
	local uint /*----------------*/ maximumResultAmount;
	local bool /*----------------*/ resultAllowCircularNavigation;

	local int /*-----------------*/ currentSelectedResult;

/*! config */
	local ElementPreferences /*--*/ windowPreferences;
	local ElementPreferences /*--*/ inputPreferences;
	local ElementPreferences /*--*/ inputContentPreferences;
	local ElementPreferences /*--*/ resultPreferences;
	local ElementPreferences /*--*/ resultContentPreferences;
	local xcb_pixmap_t /*--------*/ windowCirclePixmap;
	local uint8 /*---------------*/ whichMonitor;
	local xcb_font_t /*----------*/ font;

CONFIGUREWINDOW();
UPDATEWINDOW();
MAPWINDOW();
GETWHICHMONITOR();
GETFOCUSEDWINDOW();
SETWINDOWPROPERTIES();
DRAWWINDOW();
GETRECTANGLE();
GETTYPEDNUMBER();
DRAWSEGMENTEDUTF8();
SETCLIPPINGRECTANGLE();
UNSETCLIPPINGRECTANGLE();

SETINPUTBUFFER();
RESIZEINPUTBUFFER();
UNSETINPUTBUFFER();
SETCLIPBOARDBUFFER();
ALLOCATECLIPBOARDBUFFER();
UBSETCLIPBOARDBUFFER();

GETCHARACTERLENGTH();
GETWORDLENGTH();
SHIFTLEFTWARDS();
SHIFTRIGHTWARDS();
CHANGEMODE();
INSERTCHARACTER();
GOTOLEFT();
GOTORIGHT();
GOTOSTART();
GOTOEND();
SELECTTEXT();
SELECTSTART();
SELECTEND();
SELECTALL();
TOCASE();
COPYSELECTED();
REMOVESELECTED();
PASTECLIPBOARD();
REMOVETEXT();
GETRESULTS();
PICKRESULT();
LAUNCH();



























MAPWINDOW(){
	if(!mapped){
		const Monitor *const monitor = getWhichMonitor();
		const xcb_timestamp_t userTime = getTimestamp();
		ElementRectangle rectangle;
		struct{
			int32 /*--*/ x;
			int32 /*--*/ y;
			uint32 /*-*/ width;
			uint32 /*-*/ height;
			uint32 /*-*/ stackMode;
		} valueList;
		valueList.stackMode = XCB_STACK_MODE_ABOVE;
		if(getRectangle(monitor, NULL, NULL, &windowPreferences, &rectangle) and rectangle.width and rectangle.height){
			valueList.x = rectangle.x;
			valueList.y = rectangle.y;
			valueList.width = rectangle.width;
			valueList.height = rectangle.height;
			xcb_configure_window(connection, window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
			setWindowProperties(window, rectangle.monitor, valueList.x, valueList.y, valueList.width, valueList.height);
			xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_USER_TIME, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &userTime);
			drawWindow(window, rectangle.monitor, &rectangle);
			xcb_map_window(connection, window);
			mapped = true;
		}
	}
	ret;
}
CONFIGUREWINDOW(){
	if(mapped){
		const Monitor *const monitor = getWhichMonitor();
		ElementRectangle rectangle;
		if(getRectangle(monitor, NULL, NULL, &windowPreferences, &rectangle) and rectangle.width and rectangle.height){
			struct{
				int32 /*--*/ x;
				int32 /*--*/ y;
				uint32 /*-*/ width;
				uint32 /*-*/ height;
			} valueList;
			valueList.x = rectangle.x;
			valueList.y = rectangle.y;
			valueList.width = rectangle.width;
			valueList.height = rectangle.height;
			xcb_configure_window(connection, window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &valueList);
			setWindowProperties(window, rectangle.monitor, valueList.x, valueList.y, valueList.width, valueList.height);
			drawWindow(window, rectangle.monitor, &rectangle);
		}
	}
	ret;
}
GETWHICHMONITOR(){
	switch whichMonitor over
		to POINTER_WHICH_MONITOR:{
			ret getPointerMonitor();
		}
		to FOCUSED_WINDOW_WHICH_MONITOR:{
			const xcb_window_t window = getFocusedWindow();
			if(window and window != (*screen).root){
				ret getWindowMonitor(window);
			}
			ret getPointerMonitor();
		}
		off:{
			ret NULL;
		}
	end
}
GETFOCUSEDWINDOW(){
	xcb_get_property_cookie_t propertyCookie;
	xcb_get_input_focus_cookie_t inputFocusCookie;
	xcb_window_t window = XCB_NONE;
	jmp getCookies;
	getCookies:{
		propertyCookie = xcb_get_property_unchecked(connection, false, (*screen).root, atom._NET_ACTIVE_WINDOW, XCB_ATOM_WINDOW, 0, 1);
		inputFocusCookie = xcb_get_input_focus_unchecked(connection);
		jmp getActiveWindow;
	}
	getActiveWindow:{
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, propertyCookie, NULL);
		uint32 token = pushPointer(reply, "getFocusedWindow() get property reply", iFree);
		bool found = false;
		if(reply){
			if(xcb_get_property_value_length(reply) == sizeof(xcb_window_t)){
				window = *(xcb_window_t *)xcb_get_property_value(reply);
				found = true;
			}
			free(reply);
			popPointer(token);
			if(found){
				xcb_discard_reply(connection, inputFocusCookie);
				ret window;
			}
		}
		jmp getFocusedWindow;
	}
	getFocusedWindow:{
		xcb_get_input_focus_reply_t *const reply = xcb_wait_for_reply(connection, inputFocusCookie, NULL);
		uint32 token = pushPointer(reply, "getFocusedWindow() get input focus reply", iFree);
		if(reply){
			window = (*reply).focus;
			free(reply);
			popPointer(token);
		}
		ret window;
	}
}
SETWINDOWPROPERTIES(){
	const uint32 desktop = 0xFFFFFFFF;
	const pid_t pid = getpid();
	char hostname[256];
	xcb_atom_t type[1];
	xcb_atom_t state[2];
	struct{
		uint32 /*-*/ flags;
		int32 /*--*/ x;
		int32 /*--*/ y;
		int32 /*--*/ width;
		int32 /*--*/ height;
		int32 /*--*/ minWidth;
		int32 /*--*/ minHeight;
		int32 /*--*/ maxWidth;
		int32 /*--*/ maxHeight;
		int32 /*--*/ widthInc;
		int32 /*--*/ heightInc;
		int32 /*--*/ minAspectNumerator;
		int32 /*--*/ minAspectDenominarator;
		int32 /*--*/ maxAspectNumerator;
		int32 /*--*/ maxAspectDenominarator;
		int32 /*--*/ baseWidth;
		int32 /*--*/ baseHeight;
		int32 /*--*/ winGravity;
	} normalHints;
	struct{
		uint32 /*-*/ flags;
		uint32 /*-*/ input;
		uint32 /*-*/ initialState;
	} hints;
	(void)monitor;
	normalHints.flags = USER_POSITION_NORMAL_HINT | USER_SIZE_NORMAL_HINT | PROGRAM_MINIMUM_SIZE_NORMAL_HINT | PROGRAM_MAXIMUM_SIZE_NORMAL_HINT | PROGRAM_RESIZE_INCREMENT_NORMAL_HINT | PROGRAM_ASPECT_NORMAL_HINT | PROGRAM_BASE_SIZE_NORMAL_HINT | PROGRAM_WINDOW_GRAVITY_NORMAL_HINT;
	normalHints.x = x;
	normalHints.y = y;
	normalHints.width = width;
	normalHints.height = height;
	normalHints.minWidth = width;
	normalHints.minHeight = height;
	normalHints.maxWidth = width;
	normalHints.maxHeight = height;
	normalHints.baseWidth = width;
	normalHints.baseHeight = height;
	normalHints.widthInc = 0;
	normalHints.heightInc = 0;
	normalHints.minAspectNumerator = 1;
	normalHints.minAspectDenominarator = 1;
	normalHints.maxAspectNumerator = 1;
	normalHints.maxAspectDenominarator = 1;
	normalHints.winGravity = XCB_GRAVITY_NORTH_WEST;
	hints.flags = INPUT_HINT | STATE_HINT;
	hints.input = false;
	hints.initialState = NORMAL_STATE;
	*hostname = '\0';
	if(gethostname(hostname, countof(hostname)) != GETHOSTNAME_SUCCESS){
		printTitledError("get hostname error", "could not get hostname");
	}
	*(type + 0) = atom._NET_WM_WINDOW_TYPE_UTILITY;
	*(state + 0) = atom._NET_WM_STATE_STICKY;
	*(state + 1) = atom._NET_WM_STATE_ABOVE;
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_ICON_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NORMAL_HINTS, atom.WM_SIZE_HINTS, bitsof(uint32), sizeof(normalHints) / sizeof(uint32), &normalHints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_HINTS, atom.WM_HINTS, bitsof(uint32), sizeof(hints) / sizeof(uint32), &hints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLASS, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME "\0" PROGRAM_NAME "\0"), PROGRAM_NAME "\0" PROGRAM_NAME "\0");
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLIENT_MACHINE, XCB_ATOM_STRING, bitsof(uint8), findStringLength(hostname), hostname);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &desktop);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_WINDOW_TYPE, XCB_ATOM_ATOM, bitsof(uint32), countof(type), type);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STATE, XCB_ATOM_ATOM, bitsof(uint32), countof(state), state);
	/*! xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON, , , , ); */
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_PID, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &pid);
	ret;
}
UPDATEWINDOW(){
	if(mapped){
		const Monitor *const monitor = getWindowMonitor(window);
		drawWindow(window, monitor, NULL);
	}
	ret;
}
DRAWWINDOW(){
	ElementRectangle _windowRectangle;
	ElementRectangle inputRectangle;
	ElementRectangle resultRectangle;
	bool hasInputRectangle;
	bool hasResultRectangle;
	jmp getRectangles;
	getRectangles:{
		if(!windowRectangle){
			windowRectangle = &_windowRectangle;
			if(!getRectangle(monitor, NULL, NULL, &windowPreferences, windowRectangle) or !(*windowRectangle).width or !(*windowRectangle).height){
				ret;
			}
		}
		hasInputRectangle = getRectangle(NULL, NULL, windowRectangle, &inputPreferences, &inputRectangle);
		hasResultRectangle = getRectangle(NULL, NULL, windowRectangle, &resultPreferences, &resultRectangle);
		jmp drawWindow;
	}
	drawWindow:{
		fillDrawable(pixmap, gc, 0, 0, (*windowRectangle).width, (*windowRectangle).height, windowPreferences.background);
		if(windowCirclePixmap){
			const uint8 cornerUsed = windowPreferences.cornerUsed;
			const uint radius = windowPreferences.cornerRadius;
			const uint size = radius + 1;
			if(cornerUsed & TOP_LEFT_CORNER_USED) /*-----*/ xcb_copy_area(connection, windowCirclePixmap, pixmap, gc, 0     , 0     , 0                              , 0                               , size, size);
			if(cornerUsed & TOP_RIGHT_CORNER_USED) /*----*/ xcb_copy_area(connection, windowCirclePixmap, pixmap, gc, radius, 0     , (*windowRectangle).width - size, 0                               , size, size);
			if(cornerUsed & BOTTOM_LEFT_CORNER_USED) /*--*/ xcb_copy_area(connection, windowCirclePixmap, pixmap, gc, 0     , radius, 0                              , (*windowRectangle).height - size, size, size);
			if(cornerUsed & BOTTOM_RIGHT_CORNER_USED) /*-*/ xcb_copy_area(connection, windowCirclePixmap, pixmap, gc, radius, radius, (*windowRectangle).width - size, (*windowRectangle).height - size, size, size);
		}
		jmp drawInputElement;
	}
	drawInputElement:{
		if(hasInputRectangle and inputPreferences.width and inputPreferences.height){
			const int rX = inputRectangle.x;
			const int rY = inputRectangle.y;
			const uint rWidth = inputRectangle.width;
			const uint rHeight = inputRectangle.height;
			const uint pPadding = inputPreferences.padding;
			const uint pMargin = inputPreferences.margin;
			int x = rX + pMargin;
			int y = rY + pMargin;
			uint width = rWidth + 2 * pPadding;
			uint height = rHeight + 2 * pPadding;
			ElementRectangle inputContentRectangle;
			fillDrawable(pixmap, gc, x, y, width, height, inputPreferences.background);
			if(font){
				uint highlightedSize;
				uint8 *current = inputBuffer.dataStart;
				uint8 currentSize;
				if(inputBuffer.selectedDataCurrent){
					highlightedSize = inputBuffer.selectedDataLength;
					currentSize = inputBuffer.selectedDataCurrent - inputBuffer.dataStart;
					jmp drawInput;
				}
				if(inputMode == NORMAL_INPUT_MODE){
					highlightedSize = 0;
					currentSize = inputBuffer.dataCurrent - inputBuffer.dataStart;
					jmp drawInput;
				}
				if(inputMode == INSERT_INPUT_MODE){
					highlightedSize = 1;
					currentSize = inputBuffer.dataCurrent - inputBuffer.dataStart;
					jmp drawInput;
				}
				jmp stopDrawingInput;
				drawInput:{
					setClippingRectangle(gc, x, y, width, height);
					{
						uint16 ucs2Start[4096];
						uint length;
						if((length = UTF8ToUCS2(current, ucs2Start, countof(ucs2Start)))){
							if(!inputBuffer.selectedDataCurrent and inputMode == INSERT_INPUT_MODE and inputBuffer.dataCurrent == inputBuffer.dataStart + inputBuffer.dataLength){
								if(length < lengthof(ucs2Start)){
									*(ucs2Start + length) = ASCII_TO_UCS2(' ');
								}
							}
						}else{
							*ucs2Start = ASCII_TO_UCS2(' ');
							length = 1;
						}
						{
							xcb_query_text_extents_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_text_extents_unchecked(connection, font, length, (void *)ucs2Start), NULL);
							uint32 token = pushPointer(reply, "drawWindow() query text extents reply", iFree);
							if(reply){
								if(getRectangle(NULL, reply, &inputRectangle, &inputContentPreferences, &inputContentRectangle)){
									x += inputContentRectangle.x;
									y += inputContentRectangle.y;
								}
								free(reply);
								popPointer(token);
							}
						}
					}
					{
						uint8 copy = *(current + currentSize);
						int xCopy;
						*(current + currentSize) = '\0';
						drawSegmentedUTF8(current, &x, y, inputContentPreferences.foreground, inputContentPreferences.background);
						*(current + currentSize) = copy;
						current += currentSize;
						currentSize = highlightedSize;
						xCopy = x;
						copy = *(current + currentSize);
						*(current + currentSize) = '\0';
						drawSegmentedUTF8(current, &x, y, inputContentPreferences.selectedForeground, inputContentPreferences.selectedBackground);
						*(current + currentSize) = copy;
						if(current + currentSize < inputBuffer.dataStart + inputBuffer.dataLength){
							drawSegmentedUTF8(current + currentSize, &x, y, inputContentPreferences.foreground, inputContentPreferences.background);
						}
						if(!inputBuffer.selectedDataCurrent){
							if(inputMode == NORMAL_INPUT_MODE){
								if(inputBuffer.dataCurrent <= inputBuffer.dataStart + inputBuffer.dataLength){
									uint16 ucs2Start[4096];
									uint length;
									if((length = UTF8ToUCS2((void *)"a", ucs2Start, countof(ucs2Start)))){
										xcb_query_text_extents_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_text_extents_unchecked(connection, font, length, (void *)ucs2Start), NULL);
										uint32 token = pushPointer(reply, "drawWindow() query text extents reply", iFree);
										if(reply){
											const uint fontHeight = (*reply).font_ascent + (*reply).font_descent;
											fillDrawable(pixmap, gc, xCopy, y, 1, fontHeight, inputContentPreferences.foreground);
											free(reply);
											popPointer(token);
										}
									}
								}
							}elif(inputMode == INSERT_INPUT_MODE){
								if(inputBuffer.dataCurrent == inputBuffer.dataStart + inputBuffer.dataLength){
									drawSegmentedUTF8((void *)" ", &x, y, inputContentPreferences.selectedForeground, inputContentPreferences.selectedBackground);
								}
							}
						}
					}
					unsetClippingRectangle(gc);
					jmp stopDrawingInput;
				}
				stopDrawingInput:{}
			}
		}
		jmp drawResult;
	}
	drawResult:{
		if(asciiRoot.stringsFoundStart and hasResultRectangle and resultRectangle.width and resultRectangle.height){
			const int rX = resultRectangle.x;
			const int rY = resultRectangle.y;
			const uint rWidth = resultRectangle.width;
			const uint rHeight = resultRectangle.height;
			const uint pPadding = resultPreferences.padding;
			const uint pMargin = resultPreferences.margin;
			const uint pGap = resultPreferences.gap;
			const int stringAmount = asciiRoot.stringsFoundAmount;
			const uint8 *current = asciiRoot.stringsFoundStart;
			int i = 0;
			int x = rX + pMargin;
			int y = rY + pMargin;
			uint width = rWidth + 2 * pPadding;
			uint height = rHeight + 2 * pPadding;
			int offset = height + pMargin + pGap;
			ElementRectangle resultContentRectangle;
			jmp drawResultLoop;
			drawResultLoop:{
				if(i < stringAmount){
					{
						uint32 background = resultPreferences.background;
						if(i == currentSelectedResult){
							background = resultPreferences.selectedBackground;
						}
						fillDrawable(pixmap, gc, x, y, width, height, background);
					}
					if(font){
						uint16 ucs2Start[4096];
						uint length;
						if((length = UTF8ToUCS2(current + 1, ucs2Start, countof(ucs2Start)))){
							xcb_query_text_extents_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_text_extents_unchecked(connection, font, length, (void *)ucs2Start), NULL);
							uint32 token = pushPointer(reply, "drawWindow() query text extents reply", iFree);
							if(reply){
								if(getRectangle(NULL, reply, &resultRectangle, &resultContentPreferences, &resultContentRectangle)){
									uint32 foreground = resultContentPreferences.foreground;
									uint32 background = resultContentPreferences.background;
									uint32 valueList[2];
									if(i == currentSelectedResult){
										foreground = resultContentPreferences.selectedForeground;
										background = resultContentPreferences.selectedBackground;
									}
									*(valueList + 0) = foreground;
									*(valueList + 1) = background;
									setClippingRectangle(gc, x, y, width, height);
									xcb_change_gc(connection, gc, XCB_GC_FOREGROUND | XCB_GC_BACKGROUND, valueList);
									xcb_image_text_16(connection, length, pixmap, gc, (*reply).overall_left + x + resultContentRectangle.x, (*reply).font_ascent + y + resultContentRectangle.y, (void *)ucs2Start);
									unsetClippingRectangle(gc);
								}
								free(reply);
								popPointer(token);
							}
						}
					}
					y += offset;
					current += *current + 2;
					inc i;
					jmp drawResultLoop;
				}
			}
		}
		jmp clearArea;
	}
	clearArea:{
		if(mapped){
			xcb_clear_area(connection, false, window, 0, 0, 0, 0);
		}
		ret;
	}
}
DRAWSEGMENTEDUTF8(){
	uint16 ucs2Start[4096];
	uint length;
	if((length = UTF8ToUCS2(current, ucs2Start, countof(ucs2Start)))){
		xcb_query_text_extents_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_text_extents_unchecked(connection, font, length, (void *)ucs2Start), NULL);
		uint32 token = pushPointer(reply, "drawSegmentedUTF8() query text extents reply", iFree);
		if(reply){
			const int fontX = (*reply).overall_left + *x;
			const int fontY = (*reply).font_ascent + y;
			const uint fontWidth = (*reply).overall_width;
			const uint fontHeight = (*reply).font_ascent + (*reply).font_descent;
			uint32 valueList[2];
			(void)fontHeight;
			*(valueList + 0) = foreground;
			*(valueList + 1) = background;
			xcb_change_gc(connection, gc, XCB_GC_FOREGROUND | XCB_GC_BACKGROUND, valueList);
			xcb_image_text_16(connection, length, pixmap, gc, fontX, fontY, (void *)ucs2Start);
			free(reply);
			popPointer(token);
			*x += fontWidth;
		}
	}
	ret;
}
SETCLIPPINGRECTANGLE(){
	xcb_rectangle_t rectangle;
	rectangle.x = x;
	rectangle.y = y;
	rectangle.width = width;
	rectangle.height = height;
	xcb_set_clip_rectangles(connection, XCB_CLIP_ORDERING_UNSORTED, gc, 0, 0, 1, &rectangle);
	ret;
}
UNSETCLIPPINGRECTANGLE(){
	struct{
		xcb_pixmap_t /*-*/ clipMask;
	} valueList;
	valueList.clipMask = XCB_NONE;
	xcb_change_gc(connection, gc, XCB_GC_CLIP_MASK, &valueList);
	ret;
}
GETRECTANGLE(){
	const Monitor *monitor;
	int x;
	int y;
	int xOffset;
	int yOffset;
	uint width;
	uint height;
	int parentX;
	int parentY;
	uint parentWidth;
	uint parentHeight;
	if(_monitor){
		monitor = _monitor;
		parentX = (*monitor).leftX;
		parentY = (*monitor).topY;
		parentWidth = (*monitor).width;
		parentHeight = (*monitor).height;
	}elif(parentRectangle){
		monitor = (*parentRectangle).monitor;
		parentX = 0;
		parentY = 0;
		parentWidth = (*parentRectangle).width;
		parentHeight = (*parentRectangle).height;
		if(!monitor){
			ret false;
		}
	}else{
		ret false;
	}
	x = getTypedNumber((*preferences).x, (*preferences).xType, HORIZONTAL_AXIS, parentWidth, monitor);
	y = getTypedNumber((*preferences).y, (*preferences).yType, VERTICAL_AXIS, parentHeight, monitor);
	xOffset = getTypedNumber((*preferences).xOffset, (*preferences).xOffsetType, HORIZONTAL_AXIS, parentWidth, monitor);
	yOffset = getTypedNumber((*preferences).yOffset, (*preferences).yOffsetType, VERTICAL_AXIS, parentHeight, monitor);
	if(reply){
		width = (*reply).overall_width;
		height = (*reply).font_ascent + (*reply).font_descent;
	}else{
		width = getTypedNumber((*preferences).width, (*preferences).widthType, HORIZONTAL_AXIS, parentWidth, monitor);
		height = getTypedNumber((*preferences).height, (*preferences).heightType, VERTICAL_AXIS, parentHeight, monitor);
	}
	if((*preferences).horizontalAlignment){
		x = parentX + ((*preferences).horizontalAlignment - 1) * (parentWidth - width) / 2;
	}
	if((*preferences).verticalAlignment){
		y = parentY + ((*preferences).verticalAlignment - 1) * (parentHeight - height) / 2;
	}
	(*rectangle).monitor = monitor;
	(*rectangle).x = x + xOffset;
	(*rectangle).y = y + yOffset;
	(*rectangle).width = width;
	(*rectangle).height = height;
	ret true;
}
GETTYPEDNUMBER(){
	switch type over
		to INTEGER_NUMBER_TYPE: /*----*/ ret number;
		to PERCENTAGE_NUMBER_TYPE: /*-*/ ret size * number / 100;
		to MILLIMETER_NUMBER_TYPE: /*-*/ jmp matchMillimeterType;
		off: /*-----------------------*/ ret 0;
	end
	matchMillimeterType: switch axis over
		to HORIZONTAL_AXIS: /*--------*/ ret (*monitor).width * number / (*monitor).millimeterWidth;
		to VERTICAL_AXIS: /*----------*/ ret (*monitor).height * number / (*monitor).millimeterHeight;
		off: /*-----------------------*/ ret 0;
	end
}









SETINPUTBUFFER(){
	#define INPUT_BUFFER_BLOCK_SIZE /*-*/ (512)
	(*inputBuffer).dataLength = 0;
	(*inputBuffer).dataSize = INPUT_BUFFER_BLOCK_SIZE;
	(*inputBuffer).dataAllocated = 0;
	(*inputBuffer).dataStart = malloc((*inputBuffer).dataSize * sizeof(uint8));
	(*inputBuffer).dataCurrent = (*inputBuffer).dataStart;
	(*inputBuffer).dataToken = pushPointer((*inputBuffer).dataStart, "input buffer pointer", iFree);
	(*inputBuffer).selectedDataCurrent = NULL;
	if(!(*inputBuffer).dataStart){
		printTitledError("memory allocation error", "could not allocate memory for input buffer");
		ret;
	}
	*(*inputBuffer).dataStart = '\0';
	ret;
}
RESIZEINPUTBUFFER(){
	if((*inputBuffer).dataAllocated + count >= (*inputBuffer).dataSize){
		const uint offset = (*inputBuffer).dataCurrent - (*inputBuffer).dataStart;
		void *temp;
		(*inputBuffer).dataSize += INPUT_BUFFER_BLOCK_SIZE;
		temp = realloc((*inputBuffer).dataStart, (*inputBuffer).dataSize * sizeof(uint8));
		updatePointer((*inputBuffer).dataToken, temp);
		if(!temp){
			printTitledError("memory allocation error", "could not reallocate memory for input buffer");
			(*inputBuffer).dataSize -= INPUT_BUFFER_BLOCK_SIZE;
			ret false;
		}
		(*inputBuffer).dataStart = temp;
		(*inputBuffer).dataCurrent = (*inputBuffer).dataStart + offset;
	}
	ret true;
}
UNSETINPUTBUFFER(){
	free((*inputBuffer).dataStart);
	popPointer((*inputBuffer).dataToken);
	ret;
	#undef  INPUT_BUFFER_BLOCK_SIZE
}
SETCLIPBOARDBUFFER(){
	(*clipboardBuffer).dataLength = 0;
	(*clipboardBuffer).dataSize = 0;
	(*clipboardBuffer).dataStart = NULL;
	(*clipboardBuffer).dataToken = 0;
	ret;
}
ALLOCATECLIPBOARDBUFFER(){
	if((*clipboardBuffer).dataStart){
		free((*clipboardBuffer).dataStart);
		popPointer((*clipboardBuffer).dataToken);
	}
	(*clipboardBuffer).dataLength = length;
	(*clipboardBuffer).dataStart = malloc((*clipboardBuffer).dataLength * sizeof(uint8));
	(*clipboardBuffer).dataToken = pushPointer((*clipboardBuffer).dataStart, "clipboard buffer pointer", iFree);
	if(!(*clipboardBuffer).dataStart){
		printTitledError("memory allocation error", "could not allocate memory for clipboard buffer");
		ret false;
	}
	ret true;
}
UBSETCLIPBOARDBUFFER(){
	free((*clipboardBuffer).dataStart);
	popPointer((*clipboardBuffer).dataToken);
	ret;
}



























INSERTCHARACTER(){
	XEvent xlibEvent;
	bool usingXlib;
	uint8 buffer[4];
	uint count;
	bool flag;
	jmp matchInvisibleCharacter;
	matchInvisibleCharacter: switch (*e).detail over
		to 9: /*---*/ ret;
		to 22: /*--*/ ret;
		to 36: /*--*/ ret;
		to 91: /*--*/ ret;
		to 104: /*-*/ ret;
		to 119: /*-*/ ret;
		off: /*----*/ jmp matchCharacter;
	end
	matchCharacter:{
		xlibEvent.xkey.type = (*e).response_type & ~b(10000000);
		xlibEvent.xkey.send_event = false;
		xlibEvent.xkey.display = display;
		xlibEvent.xkey.window = (*e).event;
		xlibEvent.xkey.root = (*e).root;
		xlibEvent.xkey.subwindow = (*e).child;
		xlibEvent.xkey.time = (*e).time;
		xlibEvent.xkey.x = (*e).event_x;
		xlibEvent.xkey.y = (*e).event_y;
		xlibEvent.xkey.x_root = (*e).root_x;
		xlibEvent.xkey.y_root = (*e).root_y;
		xlibEvent.xkey.state = (*e).state;
		xlibEvent.xkey.keycode = (*e).detail;
		xlibEvent.xkey.same_screen = (*e).same_screen;
		if(!XFilterEvent(&xlibEvent, (*screen).root)){
			usingXlib = false;
			jmp lookupCharacter;
		}
		XSetEventQueueOwner(display, XlibOwnsEventQueue);
		jmp xlibEventLoop;
	}
	xlibEventLoop:{
		if(XPending(display)){
			XNextEvent(display, &xlibEvent);
			jmp switchXlibEvent;
		}
		xlibEvent.type = NoEventMask;
		jmp switchXlibEvent;
	}
	switchXlibEvent: switch xlibEvent.type over
		to KeyPress:{
			if(!XFilterEvent(&xlibEvent, (*screen).root)){
				usingXlib = true;
				jmp lookupCharacter;
			}
			jmp xlibEventLoop;
		}
		off:{
			XSetEventQueueOwner(display, XCBOwnsEventQueue);
			ret;
		}
	end
	lookupCharacter:{
		if(!(count = Xutf8LookupString(ic, &xlibEvent.xkey, (void *)buffer, sizeof(buffer), NULL, NULL))){
			ret;
		}
		if(!resizeInputBuffer(inputBuffer, count)){
			ret;
		}
		switch inputMode over
			to NORMAL_INPUT_MODE: /*-*/ jmp normalMode;
			to INSERT_INPUT_MODE: /*-*/ jmp insertMode;
			off: /*------------------*/ ret;
		end
	}
	normalMode:{
		if((*inputBuffer).selectedDataCurrent){
			removeSelected(inputBuffer);
		}
		if((*inputBuffer).dataCurrent == (*inputBuffer).dataStart + (*inputBuffer).dataLength){
			flag = true;
			jmp addCharacter;
		}
		shiftRightwards(inputBuffer, count);
		flag = false;
		jmp addCharacter;
	}
	insertMode:{
		uint length;
		if((*inputBuffer).selectedDataCurrent){
			jmp normalMode;
		}
		if((*inputBuffer).dataCurrent == (*inputBuffer).dataStart + (*inputBuffer).dataLength){
			flag = true;
			jmp addCharacter;
		}
		length = getCharacterLength(RIGHT_DIRECTION, (*inputBuffer).dataCurrent);
		if(count < length){
			shiftLeftwards(inputBuffer, length - count);
		}elif(count > length){
			shiftRightwards(inputBuffer, count - length);
		}
		(*inputBuffer).dataLength -= length;
		flag = false;
		jmp addCharacter;
	}
	addCharacter:{
		switch count over
			fallthrough4: to 4: *((*inputBuffer).dataCurrent + 3) = *(buffer + 3); jmp fallthrough3;
			fallthrough3: to 3: *((*inputBuffer).dataCurrent + 2) = *(buffer + 2); jmp fallthrough2;
			fallthrough2: to 2: *((*inputBuffer).dataCurrent + 1) = *(buffer + 1); jmp fallthrough1;
			fallthrough1: to 1: *((*inputBuffer).dataCurrent + 0) = *(buffer + 0); brk; jmp fallthrough4;
		end
		(*inputBuffer).dataCurrent += count;
		(*inputBuffer).dataLength += count;
		if(flag){
			*(*inputBuffer).dataCurrent = '\0';
		}
		currentSelectedResult = -1;
		getResults(inputBuffer);
		updateWindow();
		if(usingXlib){
			jmp xlibEventLoop;
		}
		ret;
	}
}
SHIFTLEFTWARDS(){
	uint8 *current = (*inputBuffer).dataCurrent + distance;
	jmp loop;
	loop:{
		*(current - distance) = *current;
		if(*current){
			inc current;
			jmp loop;
		}
		ret;
	}
}
SHIFTRIGHTWARDS(){
	uint8 *current = (*inputBuffer).dataStart + (*inputBuffer).dataLength;
	uint8 *const start = (*inputBuffer).dataCurrent;
	jmp loop;
	loop:{
		if(current >= start){
			*(current + distance) = *current;
			dec current;
			jmp loop;
		}
		ret;
	}
}
CHANGEMODE(){
	switch inputMode over
		to NORMAL_INPUT_MODE: /*-*/ inputMode = INSERT_INPUT_MODE; /*-*/ ret;
		to INSERT_INPUT_MODE: /*-*/ inputMode = NORMAL_INPUT_MODE; /*-*/ ret;
		off: /*------------------*/ /*--------------------------------*/ ret;
	end
}
GOTOSTART(){
	(*inputBuffer).dataCurrent = (*inputBuffer).dataStart;
	(*inputBuffer).selectedDataCurrent = NULL;
	ret;
}
GOTOEND(){
	(*inputBuffer).dataCurrent = (*inputBuffer).dataStart + (*inputBuffer).dataLength;
	(*inputBuffer).selectedDataCurrent = NULL;
	ret;
}
GOTOLEFT(){
	if((*inputBuffer).selectedDataCurrent){
		(*inputBuffer).dataCurrent = (*inputBuffer).selectedDataCurrent;
		(*inputBuffer).selectedDataCurrent = NULL;
		ret;
	}
	(*inputBuffer).selectedDataCurrent = NULL;
	if((*inputBuffer).dataCurrent == (*inputBuffer).dataStart){
		ret;
	}
	switch matchLength over
		to CHARACTER_MATCH_LENGTH: /*-*/ (*inputBuffer).dataCurrent -= getCharacterLength(LEFT_DIRECTION, (*inputBuffer).dataCurrent - 1); /*---------*/ ret;
		to WORD_MATCH_LENGTH: /*------*/ (*inputBuffer).dataCurrent -= getWordLength(inputBuffer, LEFT_DIRECTION, (*inputBuffer).dataCurrent - 1); /*-*/ ret;
		off: /*-----------------------*/ /*-----------------------------------------------------------------------------------------------------------*/ ret;
	end
}
GOTORIGHT(){
	if((*inputBuffer).selectedDataCurrent){
		(*inputBuffer).dataCurrent = (*inputBuffer).selectedDataCurrent + (*inputBuffer).selectedDataLength;
		(*inputBuffer).selectedDataCurrent = NULL;
		ret;
	}
	(*inputBuffer).selectedDataCurrent = NULL;
	if((*inputBuffer).dataCurrent == (*inputBuffer).dataStart + (*inputBuffer).dataLength){
		ret;
	}
	switch matchLength over
		to CHARACTER_MATCH_LENGTH: /*-*/ (*inputBuffer).dataCurrent += getCharacterLength(RIGHT_DIRECTION, (*inputBuffer).dataCurrent); /*---------*/ ret;
		to WORD_MATCH_LENGTH: /*------*/ (*inputBuffer).dataCurrent += getWordLength(inputBuffer, RIGHT_DIRECTION, (*inputBuffer).dataCurrent); /*-*/ ret;
		off: /*-----------------------*/ /*--------------------------------------------------------------------------------------------------------*/ ret;
	end
}
GETCHARACTERLENGTH(){
	if(*p < b(10000000)){
		ret 1 * sizeof(uint8);
	}
	if(direction == LEFT_DIRECTION){
		if((*(p - 1) & b(11100000)) == b(11000000) and (*(p - 0) & b(11000000)) == b(10000000)){
			ret 2 * sizeof(uint8);
		}
		if((*(p - 2) & b(11110000)) == b(11100000) and (*(p - 1) & b(11000000)) == b(10000000) and (*(p - 0) & b(11000000)) == b(10000000)){
			ret 3 * sizeof(uint8);
		}
		if((*(p - 3) & b(11111000)) == b(11110000) and (*(p - 2) & b(11000000)) == b(10000000) and (*(p - 1) & b(11000000)) == b(10000000) and (*(p - 0) & b(11000000)) == b(10000000)){
			ret 4 * sizeof(uint8);
		}
	}else{
		if((*(p + 0) & b(11100000)) == b(11000000) and (*(p + 1) & b(11000000)) == b(10000000)){
			ret 2 * sizeof(uint8);
		}
		if((*(p + 0) & b(11110000)) == b(11100000) and (*(p + 1) & b(11000000)) == b(10000000) and (*(p + 2) & b(11000000)) == b(10000000)){
			ret 3 * sizeof(uint8);
		}
		if((*(p + 0) & b(11111000)) == b(11110000) and (*(p + 1) & b(11000000)) == b(10000000) and (*(p + 2) & b(11000000)) == b(10000000) and (*(p + 3) & b(11000000)) == b(10000000)){
			ret 4 * sizeof(uint8);
		}
	}
	ret 0 * sizeof(uint8);
}
GETWORDLENGTH(){
	const uint8 *current;
	bool isSpecial;
	bool isWhitespace;
	bool isInvisible;
	int nextOffset;
	uint8 *wall;
	if(!(*inputBuffer).dataStart){
		ret 0;
	}
	jmp getCharacterTypes;
	getCharacterTypes:{
		const uint8 c = *p;
		current = p;
		isSpecial = (c >= 33 and c <= 47) or (c >= 58 and c <= 64) or (c >= 91 and c <= 94) or c == 96 or (c >= 123 and c <= 126);
		isWhitespace = (c >= 9 and c <= 13) or c == 32;
		isInvisible = (c >= 1 and c <= 8) or (c >= 14 and c <= 31) or c == 127;
		if(direction == LEFT_DIRECTION){
			nextOffset = -1;
		}else{
			nextOffset = 1;
			wall = (*inputBuffer).dataStart + (*inputBuffer).dataLength;
		}
		jmp matchCharacterToTypeLoop;
	}
	matchCharacterToTypeLoop:{
		bool condition;
		if(direction == LEFT_DIRECTION){
			condition = current >= (*inputBuffer).dataStart;
		}else{
			condition = current < wall;
		}
		if(condition){
			const uint8 c = *current;
			if(isSpecial){
				if((c >= 33 and c <= 47) or (c >= 58 and c <= 64) or (c >= 91 and c <= 94) or c == 96 or (c >= 123 and c <= 126)){
					current += nextOffset;
					jmp matchCharacterToTypeLoop;
				}
			}elif(isWhitespace){
				if((c >= 9 and c <= 13) or c == 32){
					current += nextOffset;
					jmp matchCharacterToTypeLoop;
				}
			}elif(isInvisible){
				if((c >= 1 and c <= 8) or (c >= 14 and c <= 31) or c == 127){
					current += nextOffset;
					jmp matchCharacterToTypeLoop;
				}
			}else{
				if((c >= 48 and c <= 57) or (c >= 65 and c <= 90) or c == 95 or (c >= 97 and c <= 122) or c >= 128){
					current += nextOffset;
					jmp matchCharacterToTypeLoop;
				}
			}
		}
		if(direction == LEFT_DIRECTION){
			ret p - current;
		}
		ret current - p;
	}
}



























/*!*/



























SELECTTEXT(){
	uint length;
	if(direction == LEFT_DIRECTION){
		switch matchLength over
			to CHARACTER_MATCH_LENGTH: /*-*/ length = getCharacterLength(direction, (*inputBuffer).dataCurrent - 1); /*---------*/ brk;
			to WORD_MATCH_LENGTH: /*------*/ length = getWordLength(inputBuffer, direction, (*inputBuffer).dataCurrent - 1); /*-*/ brk;
			off: /*-----------------------*/ /*---------------------------------------------------------------------------------*/ ret;
		end
		if(!(*inputBuffer).selectedDataCurrent){
			if((*inputBuffer).dataCurrent > (*inputBuffer).dataStart){
				(*inputBuffer).dataCurrent -= length;
				(*inputBuffer).selectedDataCurrent = (*inputBuffer).dataCurrent;
				(*inputBuffer).selectedDataLength = length;
			}
			ret;
		}
		if((*inputBuffer).dataCurrent == (*inputBuffer).selectedDataCurrent){
			if((*inputBuffer).dataCurrent > (*inputBuffer).dataStart){
				(*inputBuffer).dataCurrent -= length;
				(*inputBuffer).selectedDataCurrent -= length;
				(*inputBuffer).selectedDataLength += length;
			}
			ret;
		}
		(*inputBuffer).dataCurrent -= length;
	}else{
		switch matchLength over
			to CHARACTER_MATCH_LENGTH: /*-*/ length = getCharacterLength(direction, (*inputBuffer).dataCurrent); /*---------*/ brk;
			to WORD_MATCH_LENGTH: /*------*/ length = getWordLength(inputBuffer, direction, (*inputBuffer).dataCurrent); /*-*/ brk;
			off: /*-----------------------*/ /*-----------------------------------------------------------------------------*/ ret;
		end
		if(!(*inputBuffer).selectedDataCurrent){
			if((*inputBuffer).dataCurrent < (*inputBuffer).dataStart + (*inputBuffer).dataLength){
				(*inputBuffer).selectedDataCurrent = (*inputBuffer).dataCurrent;
				(*inputBuffer).selectedDataLength = length;
				(*inputBuffer).dataCurrent += length;
			}
			ret;
		}
		if((*inputBuffer).dataCurrent > (*inputBuffer).selectedDataCurrent){
			if((*inputBuffer).dataCurrent < (*inputBuffer).dataStart + (*inputBuffer).dataLength){
				(*inputBuffer).selectedDataLength += length;
				(*inputBuffer).dataCurrent += length;
			}
			ret;
		}
		(*inputBuffer).dataCurrent += length;
		(*inputBuffer).selectedDataCurrent += length;
	}
	(*inputBuffer).selectedDataLength -= length;
	if(!(*inputBuffer).selectedDataLength){
		(*inputBuffer).selectedDataCurrent = NULL;
	}
	ret;
}
SELECTSTART(){
	if((*inputBuffer).dataLength){
		(*inputBuffer).selectedDataCurrent = (*inputBuffer).dataStart;
		(*inputBuffer).selectedDataLength = (*inputBuffer).dataCurrent - (*inputBuffer).dataStart;
		(*inputBuffer).dataCurrent = (*inputBuffer).dataStart;
	}
	ret;
}
SELECTEND(){
	if((*inputBuffer).dataLength){
		(*inputBuffer).selectedDataCurrent = (*inputBuffer).dataCurrent;
		(*inputBuffer).selectedDataLength = (*inputBuffer).dataLength - ((*inputBuffer).dataCurrent - (*inputBuffer).dataStart);
		(*inputBuffer).dataCurrent = (*inputBuffer).dataStart + (*inputBuffer).dataLength;
	}
	ret;
}
SELECTALL(){
	if((*inputBuffer).dataLength){
		(*inputBuffer).selectedDataCurrent = (*inputBuffer).dataStart;
		(*inputBuffer).selectedDataLength = (*inputBuffer).dataLength;
		(*inputBuffer).dataCurrent = (*inputBuffer).dataStart + (*inputBuffer).dataLength;
	}
	ret;
}
TOCASE(){
	uint8 *current;
	uint8 *wall;
	int offset;
	if(!(*inputBuffer).selectedDataCurrent){
		ret;
	}
	current = (*inputBuffer).selectedDataCurrent;
	wall = current + (*inputBuffer).selectedDataLength;
	if(newCase == UPPER_CASE){
		offset = -32;
	}else{
		offset = 32;
	}
	jmp toCaseLetterLoop;
	toCaseLetterLoop:{
		if(current < wall){
			if(*current < b(10000000)){
				if(newCase == UPPER_CASE){
					*current += (*current >= 'a' and *current <= 'z') * offset;
				}else{
					*current += (*current >= 'A' and *current <= 'Z') * offset;
				}
			}
			inc current;
			jmp toCaseLetterLoop;
		}
		ret;
	}
}
COPYSELECTED(){
	const uint8 *current = (*inputBuffer).selectedDataCurrent;
	const uint8 *const wall = current + (*inputBuffer).selectedDataLength;
	uint8 *bufferCurrent;
	if(!allocateClipboardBuffer(&clipboardBuffer, (*inputBuffer).selectedDataLength)){
		ret;
	}
	bufferCurrent = clipboardBuffer.dataStart;
	jmp copySelectedLoop;
	copySelectedLoop:{
		*bufferCurrent = *current;
		if(inc current < wall){
			inc bufferCurrent;
			jmp copySelectedLoop;
		}
		ret;
	}
}
REMOVESELECTED(){
	(*inputBuffer).dataCurrent = (*inputBuffer).selectedDataCurrent;
	shiftLeftwards(inputBuffer, (*inputBuffer).selectedDataLength);
	(*inputBuffer).dataLength -= (*inputBuffer).selectedDataLength;
	(*inputBuffer).selectedDataCurrent = NULL;
	currentSelectedResult = -1;
	ret;
}
PASTECLIPBOARD(){



	/*! update input buffer */



	uint8 *current;
	uint8 *wall;
	if(!clipboardBuffer.dataLength){
		ret;
	}
	if((*inputBuffer).selectedDataCurrent){
		removeSelected(inputBuffer);
	}
	shiftRightwards(inputBuffer, clipboardBuffer.dataLength);
	current = clipboardBuffer.dataStart;
	wall = current + clipboardBuffer.dataLength;
	(*inputBuffer).dataLength += clipboardBuffer.dataLength;
	jmp pasteClipboardLoop;
	pasteClipboardLoop:{
		*(*inputBuffer).dataCurrent = *current;
		inc (*inputBuffer).dataCurrent;
		if(inc current < wall){
			jmp pasteClipboardLoop;
		}
		ret;
	}
}
REMOVETEXT(){
	uint length;
	uint8 *wall;
	int lengthOffset;
	if((*inputBuffer).selectedDataCurrent){
		removeSelected(inputBuffer);
		ret;
	}
	if(direction == LEFT_DIRECTION){
		wall = (*inputBuffer).dataStart;
		lengthOffset = -1;
	}else{
		wall = (*inputBuffer).dataStart + (*inputBuffer).dataLength;
		lengthOffset = 0;
	}
	if((*inputBuffer).dataCurrent == wall){
		ret;
	}
	switch matchLength over
		to CHARACTER_MATCH_LENGTH: /*-*/ length = getCharacterLength(direction, (*inputBuffer).dataCurrent + lengthOffset); /*---------*/ brk;
		to WORD_MATCH_LENGTH: /*------*/ length = getWordLength(inputBuffer, direction, (*inputBuffer).dataCurrent + lengthOffset); /*-*/ brk;
		off: /*-----------------------*/ /*--------------------------------------------------------------------------------------------*/ ret;
	end
	if(direction == LEFT_DIRECTION){
		(*inputBuffer).dataCurrent -= length;
	}
	shiftLeftwards(inputBuffer, length);
	(*inputBuffer).dataLength -= length;
	currentSelectedResult = -1;
	ret;
}
GETRESULTS(){
	/*! {
		const uint amountPost = (*inputBuffer).dataLength - ((*inputBuffer).dataCurrent - (*inputBuffer).dataStart);
		const uint amountPre = (*inputBuffer).dataLength - amountPost;
		const char *const dotsPre = (*inputBuffer).selectedDataCurrent and (*inputBuffer).selectedDataCurrent >= (*inputBuffer).dataStart + 3? "..." : (*inputBuffer).selectedDataCurrent and (*inputBuffer).selectedDataCurrent >= (*inputBuffer).dataStart + 2? ".." : (*inputBuffer).selectedDataCurrent and (*inputBuffer).selectedDataCurrent >= (*inputBuffer).dataStart + 1? "." : "";
		const uint (*inputBuffer).selectedDataLength = (*inputBuffer).selectedDataCurrent? (*inputBuffer).selectedDataLength : lengthof("<NONE>");
		const char *const selected = (*inputBuffer).selectedDataCurrent? (char *)(*inputBuffer).selectedDataCurrent : "<NONE>";
		const char *const dotsPost = (*inputBuffer).selectedDataCurrent and (*inputBuffer).selectedDataCurrent + (*inputBuffer).selectedDataLength < (*inputBuffer).dataStart + (*inputBuffer).dataLength - 2? "..." : (*inputBuffer).selectedDataCurrent and (*inputBuffer).selectedDataCurrent + (*inputBuffer).selectedDataLength < (*inputBuffer).dataStart + (*inputBuffer).dataLength - 1? ".." : (*inputBuffer).selectedDataCurrent and (*inputBuffer).selectedDataCurrent + (*inputBuffer).selectedDataLength < (*inputBuffer).dataStart + (*inputBuffer).dataLength - 0? "." : "";
		const char *const buffer = clipboardBuffer.dataLength? (char *)clipboardBuffer.dataStart : "";
		const uint bufferLength = clipboardBuffer.dataLength? clipboardBuffer.dataLength : lengthof("");
		const char *const isASCII = isASCIIString((*inputBuffer).dataStart)? "" : " (non-ascii)";
		const char *const mode = inputMode == NORMAL_INPUT_MODE? "" : " (insert)";
		fprintf(stdout, "[%.*s|%.*s] (selected: %s%.*s%s) (buffer: \'%.*s\')%s%s\n", amountPre, (*inputBuffer).dataStart, amountPost, (*inputBuffer).dataCurrent, dotsPre, (*inputBuffer).selectedDataLength, selected, dotsPost, bufferLength, buffer, isASCII, mode);
	} */
	getMultipleASCIIStringNodes(&asciiRoot, maximumResultAmount, (void *)(*inputBuffer).dataStart);
	ret;
}
PICKRESULT(){
	(void)inputBuffer;



	/*!*/



	ret;
}
LAUNCH(){
	#define ROOT_UID /*-*/ (0)
	uint8 *commandStart;
	uint32 commandToken;
	if(!(*inputBuffer).dataLength){
		ret;
	}
	if(geteuid() != ROOT_UID){
		exec((*inputBuffer).dataStart);
		ret;
	}
	commandStart = malloc((lengthof("su $(logname) -c \'") + (*inputBuffer).dataLength + lengthof("\'") + 1) * sizeof(uint8));
	commandToken = pushPointer(commandStart, "command to execute pointer", iFree);
	if(commandStart){
		uint8 *current = commandStart;
		copyMemory("su $(logname) -c \'", current, lengthof("su $(logname) -c \'"));
		current += lengthof("su $(logname) -c \'");
		copyMemory((*inputBuffer).dataStart, current, (*inputBuffer).dataLength);
		current += (*inputBuffer).dataLength;
		copyMemory("\'", current, lengthof("\'"));
		current += lengthof("\'");
		*current = '\0';
		exec(commandStart);
		free(commandStart);
		popPointer(commandToken);
	}
	ret;
	#undef  ROOT_UID
}



























/*! send a property or client message to the window using a custom atom to try and grab the keyboard and pointer again. */

local bool /*-*/ hasGrabbedKeyboard;
local bool /*-*/ hasGrabbedPointer;



int main(int argumentAmount, const char *const *argument){
	(void)setMemory;
	(void)findStringLength;
	(void)UTF8ToUCS2;
	(void)getPointerMonitor;
	(void)getWindowMonitor;
	(void)compositeImages;
	(void)compositeImagesOver;
	(void)compositeImagesAnd;
	(void)twoPassBoxBlur;
	(void)rotateImage;
	(void)fillDrawable;
	jmp setSignalHandler;
	setSignalHandler:{
		def struct sigaction /*-*/ Sigaction;
		Sigaction s;
		processingSignal = true;
		s.sa_handler = quit;
		s.sa_flags = 0;
		sigemptyset(&s.sa_mask);
		sigaction(SIGABRT, &s, NULL);
		sigaction(SIGBUS,  &s, NULL);
		sigaction(SIGFPE,  &s, NULL);
		sigaction(SIGILL,  &s, NULL);
		sigaction(SIGINT,  &s, NULL);
		sigaction(SIGQUIT, &s, NULL);
		sigaction(SIGSEGV, &s, NULL);
		sigaction(SIGTERM, &s, NULL);
		sigaction(SIGTRAP, &s, NULL);
		sigaction(SIGUSR1, &s, NULL);
		sigaction(SIGUSR2, &s, NULL);
		jmp setGlobals;
	}
	setGlobals:{
		programName /*-------------*/ = *argument;
		localeName /*--------------*/ = setlocale(LC_ALL, "");
		configPath /*--------------*/ = NULL;
		errorPath /*---------------*/ = NULL;
		connectionName /*----------*/ = NULL;
		colorStart /*--------------*/ = MESSAGE_START;
		colorFatal /*--------------*/ = MESSAGE_FATAL;
		colorError /*--------------*/ = MESSAGE_ERROR;
		colorEvent /*--------------*/ = MESSAGE_EVENT;
		colorEnd /*----------------*/ = MESSAGE_END;
		mustOpenErrorStream /*-----*/ = false;
		errorStream /*-------------*/ = DEFAULT_ERROR_STREAM;
		errorStreamToken /*--------*/ = 0;
		quitting /*----------------*/ = false;
		connection /*--------------*/ = NULL;
		connectionToken /*---------*/ = 0;
		display /*-----------------*/ = NULL;
		displayToken /*------------*/ = 0;
		im /*----------------------*/ = XCB_NONE;
		ic /*----------------------*/ = XCB_NONE;
		monitorStart /*------------*/ = NULL;
		monitorToken /*------------*/ = 0;
		keyPressNextOffset /*------*/ = 0;
		keyReleaseNextOffset /*----*/ = 0;
		buttonPressNextOffset /*---*/ = 0;
		buttonReleaseNextOffset /*-*/ = 0;
		event /*-------------------*/ = NULL;
		eventToken /*--------------*/ = 0;
		setConfigVariables();
		initMemoryManager();
		shmInit();
		setStringRoot(&globalScopesInstructionRoot);
		setStringRoot(&globalInstructionRoot);
		setStringRoot(&scope1ScopeInstructionRoot);
		setStringRoot(&booleanRoot);
		setStringRoot(&commandRoot);
		setStringRoot(&variableRoot);
		setStringRoot(&modifierRoot);
		setStringRoot(&macroRoot);



		/*!*/

		setStringRoot(&horizontalAlignmentRoot);
		setStringRoot(&verticalAlignmentRoot);
		setStringRoot(&numberTypeRoot);
		setStringRoot(&whichMonitorRoot);
		setStringRoot(&cornerRoot);



		setShortcutRoot(&keycodeShortcut);
		setShortcutRoot(&buttonShortcut);
		setASCIIStringRoot(&asciiRoot);
		{
			pthread_rwlockattr_t attributes;
			if(pthread_rwlockattr_init(&attributes) != PTHREAD_RWLOCKATTR_INIT_SUCCESS){
				printTitledError("pthread error", "could not init global lock attributes");
			}
			if(pthread_rwlockattr_setkind_np(&attributes, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) != PTHREAD_RWLOCKATTR_SETKIND_NP_SUCCESS){
				printTitledError("pthread error", "could not set global lock attributes lock kind");
			}
			globalsLockCreated = pthread_rwlock_init(&globalsLock, &attributes) == PTHREAD_RWLOCK_INIT_SUCCESS;
			if(!globalsLockCreated){
				printTitledError("pthread error", "could not init globals lock");
			}
			if(pthread_rwlockattr_destroy(&attributes) != PTHREAD_RWLOCKATTR_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy global lock attributes");
			}
		}
		processingSignal /*-----*/ = false;
		jmp getProgramArguments;
	}
	getProgramArguments:{
		if(argumentAmount == 1){
			printError("%s%s: %susage:%s %s [argument] [value] or %s [argument] [--help]\n\t[-h], [--help]  \tdisplay this message\n\t[-c], [--config]\tpath to config file, mandatory\n\t[-e], [--error] \tpath to error file, optional\n\t[-s], [--server]\tX server connection, optional\n", colorStart, programName, colorError, colorEnd, programName, programName);
			jmp mainEmergencyExit;
		}
		dec argumentAmount;
		jmp checkErrorRedirection;
	}
	checkErrorRedirection:{
		if(!isatty(fileno(DEFAULT_ERROR_STREAM))){
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
		}
		jmp matchArgumentsLoop;
	}
	matchArgumentsLoop:{
		switch identifyArgument(*(inc argument)) over
			to HELP_ARGUMENT: /*---*/ jmp helpArgument;
			to CONFIG_ARGUMENT: /*-*/ jmp configArgument;
			to ERROR_ARGUMENT: /*--*/ jmp errorArgument;
			to SERVER_ARGUMENT: /*-*/ jmp serverArgument;
			off: /*----------------*/ jmp notAnArgument;
		end
	}
	helpArgument:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s [argument] [value] or %s [argument] [--help]\n\t[-h], [--help]  \tdisplay this message\n\t[-c], [--config]\tpath to config file, mandatory\n\t[-e], [--error] \tpath to error file, optional\n\t[-s], [--server]\tX server connection, optional\n", programName, programName, programName);
		jmp mainEmergencyExit;
	}
	configArgument:{
		if(configPath){
			printTitledError("argument error", "the config argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no config value specified");
			jmp mainEmergencyExit;
		}
		configPath = *(inc argument);
		switch identifyArgument(configPath) over
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp openConfigFile;
			to HELP_ARGUMENT: /*---------*/ jmp displayConfigUsage;
			off: /*----------------------*/ jmp displayNoConfigValue;
		end
	}
	openConfigFile:{
		DIR *const dir = opendir(configPath);
		FILE *file;
		uint32 token = pushPointer(dir, "config directory argument", closedir);
		if(dir){
			closedir(dir);
			popPointer(token);
			printTitledQuotedError("argument error", *argument, "config value is directory");
			jmp mainEmergencyExit;
		}
		file = fopen(configPath, "r");
		token = pushPointer(file, "config file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			jmp matchArgumentLoopControl;
		}
		file = fopen(configPath, "w");
		token = pushPointer(file, "config file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			remove(configPath);
			jmp matchArgumentLoopControl;
		}
		printTitledError("argument error", "could not read or create config file");
		jmp mainEmergencyExit;
	}
	displayConfigUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --config \"/path/to/file\"\n\tif the specified file doesn't exist it will be created\n\tand it will contain the hardcoded default configuration\n", programName, programName);
		jmp mainEmergencyExit;
	}
	displayNoConfigValue:{
		printTitledError("argument error", "no config value specified");
		jmp mainEmergencyExit;
	}
	errorArgument:{
		if(errorPath){
			printTitledError("argument error", "the error argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no error value specified");
			jmp mainEmergencyExit;
		}
		errorPath = *(inc argument);
		switch identifyArgument(errorPath) over
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp openErrorFile;
			to HELP_ARGUMENT: /*---------*/ jmp displayErrorUsage;
			to STDOUT_ARGUMENT: /*-------*/ jmp setErrorStreamStdout;
			to STDERR_ARGUMENT: /*-------*/ jmp setErrorStreamStderr;
			off: /*----------------------*/ jmp displayNoErrorValue;
		end
	}
	openErrorFile:{
		DIR *const dir = opendir(configPath);
		FILE *file;
		uint32 token = pushPointer(dir, "error directory argument", closedir);
		if(dir){
			closedir(dir);
			popPointer(token);
			printTitledQuotedError("argument error", *argument, "error value is directory");
			jmp mainEmergencyExit;
		}
		file = fopen(errorPath, "r");
		token = pushPointer(file, "error file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			mustOpenErrorStream = true;
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
			jmp matchArgumentLoopControl;
		}
		file = fopen(errorPath, "w");
		token = pushPointer(file, "error file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			remove(errorPath);
			mustOpenErrorStream = true;
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
			jmp matchArgumentLoopControl;
		}
		printTitledError("argument error", "could not create error file");
		jmp mainEmergencyExit;
	}
	displayErrorUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --error \"/path/to/file\"\n\tif the specified file doesn't exist it will be created\n", programName, programName);
		jmp mainEmergencyExit;
	}
	setErrorStreamStdout:{
		errorStream = stdout;
		jmp matchArgumentLoopControl;
	}
	setErrorStreamStderr:{
		errorStream = stderr;
		jmp matchArgumentLoopControl;
	}
	displayNoErrorValue:{
		printTitledError("argument error", "no error value specified");
		jmp mainEmergencyExit;
	}
	serverArgument:{
		if(connectionName){
			printTitledError("argument error", "the server argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no server value specified");
			jmp mainEmergencyExit;
		}
		connectionName = *(inc argument);
		switch identifyArgument(connectionName) over
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp matchArgumentLoopControl;
			to HELP_ARGUMENT: /*---------*/ jmp displayServerUsage;
			off: /*----------------------*/ jmp displayNoServerValue;
		end
	}
	displayServerUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --server \"name\"\n\tthe name of the server, if running, should be something like \":0\"\n\tit can be checked with the $DISPLAY variable on a running server (no tty)\n", programName, programName);
		jmp mainEmergencyExit;
	}
	displayNoServerValue:{
		printTitledError("argument error", "no server value specified");
		jmp mainEmergencyExit;
	}
	notAnArgument:{
		printTitledQuotedError("argument error", *argument, "is not recognized as program argument, check help? [-h]");
		jmp mainEmergencyExit;
	}
	matchArgumentLoopControl:{
		if(dec argumentAmount){
			jmp matchArgumentsLoop;
		}
		jmp argumentsFinalCheck;
	}
	argumentsFinalCheck:{
		if(!configPath){
			printTitledError("argument error", "no config argument specified");
			jmp mainEmergencyExit;
		}
		if(errorPath and sensitiveStringCompare(errorPath, configPath)){
			mustOpenErrorStream = false;
			printTitledError("argument error", "config and error files are the same");
			jmp mainEmergencyExit;
		}
		jmp startConcurrentThreads;
	}
	startConcurrentThreads:{
		jmp establishServerConnection;
	}
	establishServerConnection:{
		screenNumber = 0;
		connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
		connectionToken = pushPointer(connection, "X connection", iXCBDisconnect);
		screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		jmp establishDualServerConnection;
	}
	establishDualServerConnection:{
		xcb_disconnect(connection);
		popPointer(connectionToken);
		connection = NULL;
		connectionToken = 0;
		display = XOpenDisplay(connectionName);
		displayToken = pushPointer(display, "X connection", XCloseDisplay);
		if(!display){
			printTitledError("fatal X server error", "could not connect to server");
			jmp mainEmergencyExit;
		}
		screenNumber = DefaultScreen(display);
		connection = XGetXCBConnection(display);
		connectionToken = 0;
		screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		XSetEventQueueOwner(display, XCBOwnsEventQueue);
		jmp checkExtensionAvailability;
	}
	checkExtensionAvailability:{
		#define STRING(f) /*--------*/ { \
			  f("RANDR") \
		}
		#define BASE_POINTER /*-----*/ { \
			  &randrMajorOpcode \
			, &randrBaseEvent \
			, &randrBaseError \
		}
		#define VERSION_FUNCTION /*-*/ { \
			  &randrQueryVersionUnchecked \
		}
		#define MAJOR_VERSION /*----*/ { \
			  XCB_RANDR_MAJOR_VERSION \
		}
		#define MINOR_VERSION /*----*/ { \
			  XCB_RANDR_MINOR_VERSION \
		}
		char *nameStart[] = STRING(SELF);
		uint lengthStart[] = STRING(lengthof);
		xcb_query_extension_cookie_t cookieStart[countof(nameStart)];
		uint8 *basePointerStart[countof(nameStart) * 3] = BASE_POINTER;
		xcb_void_cookie_t (*versionFunctionStart[countof(nameStart)])(xcb_connection_t *, uint32, uint32) = VERSION_FUNCTION;
		uint32 majorVersionStart[countof(nameStart)] = MAJOR_VERSION;
		uint32 minorVersionStart[countof(nameStart)] = MINOR_VERSION;
		xcb_void_cookie_t versionCookieStart[countof(nameStart)];
		char **nameCurrent = nameStart;
		uint *lengthCurrent = lengthStart;
		xcb_query_extension_cookie_t *cookieCurrent = cookieStart;
		uint8 **basePointerCurrent = basePointerStart;
		xcb_void_cookie_t (**versionFunctionCurrent)(xcb_connection_t *, uint32, uint32) = versionFunctionStart;
		uint32 *majorVersionCurrent = majorVersionStart;
		uint32 *minorVersionCurrent = minorVersionStart;
		xcb_void_cookie_t *versionCookieCurrent = versionCookieStart;
		xcb_query_extension_cookie_t *const cookieWall = cookieCurrent + countof(nameStart);
		xcb_void_cookie_t *const versionCookieWall = versionCookieCurrent + countof(nameStart);
		jmp queryExtensionRequestLoop;
		queryExtensionRequestLoop:{
			*cookieCurrent = xcb_query_extension_unchecked(connection, *lengthCurrent, *nameCurrent);
			if(inc cookieCurrent < cookieWall){
				inc nameCurrent;
				inc lengthCurrent;
				jmp queryExtensionRequestLoop;
			}
			cookieCurrent = cookieStart;
			nameCurrent = nameStart;
			lengthCurrent = lengthStart;
			jmp queryExtensionReplyLoop;
		}
		queryExtensionReplyLoop:{
			xcb_query_extension_reply_t *const reply = xcb_wait_for_reply(connection, *cookieCurrent, NULL);
			uint32 token = pushPointer(reply, "query extension reply", iFree);
			(*versionCookieCurrent).sequence = 0;
			**(basePointerCurrent + 0) = 0;
			**(basePointerCurrent + 1) = 0;
			**(basePointerCurrent + 2) = 0;
			if(!reply){
				printTitledNamedError("reply error", "could not get reply for", *nameCurrent);
			}else{
				if(!(*reply).present){
					printTitledQuotedError("extension error", *nameCurrent, "extension is not available");
				}else{
					*versionCookieCurrent = (*versionFunctionCurrent)(connection, *majorVersionCurrent, *minorVersionCurrent);
					**(basePointerCurrent + 0) = (*reply).major_opcode;
					**(basePointerCurrent + 1) = (*reply).first_event;
					**(basePointerCurrent + 2) = (*reply).first_error;
				}
				free(reply);
				popPointer(token);
			}
			if(inc cookieCurrent < cookieWall){
				inc nameCurrent;
				basePointerCurrent += 3;
				inc versionFunctionCurrent;
				inc majorVersionCurrent;
				inc minorVersionCurrent;
				inc versionCookieCurrent;
				jmp queryExtensionReplyLoop;
			}
			versionCookieCurrent = versionCookieStart;
			jmp queryExtensionVersionReplyLoop;
		}
		queryExtensionVersionReplyLoop:{
			if((*versionCookieCurrent).sequence){
				void *const reply = xcb_wait_for_reply(connection, *versionCookieCurrent, NULL);
				uint32 token = pushPointer(reply, "query extension version reply", iFree);
				free(reply);
				popPointer(token);
			}
			if(inc versionCookieCurrent < versionCookieWall){
				jmp queryExtensionVersionReplyLoop;
			}
			jmp setAtoms;
		}
		#undef  MINOR_VERSION
		#undef  MAJOR_VERSION
		#undef  VERSION_FUNCTION
		#undef  BASE_POINTER
		#undef  STRING
	}
	setAtoms:{
		#define STRING(f) /*-*/ { \
			  f("WM_NAME") \
			, f("WM_ICON_NAME") \
			, f("WM_NORMAL_HINTS") \
			, f("WM_SIZE_HINTS") \
			, f("WM_HINTS") \
			, f("WM_CLASS") \
			, f("WM_TRANSIENT_FOR") \
			, f("WM_PROTOCOLS") \
			, f("WM_TAKE_FOCUS") \
			, f("WM_DELETE_WINDOW") \
			, f("WM_COLORMAP_WINDOWS") \
			, f("WM_COLORMAP_NOTIFY") \
			, f("WM_CLIENT_MACHINE") \
			, f("WM_LOCALE_NAME") \
			, f("WM_WINDOW_ROLE") \
			, f("WM_COMMAND") \
			, f("WM_CLIENT_LEADER") \
			, f("WM_STATE") \
			, f("WM_CHANGE_STATE") \
			, f("WM_ICON_SIZE") \
			, f("UTF8_STRING") \
			, f("_NET_SUPPORTED") \
			, f("_NET_CLIENT_LIST") \
			, f("_NET_CLIENT_LIST_STACKING") \
			, f("_NET_NUMBER_OF_DESKTOPS") \
			, f("_NET_DESKTOP_GEOMETRY") \
			, f("_NET_DESKTOP_VIEWPORT") \
			, f("_NET_CURRENT_DESKTOP") \
			, f("_NET_DESKTOP_NAMES") \
			, f("_NET_ACTIVE_WINDOW") \
			, f("_NET_WORKAREA") \
			, f("_NET_SUPPORTING_WM_CHECK") \
			, f("_NET_VIRTUAL_ROOTS") \
			, f("_NET_DESKTOP_LAYOUT") \
			, f("_NET_SHOWING_DESKTOP") \
			, f("_NET_CLOSE_WINDOW") \
			, f("_NET_MOVERESIZE_WINDOW") \
			, f("_NET_WM_MOVERESIZE") \
			, f("_NET_RESTACK_WINDOW") \
			, f("_NET_REQUEST_FRAME_EXTENTS") \
			, f("_NET_WM_NAME") \
			, f("_NET_WM_VISIBLE_NAME") \
			, f("_NET_WM_ICON_NAME") \
			, f("_NET_WM_VISIBLE_ICON_NAME") \
			, f("_NET_WM_DESKTOP") \
			, f("_NET_WM_WINDOW_TYPE") \
			, f("_NET_WM_WINDOW_TYPE_DESKTOP") \
			, f("_NET_WM_WINDOW_TYPE_DOCK") \
			, f("_NET_WM_WINDOW_TYPE_TOOLBAR") \
			, f("_NET_WM_WINDOW_TYPE_MENU") \
			, f("_NET_WM_WINDOW_TYPE_UTILITY") \
			, f("_NET_WM_WINDOW_TYPE_SPLASH") \
			, f("_NET_WM_WINDOW_TYPE_DIALOG") \
			, f("_NET_WM_WINDOW_TYPE_NORMAL") \
			, f("_NET_WM_STATE") \
			, f("_NET_WM_STATE_MODAL") \
			, f("_NET_WM_STATE_STICKY") \
			, f("_NET_WM_STATE_MAXIMIZED_VERT") \
			, f("_NET_WM_STATE_MAXIMIZED_HORZ") \
			, f("_NET_WM_STATE_SHADED") \
			, f("_NET_WM_STATE_SKIP_TASKBAR") \
			, f("_NET_WM_STATE_SKIP_PAGER") \
			, f("_NET_WM_STATE_HIDDEN") \
			, f("_NET_WM_STATE_FULLSCREEN") \
			, f("_NET_WM_STATE_ABOVE") \
			, f("_NET_WM_STATE_BELOW") \
			, f("_NET_WM_STATE_DEMANDS_ATTENTION") \
			, f("_NET_WM_ALLOWED_ACTIONS") \
			, f("_NET_WM_ACTION_MOVE") \
			, f("_NET_WM_ACTION_RESIZE") \
			, f("_NET_WM_ACTION_MINIMIZE") \
			, f("_NET_WM_ACTION_SHADE") \
			, f("_NET_WM_ACTION_STICK") \
			, f("_NET_WM_ACTION_MAXIMIZE_HORZ") \
			, f("_NET_WM_ACTION_MAXIMIZE_VERT") \
			, f("_NET_WM_ACTION_FULLSCREEN") \
			, f("_NET_WM_ACTION_CHANGE_DESKTOP") \
			, f("_NET_WM_ACTION_CLOSE") \
			, f("_NET_WM_STRUT") \
			, f("_NET_WM_STRUT_PARTIAL") \
			, f("_NET_WM_ICON_GEOMETRY") \
			, f("_NET_WM_ICON") \
			, f("_NET_WM_PID") \
			, f("_NET_WM_HANDLED_ICONS") \
			, f("_NET_WM_USER_TIME") \
			, f("_NET_FRAME_EXTENTS") \
			, f("_NET_WM_PING") \
			, f("_NET_WM_SYNC_REQUEST") \
			, f("_NET_WM_SYNC_REQUEST_COUNTER") \
			, f("_NET_SYSTEM_TRAY_ORIENTATION") \
			, f("_NET_SYSTEM_TRAY_OPCODE") \
			, f("_NET_SYSTEM_TRAY_MESSAGE_DATA") \
			, f("_XEMBED_INFO") \
			, f("_XEMBED") \
			, f("_XROOTPMAP_ID") \
		}
		const char *const atomNameStart[] = STRING(SELF);
		const uint atomNameSizeStart[] = STRING(lengthof);
		xcb_intern_atom_cookie_t cookieStart[countof(atomNameStart)];
		const char *const *atomNameCurrent = atomNameStart;
		const uint *atomNameSizeCurrent = atomNameSizeStart;
		xcb_intern_atom_cookie_t *cookieCurrent = cookieStart;
		xcb_intern_atom_cookie_t *const cookieWall = cookieStart + countof(cookieStart);
		xcb_atom_t *atomCurrent = (void *)&atom;
		jmp atomRequestLoop;
		atomRequestLoop:{
			*cookieCurrent = xcb_intern_atom_unchecked(connection, false, *atomNameSizeCurrent, *atomNameCurrent);
			if(inc cookieCurrent < cookieWall){
				inc atomNameSizeCurrent;
				inc atomNameCurrent;
				jmp atomRequestLoop;
			}
			cookieCurrent = cookieStart;
			jmp atomReplyLoop;
		}
		atomReplyLoop:{
			xcb_intern_atom_reply_t *const reply = xcb_wait_for_reply(connection, *cookieCurrent, NULL);
			uint32 token = pushPointer(reply, "atom reply", iFree);
			if(!reply){
				printError("%s%s: %s%s:%s %s %s %s\n", colorStart, programName, colorError, "atom error", colorEnd, "could not get the", *(atomNameStart + (cookieCurrent - cookieStart)), "atom");
			}else{
				*atomCurrent = (*reply).atom;
				free(reply);
				popPointer(token);
			}
			if(inc cookieCurrent < cookieWall){
				inc atomCurrent;
				jmp atomReplyLoop;
			}
			jmp setOtherAtoms;
		}
		#undef  STRING
	}
	setOtherAtoms:{
		jmp selectInput;
	}
	selectInput:{
		const uint32 valueList = XCB_EVENT_MASK_NO_EVENT;
		xcb_void_cookie_t cookie = xcb_change_window_attributes_checked(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
		xcb_generic_error_t *error = xcb_request_check(connection, cookie);
		uint32 token = pushPointer(error, "select input event mask error", iFree);
		if(error){
			printTitledError("select input error", "could not apply to receive root window events");
			free(error);
			popPointer(token);
		}
		cookie = xcb_randr_select_input_checked(connection, (*screen).root, XCB_RANDR_NOTIFY_MASK_SCREEN_CHANGE);
		error = xcb_request_check(connection, cookie);
		token = pushPointer(error, "select input xrandr event mask error", iFree);
		if(error){
			printTitledError("randr select input error", "could not apply to receive monitor events");
			free(error);
			popPointer(token);
		}
		jmp selectExtraInput;
	}
	selectExtraInput:{
		xcb_grab_keyboard_cookie_t keyboardCookie;
		xcb_grab_pointer_cookie_t pointerCookie;
		void *reply;
		uint32 token;
		if(!XSupportsLocale()){
			printTitledError("locale error", "current X locale not supported");
		}
		if(!(im = XOpenIM(display, NULL, NULL, NULL))){
			printTitledError("input method error", "could not open input method");
		}elif(!(ic = XCreateIC(im, XNInputStyle, XIMPreeditNothing | XIMStatusNothing, XNClientWindow, (*screen).root, NULL))){
			printTitledError("input context error", "could not open input context");
		}



		/*!*/

		hasGrabbedKeyboard = false;
		hasGrabbedPointer = false;



		keyboardCookie = xcb_grab_keyboard_unchecked(connection, true, (*screen).root, getTimestamp(), XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);



		pointerCookie = xcb_grab_pointer_unchecked(connection, true, (*screen).root, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, getTimestamp());



		reply = xcb_wait_for_reply(connection, keyboardCookie, NULL);
		token = pushPointer(reply, "grab keyboard reply", iFree);
		if(!reply){
			printTitledError("select input error", "could not grab keyboard");
		}else{
			hasGrabbedKeyboard = (*(xcb_grab_keyboard_reply_t *)reply).status;
			free(reply);
			popPointer(token);
			if(hasGrabbedKeyboard != XCB_GRAB_STATUS_SUCCESS){
				printTitledError("select input error", "could not grab keyboard");
			}
		}



		reply = xcb_wait_for_reply(connection, pointerCookie, NULL);
		token = pushPointer(reply, "grab pointer reply", iFree);
		if(!reply){
			printTitledError("select input error", "could not grab pointer");
		}else{
			hasGrabbedPointer = (*(xcb_grab_pointer_reply_t *)reply).status;
			free(reply);
			popPointer(token);
			if(hasGrabbedPointer != XCB_GRAB_STATUS_SUCCESS){
				printTitledError("select input error", "could not grab pointer");
			}
		}
		jmp setupScreenProfile;
	}
	setupScreenProfile:{
		xcb_depth_iterator_t depthIterator = xcb_screen_allowed_depths_iterator(screen);
		xcb_visualtype_iterator_t visualIterator;
		visual = (*screen).root_visual;
		depth = (*screen).root_depth;
		jmp findDepth;
		findDepth:{
			if((*depthIterator.data).depth == 32){
				visualIterator = xcb_depth_visuals_iterator(depthIterator.data);
				jmp findVisual;
			}
			if(!depthIterator.rem){
				printTitledError("screen error", "could not find a 32-bit depth visual, using default screen visual instead");
				jmp setupIDs;
			}
			xcb_depth_next(&depthIterator);
			jmp findDepth;
		}
		findVisual:{
			if((*visualIterator.data)._class == XCB_VISUAL_CLASS_TRUE_COLOR){
				visual = (*visualIterator.data).visual_id;
				depth = (*depthIterator.data).depth;
				jmp setupIDs;
			}
			if(!visualIterator.rem){
				printTitledError("screen error", "could not match 32-bit depth with a true color visual, using default screen visual instead");
				jmp setupIDs;
			}
			dec visualIterator.rem;
			inc visualIterator.data;
			jmp findVisual;
		}
	}
	setupIDs:{
		struct{
			uint32 /*---------*/ backgroundColor;
			uint32 /*---------*/ borderColor;
			uint32 /*---------*/ overrideRedirect;
			uint32 /*---------*/ eventMask;
			xcb_colormap_t /*-*/ colormap;
		} valueList;
		struct{
			uint32 /*---------*/ generateExpose;
		} gcValueList;
		colormap = xcb_generate_id(connection);
		window = xcb_generate_id(connection);
		pixmap = xcb_generate_id(connection);
		gc = xcb_generate_id(connection);
		valueList.backgroundColor = 0x00000000;
		valueList.borderColor = 0x00000000;
		valueList.overrideRedirect = true;
		valueList.eventMask = XCB_EVENT_MASK_STRUCTURE_NOTIFY | XCB_EVENT_MASK_PROPERTY_CHANGE;
		valueList.colormap = colormap;
		gcValueList.generateExpose = false;
		xcb_create_colormap(connection, XCB_COLORMAP_ALLOC_NONE, colormap, (*screen).root, visual);
		xcb_create_window(connection, depth, window, (*screen).root, 0, 0, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT, visual, XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP, &valueList);
		xcb_create_pixmap(connection, depth, pixmap, window, (*screen).width_in_pixels, (*screen).height_in_pixels);
		xcb_create_gc(connection, gc, pixmap, XCB_GC_GRAPHICS_EXPOSURES, &gcValueList);
		xcb_change_window_attributes(connection, window, XCB_CW_BACK_PIXMAP, &pixmap);
		mapped = false;
		jmp storeMonitors;
	}
	storeMonitors:{
		xcb_randr_get_monitors_reply_t *const reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors_unchecked(connection, (*screen).root, true), NULL);
		uint32 replyToken = pushPointer(reply, "monitor reply", iFree);
		Monitor *monitorCurrent;
		Monitor *monitorWall;
		xcb_randr_monitor_info_iterator_t iterator;
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		freeMonitors();
		if(!reply){
			printTitledError("reply error", "could not get monitors");
			monitorAllocated = 0;
			jmp storeMonitorsExit;
		}
		monitorAllocated = (*reply).nMonitors;
		monitorStart = malloc(monitorAllocated * sizeof(Monitor));
		monitorToken = pushPointer(monitorStart, "monitor pointer", iFree);
		if(!monitorStart){
			printTitledError("memory allocation error", "could not store monitor data");
			monitorAllocated = 0;
			free(reply);
			jmp storeMonitorsExit;
		}
		iterator = xcb_randr_get_monitors_monitors_iterator(reply);
		monitorCurrent = monitorStart;
		monitorWall = monitorStart + monitorAllocated;
		jmp storeMonitorLoop;
		storeMonitorLoop:{
			if(monitorCurrent < monitorWall){
				const xcb_randr_monitor_info_t *const data = iterator.data;
				const int x = (*data).x;
				const int y = (*data).y;
				const int width = (*data).width;
				const int height = (*data).height;
				xcb_randr_output_t *outputCurrent;
				xcb_randr_output_t *outputWall;
				if(monitorCurrent > monitorStart){
					const Monitor *current = monitorStart;
					const Monitor *const wall = monitorCurrent;
					jmp removeSameMonitorLoop;
					removeSameMonitorLoop:{
						if(current < wall){
							if((*current).leftX == x and (*current).topY == y and (*current).width == width and (*current).height == height){
								dec monitorAllocated;
								xcb_randr_monitor_info_next(&iterator);
								jmp storeMonitorLoop;
							}
							inc current;
							jmp removeSameMonitorLoop;
						}
					}
				}
				(*monitorCurrent).leftX = x;
				(*monitorCurrent).topY = y;
				(*monitorCurrent).rightX = x + width;
				(*monitorCurrent).bottomY = y + height;
				(*monitorCurrent).width = width;
				(*monitorCurrent).height = height;
				outputCurrent = xcb_randr_monitor_info_outputs(data);
				outputWall = outputCurrent + xcb_randr_monitor_info_outputs_length(data);
				jmp getOutputMillimeterSizeLoop;
				getOutputMillimeterSizeLoop:{
					if(outputCurrent < outputWall){
						xcb_randr_get_output_info_reply_t *const reply = xcb_wait_for_reply(connection, xcb_randr_get_output_info_unchecked(connection, *outputCurrent, getTimestamp()), NULL);
						uint32 token = pushPointer(reply, "get output info reply", iFree);
						if(reply){
							if((*reply).connection == XCB_RANDR_CONNECTION_CONNECTED){
								(*monitorCurrent).millimeterWidth = (*reply).mm_width;
								(*monitorCurrent).millimeterHeight = (*reply).mm_height;
								outputCurrent = outputWall;
							}
							free(reply);
							popPointer(token);
						}
						inc outputCurrent;
						jmp getOutputMillimeterSizeLoop;
					}
					xcb_randr_monitor_info_next(&iterator);
					inc monitorCurrent;
					jmp storeMonitorLoop;
				}
			}
			free(reply);
			popPointer(replyToken);
			jmp trimMonitorMemory;
		}
	}
	trimMonitorMemory:{
		void *temp = realloc(monitorStart, monitorAllocated * sizeof(Monitor));
		updatePointer(monitorToken, temp);
		if(!temp){
			jmp storeMonitorsExit;
		}
		monitorStart = temp;
		jmp storeMonitorsExit;
	}
	storeMonitorsExit:{
		configureWindow();
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		if(event){
			jmp eventLoop;
		}
		jmp preReadConfig;
	}
	preReadConfig:{
		bulkInsertString(&globalScopesInstructionRoot, globalScopesInstructionList);
		bulkInsertString(&globalInstructionRoot, globalInstructionList);
		bulkInsertString(&scope1ScopeInstructionRoot, scope1ScopeInstructionList);
		bulkInsertString(&booleanRoot, booleanList);
		bulkInsertString(&commandRoot, commandList);
		bulkInsertString(&variableRoot, variableList);
		bulkInsertString(&modifierRoot, modifierList);
		bulkInsertString(&macroRoot, macroList);



		/*!*/

		bulkInsertString(&horizontalAlignmentRoot, horizontalAlignmentList);
		bulkInsertString(&verticalAlignmentRoot, verticalAlignmentList);
		bulkInsertString(&numberTypeRoot, numberTypeList);
		bulkInsertString(&whichMonitorRoot, whichMonitorList);
		bulkInsertString(&cornerRoot, cornerList);



		pathInsertString(&asciiRoot, "PATH");
		jmp readConfig;
	}
	readConfig:{
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		displaySimpleConfigErrors = true;
		restartCommand(false);
		setConfigVariables();
		readConfig(true, configPath, fgetc);
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		jmp getThing;
	}









	getThing:{



		setInputBuffer(&inputBuffer);
		setClipboardBuffer(&clipboardBuffer);

		/*! unsetInputBuffer(&inputBuffer); */
		/*! unsetClipboardBuffer(&clipboardBuffer); */



		inputMode = NORMAL_INPUT_MODE;
		currentSelectedResult = -1;



		getResults(&inputBuffer);
		mapWindow();



		jmp eventLoopCheckShortcuts;
	}









	eventLoopCheckShortcuts:{
		if(keyPressNextOffset){
			jmp keyPressEvent;
		}
		if(keyReleaseNextOffset){
			jmp keyReleaseEvent;
		}
		if(buttonPressNextOffset){
			jmp buttonPressEvent;
		}
		if(buttonReleaseNextOffset){
			jmp buttonReleaseEvent;
		}
		jmp eventLoop;
	}
	eventLoop:{
		xcb_flush(connection);
		free(event);
		popPointer(eventToken);
		event = NULL;
		eventToken = 0;
		jmp waitForEvent;
	}
	waitForEvent:{
		event = xcb_wait_for_event(connection);
		eventToken = pushPointer(event, "event pointer", iFree);
		if(event){
			jmp switchEvent;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		jmp waitForEvent;
	}
	switchEvent:{
		#define XCB_ONE /*-*/ (1)
		printXEvent(eventName);
		switch (*event).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unrecognizedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp keyPressEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp keyReleaseEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp buttonPressEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp buttonReleaseEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp unexpectedEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp eventLoop;
			to XCB_MAP_NOTIFY: /*--------*/ jmp eventLoop;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp eventLoop;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp eventLoop;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp eventLoop;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp propertyNotifyEvent;
			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp genericEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	errorEvent:{
		#define e /*-*/ ((xcb_generic_error_t *)event)
		printXError(errorName);
		jmp eventLoop;
		#undef  e
	}
	keyPressEvent:{
		#define e /*-*/ ((xcb_key_press_event_t *)event)
		if(getNextShortcut(&keycodeShortcut, (*e).detail, (*e).state & b(11111111), &keyPressNextOffset)){
			jmp matchCommandPress;
		}
		insertCharacter(&inputBuffer, e);
		jmp eventLoop;
		#undef  e
	}
	keyReleaseEvent:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		if(!keyReleaseNextOffset){
			xcb_query_keymap_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_keymap_unchecked(connection), NULL);
			uint32 token = pushPointer(reply, "query keymap reply", iFree);
			if(reply){
				const bool isPressed = !!(*((*reply).keys + (*e).detail / 8) & (1 << (*e).detail % 8));
				free(reply);
				popPointer(token);
				if(isPressed){
					jmp eventLoop;
				}
			}
		}
		if(getNextShortcut(&keycodeShortcut, (*e).detail, (*e).state & b(11111111), &keyReleaseNextOffset)){
			jmp matchCommandRelease;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonPressEvent:{
		#define e /*-*/ ((xcb_button_press_event_t *)event)
		if(getNextShortcut(&buttonShortcut, (*e).detail, (*e).state & b(11111111), &buttonPressNextOffset)){
			jmp matchCommandPress;
		}
		if((*e).child != window){
			jmp mainEmergencyExit;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonReleaseEvent:{
		#define e /*-*/ ((xcb_button_release_event_t *)event)
		if(getNextShortcut(&buttonShortcut, (*e).detail, (*e).state & b(11111111), &buttonReleaseNextOffset)){
			jmp matchCommandRelease;
		}
		jmp eventLoop;
		#undef  e
	}
	matchCommandPress: switch matchCommand((*eventModifierNode).command, PRESS_SWITCH_COMMAND_ORIGIN) over
		to TYPICAL_SWITCH_COMMAND: /*-------*/ jmp eventLoopCheckShortcuts;
		to RESTART_SWITCH_COMMAND: /*-------*/ jmp readConfig;
		to EXIT_SWITCH_COMMAND: /*----------*/ jmp mainEmergencyExit;
		off: /*-----------------------------*/ jmp eventLoopCheckShortcuts;
	end
	matchCommandRelease: switch matchCommand((*eventModifierNode).command, RELEASE_SWITCH_COMMAND_ORIGIN) over
		to TYPICAL_SWITCH_COMMAND: /*-------*/ jmp eventLoopCheckShortcuts;
		to RESTART_SWITCH_COMMAND: /*-------*/ jmp readConfig;
		to EXIT_SWITCH_COMMAND: /*----------*/ jmp mainEmergencyExit;
		off: /*-----------------------------*/ jmp eventLoopCheckShortcuts;
	end
	propertyNotifyEvent:{
		#define e /*-*/ ((xcb_property_notify_event_t *)event)



		/*!*/



		/*! if specific property event came to enable keyboard grabbing, grab keyboard */

		/*!{
			uint i = 0;
			jmp loopo;
			loopo:{
				if(i < 1000){
					void *reply = xcb_wait_for_reply(connection, xcb_grab_keyboard_unchecked(connection, true, (*screen).root, getTimestamp(), XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC), NULL);
					uint32 token = pushPointer(reply, "grab keyboard reply", iFree);
					if(!reply){
						printTitledError("select input error", "could not grab keyboard");
					}else{
						const uint8 status = (*(xcb_grab_keyboard_reply_t *)reply).status;
						free(reply);
						popPointer(token);
						if(status == XCB_GRAB_STATUS_SUCCESS){
							fprintf(stdout, "\n\n\nsuccess after %u\n\n\n\n", i);
							jmp loopoExit;
						}
					}
					inc i;
					jmp loopo;
				}
				fprintf(stdout, "\n\n\nfailure after %u\n\n\n\n", i);
				printTitledError("select input error", "could not grab keyboard");
			}
			loopoExit:{}
		}*/



		jmp eventLoop;
		#undef  e
	}
	genericEvent:{
		#define e /*-*/ ((xcb_ge_generic_event_t *)event)
		jmp unexpectedEvent;
		#undef  e
	}
	extensionEvent:{
		const uint8 eventType = (*event).response_type & ~b(10000000);
		if(eventType >= randrBaseEvent and eventType < randrBaseEvent + countof(randrEventName) - 1){
			jmp switchRandrEvent;
		}
		if(eventType >= randrBaseError and eventType < randrBaseError + countof(randrErrorName) - 1){
			jmp switchRandrError;
		}
		jmp unhandledEvent;
	}
	switchRandrEvent:{
		printXEvent(randrEventName);
		switch ((*event).response_type & ~b(10000000)) - randrBaseEvent over
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY: /*-*/ jmp storeMonitors;
			to XCB_RANDR_NOTIFY: /*---------------*/ jmp storeMonitors;
			off: /*-------------------------------*/ jmp unrecognizedEvent;
		end
	}
	switchRandrError:{
		printXError(randrErrorName);
		switch ((*event).response_type & ~b(10000000)) - randrBaseError over
			to XCB_RANDR_BAD_OUTPUT: /*---*/ jmp eventLoop;
			to XCB_RANDR_BAD_CRTC: /*-----*/ jmp eventLoop;
			to XCB_RANDR_BAD_MODE: /*-----*/ jmp eventLoop;
			to XCB_RANDR_BAD_PROVIDER: /*-*/ jmp eventLoop;
			off: /*-----------------------*/ jmp unrecognizedEvent;
		end
	}
	unrecognizedEvent:{
		printTitledValuedError("X event error", "unrecognized event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unrecognizedError:{
		printTitledValuedError("X event error", "unrecognized error with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
		jmp unrecognizedError;
	}
	unexpectedEvent:{
		printTitledValuedError("unexpected X event", "unexpected event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unhandledEvent:{
		printTitledValuedError("X event error", "unhandled event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	mainEmergencyExit:{
		exitCommand();
		ret 0;
	}
}
QUIT(){
	const char *message;
	const Pointer *start;
	const Pointer *current;
	const Pointer *wall;
	jmp evaluateHandlerAvailability;
	evaluateHandlerAvailability:{
		if(quitting){
			switch signal over
				to SIGABRT: /*-*/ brk;
				to SIGBUS: /*--*/ brk;
				to SIGFPE: /*--*/ brk;
				to SIGILL: /*--*/ brk;
				to SIGSEGV: /*-*/ brk;
				to SIGTRAP: /*-*/ brk;
				off: /*--------*/ ret;
			end
			printTitledNamedError("quitting error", "could not free", labelExamined);
			jmp exit;
		}
		if(processingSignal and signal != SIGINT){
			ret;
		}
		processingSignal = true;
		jmp findSignal;
	}
	findSignal: switch signal over
		to SIGABRT: /*-*/ message = "aborted"; /*--------------*/ jmp exitWithError;
		to SIGBUS: /*--*/ message = "hardware faulted"; /*-----*/ jmp exitWithError;
		to SIGFPE: /*--*/ message = "programmer math'd up"; /*-*/ jmp exitWithError;
		to SIGILL: /*--*/ message = "executable corrupted"; /*-*/ jmp exitWithError;
		to SIGINT: /*--*/ message = "interrupted"; /*----------*/ jmp exitWithError;
		to SIGQUIT: /*-*/ message = "voluntarily quitted"; /*--*/ jmp exitWithError;
		to SIGSEGV: /*-*/ message = "segmentation faulted"; /*-*/ jmp exitWithError;
		to SIGTERM: /*-*/ message = "terminated"; /*-----------*/ jmp exitWithError;
		to SIGTRAP: /*-*/ message = "trapped"; /*--------------*/ jmp exitWithError;
		to SIGUSR1: /*-*/ /*-----------------------------------*/ jmp handleUserSignal;
		to SIGUSR2: /*-*/ /*-----------------------------------*/ jmp handleUserSignal;
		off: /*--------*/ message = "unhandled signal"; /*-----*/ jmp exitWithError;
	end
	handleUserSignal:{
		processingSignal = false;
		ret;
	}
	exitWithError:{
		quitting = true;
		printTitledError("signal received", message);
		if(dynamicDataSegment.allocated <= 1){
			jmp exit;
		}
		start = dynamicDataSegment.data;
		current = start + 1;
		wall = start + dynamicDataSegment.allocated;
		switch signal over
			to SIGABRT:
			to SIGBUS:
			to SIGFPE:
			to SIGILL:
			to SIGSEGV:
			to SIGTRAP:{
				printError("%s%s: %spointers at time of error:%s\n", colorStart, programName, colorError, colorEnd);
				if(dynamicDataSegment.allocated > 1){
					jmp printPointedVariables;
				}
				printError("none\n");
				jmp freePointedVariablesLoop;
			}
			off:{
				jmp freePointedVariablesLoop;
			}
		end
	}
	printPointedVariables:{
		printUnaccountedForPointers(current, wall);
		current = start + 1;
		jmp freePointedVariablesLoop;
	}
	freePointedVariablesLoop:{
		if((*current).data){
			labelExamined = (*current).label;
			(*current).free((*current).data);
		}
		if(inc current < wall){
			jmp freePointedVariablesLoop;
		}
		jmp exit;
	}
	exit:{
		deleteMemoryManager();
		closeErrorStream();
		exit(EXIT_SUCCESS);
	}
}
GETSHAREDCHARACTER(){
	(void)configFile;
	inc sharedCurrent;
	ret *(sharedCurrent - 1);
}
INITMEMORYMANAGER(){
	#define DYNAMIC_DATA_SEGMENT_BLOCK_SIZE /*-*/ (16)
	#define s /*-------------------------------*/ (dynamicDataSegment)
	s.size = DYNAMIC_DATA_SEGMENT_BLOCK_SIZE;
	s.allocated = 0;
	s.data = malloc(DYNAMIC_DATA_SEGMENT_BLOCK_SIZE * sizeof(Pointer));
	memorySegmentMutexCreated = pthread_mutex_init(&memorySegmentMutex, NULL) == PTHREAD_MUTEX_INIT_SUCCESS;
	if(!memorySegmentMutexCreated){
		printTitledError("pthread error", "could not init memory segment mutex");
	}
	if(!s.data){
		printTitledError("memory allocation error", "could not allocate memory for dynamic memory segment");
		ret false;
	}
	(*s.data).data = (void *)1;
	inc s.allocated;
	ret true;
}
PUSHPOINTER(){
	uint32 token = 0;
	jmp checkPointerValidity;
	checkPointerValidity:{
		if(!s.data or !pointer or !memorySegmentMutexCreated){
			ret 0;
		}
		if(pthread_mutex_lock(&memorySegmentMutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
			printTitledError("pthread error", "could not lock pushPointer() mutex");
		}
		jmp appendPointer;
	}
	appendPointer:{
		Pointer *data;
		token = s.allocated;
		if(token == s.size){
			void *temp;
			s.size += DYNAMIC_DATA_SEGMENT_BLOCK_SIZE;
			if(!(temp = realloc(s.data, s.size * sizeof(Pointer)))){
				token = 0;
				jmp emergencyExit;
			}
			s.data = temp;
		}
		data = s.data + token;
		(*data).label = label;
		(*data).data = pointer;
		(*data).token = token;
		(*data).line = line;
		(*data).file = file;
		(*data).free = freeFunction;
		inc s.allocated;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memorySegmentMutexCreated and pthread_mutex_unlock(&memorySegmentMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock pushPointer() mutex");
		}
		ret token;
	}
}
POPPOINTER(){
	jmp checkTokenValidity;
	checkTokenValidity:{
		if(!s.data or !token or !memorySegmentMutexCreated){
			ret;
		}
		if(pthread_mutex_lock(&memorySegmentMutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
			printTitledError("pthread error", "could not lock popPointer() mutex");
		}
		(*(s.data + token)).data = NULL;
		jmp trimSegmentLoop;
	}
	trimSegmentLoop:{
		if(!(*(s.data + dec s.allocated)).data){
			jmp trimSegmentLoop;
		}
		inc s.allocated;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memorySegmentMutexCreated and pthread_mutex_unlock(&memorySegmentMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock popPointer() mutex");
		}
		ret;
	}
}
UPDATEPOINTER(){
	jmp checkTokenValidity;
	checkTokenValidity:{
		if(!s.data or !token or !pointer or !memorySegmentMutexCreated){
			ret;
		}
		if(pthread_mutex_lock(&memorySegmentMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock updatePointer() mutex");
		}
		jmp updatePointer;
	}
	updatePointer:{
		(*(s.data + token)).data = pointer;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memorySegmentMutexCreated and pthread_mutex_unlock(&memorySegmentMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock updatePointer() mutex");
		}
		ret;
	}
}
DELETEMEMORYMANAGER(){
	free(s.data);
	if(memorySegmentMutexCreated){
		if(pthread_mutex_destroy(&memorySegmentMutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy memory segment mutex");
		}
		memorySegmentMutexCreated = false;
	}
	ret;
}
IFREE(){
	free(pointer);
	ret 0;
}
ISHMCTL(){
	#define SHMGET_FAILURE /*-*/ (-1)
	const int shmid = (int64)pointer;
	if(shmid != SHMGET_FAILURE){
		shmctl(shmid, IPC_RMID, NULL);
	}
	ret 0;
	#undef  SHMGET_FAILURE
}
IXCBDISCONNECT(){
	xcb_disconnect(pointer);
	ret 0;
	#undef  s
	#undef  DYNAMIC_DATA_SEGMENT_BLOCK_SIZE
}
SHMINIT(){
	#define STAT_FAILURE /*----*/ (-1)
	#define SHMGET_FAILURE /*--*/ (-1)
	#define SHMAT_FAILURE /*---*/ ((void *)-1)
	#define SHMCTL_FAILURE /*--*/ (-1)
	#define SHMDT_FAILURE /*---*/ (-1)
	#define STAT_PATH /*-------*/ ("/dev/shm/" PROGRAM_NAME)
	#define SHM_KEY /*---------*/ (((s.st_dev << 20) & 0xfff00000) | ((s.st_ino << 8) & 0x000fff00) | 0x00000045)
	#define SHARED_SIZE /*-----*/ (65536)
	#define SHM_HEADER_SIZE /*-*/ (sizeof(pthread_mutex_t) + sizeof(pthread_cond_t) + sizeof(uint8))
	#define SHM_FOOTER_SIZE /*-*/ (2)
	#define SHM_BODY_SIZE /*---*/ (SHM_SIZE - SHM_HEADER_SIZE - SHM_FOOTER_SIZE)
	#define SHM_NONE /*--------*/ (0)
	shmRunning = false;
	shmid = SHMGET_FAILURE;
	shmidToken = 0;
	sharedStart = SHMAT_FAILURE;
	sharedToken = 0;
	sharedMutexCreated = false;
	sharedCondCreated = false;
	sharedThreadCreated = false;
	sharedQuittingThread = false;
	ret;
}
SHMCONNECT(){
	def struct stat /*-*/ Stat;
	FILE *file;
	Stat s;
	shmRunning = true;
	jmp createKeyFile;
	createKeyFile:{
		uint32 token;
		file = fopen(STAT_PATH, "w");
		token = pushPointer(file, "shm file", fclose);
		if(!file){
			file = fopen(STAT_PATH, "r");
			token = pushPointer(file, "shm file", fclose);
			if(!file){
				printError("%s%s: %s%s:%s %s %s %s\n", colorStart, programName, colorError, "shared memory error", colorEnd, "could neither create nor read", STAT_PATH, "file");
				ret;
			}
		}
		fclose(file);
		popPointer(token);
		jmp getKeyFileStat;
	}
	getKeyFileStat:{
		if(stat(STAT_PATH, &s) == STAT_FAILURE){
			printTitledError("shared memory error", "could not generate shared memory key");
			ret;
		}
		jmp createSharedMemory;
	}
	createSharedMemory:{
		shmid = shmget(SHM_KEY, SHARED_SIZE, IPC_CREAT | 0600);
		shmidToken = pushPointer((void *)(int64)shmid, "shm id", ishmctl);
		if(shmid == SHMGET_FAILURE){
			printTitledError("shared memory error", "could not create shared memory segment");
			ret;
		}
		jmp attachToSharedMemory;
	}
	attachToSharedMemory:{
		sharedStart = shmat(shmid, NULL, SHM_NONE);
		sharedToken = pushPointer(sharedStart, "shared memory pointer", shmdt);
		if(sharedStart == SHMAT_FAILURE){
			printTitledError("shared memory error", "could not attach to shared memory");
			ret;
		}
		sharedMutex = (void *)sharedStart;
		sharedCond = (void *)(sharedStart + sizeof(pthread_mutex_t));
		*(sharedStart + SHM_HEADER_SIZE - sizeof(uint8)) = EMPTY_SHARED_STATUS;
		jmp createThreadObjects;
	}
	createThreadObjects:{
		pthread_mutexattr_t mutexAttributes;
		pthread_condattr_t condAttributes;
		if(pthread_mutexattr_init(&mutexAttributes) != PTHREAD_MUTEXATTR_INIT_SUCCESS){
			printTitledError("pthread error", "could not init shared mutex attributes");
		}
		if(pthread_mutexattr_setpshared(&mutexAttributes, PTHREAD_PROCESS_SHARED) != PTHREAD_MUTEXATTR_SETPSHARED_SUCCESS){
			printTitledError("pthread error", "could not set shared mutex shared process attribute");
		}
		sharedMutexCreated = pthread_mutex_init(sharedMutex, &mutexAttributes) == PTHREAD_MUTEX_INIT_SUCCESS;
		if(!sharedMutexCreated){
			printTitledError("pthread error", "could not init shared mutex");
		}
		if(pthread_mutexattr_destroy(&mutexAttributes) != PTHREAD_MUTEXATTR_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy shared mutex attributes");
		}
		if(pthread_condattr_init(&condAttributes) != PTHREAD_CONDATTR_INIT_SUCCESS){
			printTitledError("pthread error", "could not init shared cond attributes");
		}
		if(pthread_condattr_setpshared(&condAttributes, PTHREAD_PROCESS_SHARED) != PTHREAD_CONDATTR_SETPSHARED_SUCCESS){
			printTitledError("pthread error", "could not set shared cond shared process attribute");
		}
		sharedCondCreated = pthread_cond_init(sharedCond, &condAttributes) == PTHREAD_COND_INIT_SUCCESS;
		if(!sharedCondCreated){
			printTitledError("pthread error", "could not init shared cond");
		}
		if(pthread_condattr_destroy(&condAttributes) != PTHREAD_CONDATTR_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy shared cond attributes");
		}
		sharedThreadCreated = pthread_create(&sharedThread, NULL, shmMain, NULL) == PTHREAD_CREATE_SUCCESS;
		if(!sharedThreadCreated){
			printTitledError("pthread error", "could not create shared memory thread");
		}
		ret;
	}
}
SHMMAIN(){
	(void)arg;
	if(pthread_mutex_lock(sharedMutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock shared mutex");
	}
	jmp waitIndefinitely;
	waitIndefinitely:{
		if(pthread_cond_wait(sharedCond, sharedMutex) != PTHREAD_COND_WAIT_SUCCESS){
			printTitledError("pthread error", "could not wait shared mutex");
		}
		sharedCurrent = sharedStart + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t);
		if(sharedQuittingThread){
			*sharedCurrent = FULL_SHARED_STATUS;
			if(pthread_mutex_unlock(sharedMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock shared mutex");
			}
			ret NULL;
		}
		if(*sharedCurrent == FULL_SHARED_STATUS){
			if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
				printTitledError("pthread error", "could not lock globals write lock");
			}
			*sharedCurrent = EMPTY_SHARED_STATUS;
			inc sharedCurrent;
			readConfig(false, "transmitter", getSharedCharacter);
			if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock globals write lock");
			}
			*(sharedStart + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t)) = EMPTY_SHARED_STATUS;
		}
		jmp waitIndefinitely;
	}
}
SHMDISCONNECT(){
	if(!shmRunning){
		ret;
	}
	shmRunning = false;
	jmp destroyThreadObjects;
	destroyThreadObjects:{
		sharedQuittingThread = true;
		if(sharedThreadCreated){
			if(sharedMutexCreated and sharedCondCreated){
				if(pthread_mutex_lock(sharedMutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
					printTitledError("pthread error", "could not lock shared mutex");
				}
				if(pthread_cond_signal(sharedCond) != PTHREAD_COND_SIGNAL_SUCCESS){
					printTitledError("pthread error", "could not signal shared thread");
				}
				if(pthread_mutex_unlock(sharedMutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock shared mutex");
				}
			}
			if(pthread_join(sharedThread, NULL) != PTHREAD_JOIN_SUCCESS){
				printTitledError("pthread error", "could not join shared thread");
			}
			sharedThreadCreated = false;
		}
		if(sharedCond and sharedCondCreated){
			if(pthread_cond_destroy(sharedCond) != PTHREAD_COND_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy shared cond");
			}
			sharedCondCreated = false;
		}
		if(sharedMutex and sharedMutexCreated){
			if(pthread_mutex_destroy(sharedMutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy shared mutex");
			}
			sharedMutexCreated = false;
		}
		jmp markForDeletion;
	}
	markForDeletion:{
		if(shmid != SHMGET_FAILURE and shmctl(shmid, IPC_RMID, NULL) == SHMCTL_FAILURE){
			printTitledError("shared memory error", "could not mark shared memory for deletion");
			ret;
		}
		popPointer(shmidToken);
		shmid = SHMGET_FAILURE;
		shmidToken = 0;
		jmp detach;
	}
	detach:{
		if(sharedStart != SHMAT_FAILURE and shmdt(sharedStart) == SHMDT_FAILURE){
			printTitledError("shared memory error", "could not detach from shared memory");
			ret;
		}
		popPointer(sharedToken);
		sharedStart = SHMAT_FAILURE;
		sharedToken = 0;
		ret;
	}
	#undef  SHM_NONE
	#undef  SHM_BODY_SIZE
	#undef  SHM_FOOTER_SIZE
	#undef  SHM_HEADER_SIZE
	#undef  SHARED_SIZE
	#undef  SHM_KEY
	#undef  STAT_PATH
	#undef  SHMDT_FAILURE
	#undef  SHMCTL_FAILURE
	#undef  SHMAT_FAILURE
	#undef  SHMGET_FAILURE
	#undef  STAT_FAILURE
}
IDENTIFYARGUMENT(){
	if(*p != '-') jmp findValueArgument;
	inc p;
	if(*p != '-') jmp findShortArgument;
	inc p;
	jmp findLongArgument;
	findValueArgument:{
		if(insensitiveStringCompare("stdout", p)) /*-*/ ret STDOUT_ARGUMENT;
		if(insensitiveStringCompare("stderr", p)) /*-*/ ret STDERR_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
	findShortArgument:{
		if(insensitiveStringCompare("h", p)) /*------*/ ret HELP_ARGUMENT;
		if(insensitiveStringCompare("c", p)) /*------*/ ret CONFIG_ARGUMENT;
		if(insensitiveStringCompare("e", p)) /*------*/ ret ERROR_ARGUMENT;
		if(insensitiveStringCompare("s", p)) /*------*/ ret SERVER_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
	findLongArgument:{
		if(insensitiveStringCompare("help", p)) /*---*/ ret HELP_ARGUMENT;
		if(insensitiveStringCompare("config", p)) /*-*/ ret CONFIG_ARGUMENT;
		if(insensitiveStringCompare("error", p)) /*--*/ ret ERROR_ARGUMENT;
		if(insensitiveStringCompare("server", p)) /*-*/ ret SERVER_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
}
INSENSITIVESTRINGCOMPARE(){
	jmp compareCharacterLoop;
	compareCharacterLoop:{
		char c1 = *s1;
		c1 |= 32 * (c1 >= 'A' and c1 <= 'Z');
		if(*s0 != c1) /*-*/ ret false;
		if(!c1) /*-------*/ ret true;
		inc s0;
		inc s1;
		jmp compareCharacterLoop;
	}
}
SENSITIVESTRINGCOMPARE(){
	jmp compareCharacterLoop;
	compareCharacterLoop:{
		if(*s0 != *s1) /*-*/ ret false;
		if(!*s0) /*-------*/ ret true;
		inc s0;
		inc s1;
		jmp compareCharacterLoop;
	}
}
SETSTRINGROOT(){
	#define DATA_BLOCK_SIZE /*-*/ (256)
	(*root).dataSize = DATA_BLOCK_SIZE;
	(*root).dataAllocated = 0;
	(*root).dataStart = malloc(DATA_BLOCK_SIZE * sizeof(StringNode));
	(*root).dataToken = pushPointer((*root).dataStart, "string tree pointer", iFree);
	(*root).counter = 1;
	(*root).letter = 0;
	(*root).childrenAmount = 0;
	if(!(*root).dataStart){
		printTitledError("memory allocation error", "could not allocate memory for a string tree");
		(*root).dataSize = 0;
	}
	ret;
}
BULKINSERTSTRING(){
	jmp confirmRootValidity;
	confirmRootValidity:{
		if(!(*root).dataStart){
			ret;
		}
		(*root).stringArray = current;
		jmp insertStringLoop;
	}
	insertStringLoop:{
		if(insertString(root, *current) and *(inc current)){
			jmp insertStringLoop;
		}
		jmp trimMemory;
	}
	trimMemory:{
		void *temp;
		(*root).dataSize = (*root).dataAllocated;
		temp = realloc((*root).dataStart, (*root).dataSize * sizeof(StringNode));
		updatePointer((*root).dataToken, temp);
		if(!temp){
			ret;
		}
		(*root).dataStart = temp;
		ret;
	}
}
INSERTSTRING(){
	StringNode *node;
	uint allocated = (*root).dataAllocated;
	uint size = (*root).dataSize;
	StringNode *data = (*root).dataStart;
	jmp findString;
	findString:{
		if(!(node = getStringNode(root, &string))){
			ret false;
		}
		jmp addLetterLoop;
	}
	addLetterLoop:{
		if(allocated == size){
			const uint nodeOffset = node - data;
			void *temp;
			size += DATA_BLOCK_SIZE;
			temp = realloc(data, size * sizeof(StringNode));
			updatePointer((*root).dataToken, temp);
			if(!temp){
				printTitledError("memory allocation error", "could not reallocate memory for string tree nodes");
				size -= DATA_BLOCK_SIZE;
				(*node).letter = b(10000000) | (*root).counter;
				inc (*root).counter;
				(*root).dataStart = data;
				(*root).dataSize = size;
				(*root).dataAllocated = allocated;
				ret false;
			}
			data = temp;
			if(node != (void *)&(*root).letter){
				node = data + nodeOffset;
			}
		}
		if((*node).childrenAmount >= STRING_NODE_CHILDREN_AMOUNT){
			printTitledError("insert string error", "out of space for new children in string node");
			ret false;
		}
		*((*node).offset + (*node).childrenAmount) = allocated;
		inc (*node).childrenAmount;
		node = data + allocated;
		(*node).childrenAmount = 0;
		inc allocated;
		if(*string){
			(*node).letter = *string;
			inc string;
			jmp addLetterLoop;
		}
		(*node).letter = b(10000000) | (*root).counter;
		inc (*root).counter;
		(*root).dataStart = data;
		(*root).dataSize = size;
		(*root).dataAllocated = allocated;
		ret true;
	}
}
GETSTRINGNODE(){
	const uint16 *offsetCurrent;
	const uint16 *offsetWall;
	const char *string;
	StringNode *node;
	StringNode *data;
	char c;
	jmp confirmRootValidity;
	confirmRootValidity:{
		if(!(*root).dataStart){
			ret NULL;
		}
		string = *stringReturn;
		node = (void *)&(*root).letter;
		data = (*root).dataStart;
		jmp findLetterLoop;
	}
	findLetterLoop:{
		offsetCurrent = (*node).offset;
		offsetWall = offsetCurrent + (*node).childrenAmount;
		c = *string;
		c += (c >= 'A' and c <= 'Z') * 32 - (c == '_') * 50;
		jmp nextLetterLoop;
	}
	nextLetterLoop:{
		if(offsetCurrent < offsetWall){
			StringNode *const n = data + *offsetCurrent;
			if(!c and (*n).letter & b(10000000)){
				(*root).returnedCounter = ((*n).letter & ~b(10000000)) - 1;
				*stringReturn = string;
				ret NULL;
			}
			if((*n).letter != c){
				inc offsetCurrent;
				jmp nextLetterLoop;
			}
			node = n;
			inc string;
			jmp findLetterLoop;
		}
		*stringReturn = string;
		ret node;
	}
}
DELETESTRINGROOT(){
	free((*root).dataStart);
	popPointer((*root).dataToken);
	ret;
	#undef  DATA_BLOCK_SIZE
}
SETSHORTCUTROOT(){
	#define MODIFIER_DATA_BLOCK_SIZE /*-*/ (32)
	(*root).modifierSize = MODIFIER_DATA_BLOCK_SIZE;
	(*root).modifierAllocated = 1;
	(*root).modifierNotInUseOffset = 1;
	(*root).modifierStart = malloc((*root).modifierSize * sizeof(ModifierNode));
	(*root).modifierToken = pushPointer((*root).modifierStart, "shortcut modifier list pointer", iFree);
	if(!(*root).modifierStart){
		printTitledError("memory allocation error", "could not allocate shortcut modifier memory");
		(*root).modifierSize = 1;
		jmp emergencyExit;
	}
	{
		uint32 *codeListStartCurrent = (*root).codeListStart;
		uint32 *codeListWallCurrent = (*root).codeListWall;
		uint32 *const codeListStartWall = codeListStartCurrent + SHORTCUT_CODE_AMOUNT;
		jmp initializeCodeListsLoop;
		initializeCodeListsLoop:{
			*codeListStartCurrent = 0;
			*codeListWallCurrent = 0;
			if(inc codeListStartCurrent < codeListStartWall){
				inc codeListWallCurrent;
				jmp initializeCodeListsLoop;
			}
			ret;
		}
	}
	emergencyExit:{
		(*root).modifierSize = 0;
		free((*root).modifierStart);
		popPointer((*root).modifierToken);
		ret;
	}
}
INSERTSHORTCUT(){
	ModifierNode *node;
	if((*root).modifierAllocated == (*root).modifierSize){
		void *temp;
		(*root).modifierSize += MODIFIER_DATA_BLOCK_SIZE;
		temp = realloc((*root).modifierStart, (*root).modifierSize * sizeof(ModifierNode));
		updatePointer((*root).modifierToken, temp);
		if(!temp){
			printTitledError("memory allocation error", "could not reallocate memory for shortcuts");
			(*root).modifierSize -= MODIFIER_DATA_BLOCK_SIZE;
			ret false;
		}
		(*root).modifierStart = temp;
	}
	node = (*root).modifierStart + (*root).modifierNotInUseOffset;
	(*node).inUse = true;
	(*node).command = command;
	(*node).modifier = modifier;
	(*node).nextOffset = 0;
	(*node).string = string;
	(*node).stringToken = stringToken;
	(*node).field0 = field0;
	(*node).field1 = field1;
	(*node).field2 = field2;
	(*node).field3 = field3;
	(*node).field4 = field4;
	if(!*((*root).codeListStart + code)){
		*((*root).codeListStart + code) = (*root).modifierNotInUseOffset;
	}else{
		const uint offset = *((*root).codeListWall + code);
		(*((*root).modifierStart + offset)).nextOffset = (*root).modifierNotInUseOffset - offset;
	}
	*((*root).codeListWall + code) = (*root).modifierNotInUseOffset;
	if((*root).modifierNotInUseOffset == (*root).modifierAllocated){
		inc (*root).modifierAllocated;
		inc (*root).modifierNotInUseOffset;
	}else{
		const ModifierNode *current = node + 1;
		const ModifierNode *const wall = (*root).modifierStart + (*root).modifierAllocated;
		jmp findNextAvailableModifierNodeSlotLoop;
		findNextAvailableModifierNodeSlotLoop:{
			if(current < wall and (*current).inUse){
				inc current;
				jmp findNextAvailableModifierNodeSlotLoop;
			}
			(*root).modifierNotInUseOffset = current - (*root).modifierStart;
		}
	}
	ret true;
}
GETNEXTSHORTCUT(){
	const ModifierNode *current = (*root).modifierStart;
	int offset;
	if(!*nextOffset){
		offset = *((*root).codeListStart + code);
		jmp findShortcutModifierLoop;
	}
	code = shortcutCode;
	modifier = shortcutModifier;
	offset = *nextOffset;
	jmp findShortcutModifierLoop;
	findShortcutModifierLoop:{
		if(offset){
			current += offset;
			if((*current).modifier == modifier){
				shortcutCode = code;
				shortcutModifier = modifier;
				eventModifierNode = current;
				if((*current).nextOffset){
					*nextOffset = current - (*root).modifierStart + (*current).nextOffset;
					ret true;
				}
				*nextOffset = 0;
				ret true;
			}
			offset = (*current).nextOffset;
			jmp findShortcutModifierLoop;
		}
		*nextOffset = 0;
		ret false;
	}
}
REMOVESHORTCUT(){
	ModifierNode *const modifierStart = (*root).modifierStart;
	ModifierNode *node = modifierStart + *((*root).codeListStart + code);
	bool hasRemovedShortcut = false;
	if(node > modifierStart){
		ModifierNode *previousNode = NULL;
		uint modifierAllocated = (*root).modifierAllocated;
		uint modifierNotInUseOffset = (*root).modifierNotInUseOffset;
		jmp removeModifierLoop;
		removeModifierLoop:{
			const int nextOffset = (*node).nextOffset;
			if(modifier == (*node).modifier){
				(*node).inUse = false;
				free((*node).string);
				popPointer((*node).stringToken);
				if(!previousNode){
					*((*root).codeListStart + code) = !!nextOffset * *((*root).codeListStart + code) + nextOffset;
				}else{
					(*previousNode).nextOffset = !!nextOffset * (*previousNode).nextOffset + nextOffset;
				}
				if(node == modifierStart + modifierAllocated - 1){
					if(dec modifierAllocated < modifierNotInUseOffset){
						dec modifierNotInUseOffset;
					}
				}elif(node - modifierStart < modifierNotInUseOffset){
					modifierNotInUseOffset = node - modifierStart;
				}
				hasRemovedShortcut = true;
			}
			if(nextOffset){
				previousNode = node;
				node += nextOffset;
				jmp removeModifierLoop;
			}
			(*root).modifierAllocated = modifierAllocated;
			(*root).modifierNotInUseOffset = modifierNotInUseOffset;
		}
	}
	ret hasRemovedShortcut;
}
UNSETSHORTCUTROOT(){
	if((*root).modifierAllocated > 1){
		const ModifierNode *current = (*root).modifierStart + 1;
		const ModifierNode *const wall = (*root).modifierStart + (*root).modifierAllocated;
		jmp freeStringLoop;
		freeStringLoop:{
			if(current < wall){
				if((*current).inUse){
					free((*current).string);
					popPointer((*current).stringToken);
				}
				inc current;
				jmp freeStringLoop;
			}
		}
	}
	free((*root).modifierStart);
	popPointer((*root).modifierToken);
	ret;
	#undef  MODIFIER_DATA_BLOCK_SIZE
}
UNGRABSHORTCUTS(){
	if(connection){
		if(keycodeShortcut.modifierAllocated > 1){
			xcb_ungrab_key(connection, XCB_GRAB_ANY, (*screen).root, XCB_MOD_MASK_ANY);
		}
		if(buttonShortcut.modifierAllocated > 1){
			xcb_ungrab_button(connection, XCB_BUTTON_INDEX_ANY, (*screen).root, XCB_MOD_MASK_ANY);
		}
	}
	ret;
}
RANDRQUERYVERSIONUNCHECKED(){
	xcb_void_cookie_t cookie;
	cookie.sequence = xcb_randr_query_version_unchecked(connection, majorVersion, minorVersion).sequence;
	ret cookie;
}
SETASCIISTRINGROOT(){
	#define DATA_BLOCK_SIZE /*--------------*/ (16384)
	#define UTF8_STRING_BLOCK_SIZE /*-------*/ (16)
	#define FOUND_STRINGS_BLOCK_SIZE /*-----*/ (512)
	#define NONE_ASCII_STRING_NODE /*-------*/ (0)
	#define COMPLETE_ASCII_STRING_NODE /*---*/ (1)
	#define INCOMPLETE_ASCII_STRING_NODE /*-*/ (2)
	(*root).dataSize = DATA_BLOCK_SIZE;
	(*root).dataAllocated = 1;
	(*root).dataStart = malloc(DATA_BLOCK_SIZE * sizeof(ASCIIStringNode));
	(*root).dataToken = pushPointer((*root).dataStart, "ascii string tree pointer", iFree);
	(*root).utf8StringAmount = 0;
	(*root).utf8StringSize = UTF8_STRING_BLOCK_SIZE;
	(*root).utf8StringAllocated = 0;
	(*root).utf8StringStart = malloc((*root).stringsFoundSize * sizeof(uint8));
	(*root).utf8StringToken = pushPointer((*root).utf8StringStart, "utf-8 string pointer", iFree);
	(*root).stringsFoundAmount = 0;
	(*root).stringsFoundSize = 0;
	(*root).stringsFoundAllocated = 0;
	(*root).stringsFoundStart = NULL;
	(*root).stringsFoundToken = 0;
	if(!(*root).dataStart){
		printTitledError("memory allocation error", "could not allocate memory for a ascii string tree");
		ret;
	}
	if(!(*root).utf8StringStart){
		printTitledError("memory allocation error", "could not allocate memory for utf8 strings");
		ret;
	}
	setMemory((*root).dataStart, 0, DATA_BLOCK_SIZE * sizeof(ASCIIStringNode) / sizeof(uint64), sizeof(uint64));
	ret;
}
PATHINSERTSTRING(){
	char *pathStart = getenv(path);
	if(pathStart and *pathStart){
		char *pathCurrent = pathStart;
		uint i = 1;
		jmp getPathNameLoop;
		getPathNameLoop:{
			DIR *dir;
			uint32 dirToken;
			char lastChar;
			if(*pathCurrent != ':' and *pathCurrent != '\0'){
				inc pathCurrent;
				jmp getPathNameLoop;
			}
			lastChar = *pathCurrent;
			*pathCurrent = '\0';
			dir = opendir(pathStart);
			dirToken = pushPointer(pathStart, "executable path pointer", closedir);
			if(dir){
				jmp storeDirectoryNameLoop;
				storeDirectoryNameLoop:{
					struct dirent *entry;
					if((entry = readdir(dir))){
						const char *const name = (*entry).d_name;
						if(*name == '.' and (*(name + 1) == '\0' or (*(name + 1) == '.' and *(name + 2) == '\0'))){
							jmp storeDirectoryNameLoop;
						}
						if((*entry).d_type != DT_LNK and (*entry).d_type != DT_REG){
							jmp storeDirectoryNameLoop;
						}
						if(isASCIIString(name)){
							const char *n = name;
							insertASCIIString(root, n);
							n = name;
						}
						jmp storeDirectoryNameLoop;
					}
					closedir(dir);
					popPointer(dirToken);
				}
			}
			*pathCurrent = lastChar;
			if(*pathCurrent == ':'){
				inc pathCurrent;
			}
			if(*pathCurrent){
				inc i;
				pathStart = pathCurrent;
				jmp getPathNameLoop;
			}
		}
	}
	ret;
}
ISASCIISTRING(){
	jmp loop;
	loop:{
		if(*(uint8 *)string == b(00000000)) ret true;
		if(*(uint8 *)string >= b(10000000)) ret false;
		string = (uint8 *)string + 1;
		jmp loop;
	}
}
INSERTASCIISTRING(){
	ASCIIStringNode *data = (*root).dataStart;
	ASCIIStringNode *node;
	uint allocated = (*root).dataAllocated;
	uint size = (*root).dataSize;
	jmp getNode;
	getNode: switch getASCIIStringNode(root, false, &string, &node) over
		to COMPLETE_ASCII_STRING_NODE: /*---*/ ret false;
		to INCOMPLETE_ASCII_STRING_NODE: /*-*/ jmp insertNodeLoop;
		off: /*-----------------------------*/ ret false;
	end
	insertNodeLoop:{
		char c;
		uint parentOffset;
		if(allocated == size){
			const uint nodeOffset = node - data;
			void *temp;
			size += DATA_BLOCK_SIZE;
			temp = realloc(data, size * sizeof(ASCIIStringNode));
			updatePointer((*root).dataToken, temp);
			if(!temp){
				printTitledError("memory allocation error", "could not reallocate memory for a ascii string nodes");
				size -= DATA_BLOCK_SIZE;
				(*root).dataStart = data;
				(*root).dataSize = size;
				(*root).dataAllocated = allocated;
				ret false;
			}
			data = temp;
			node = data + nodeOffset;
			setMemory(data + size - DATA_BLOCK_SIZE, 0, DATA_BLOCK_SIZE * sizeof(ASCIIStringNode) / sizeof(uint64), sizeof(uint64));
		}
		c = *string;
		parentOffset = node - data;
		*((*node).childOffset + c) = allocated;
		inc (*node).childrenAmount;
		node = data + allocated;
		(*node).parentOffset = parentOffset;
		inc allocated;
		if(c){
			(*node).letter = c;
			inc string;
			jmp insertNodeLoop;
		}
		(*node).letter = b(10000000);
		(*root).dataStart = data;
		(*root).dataSize = size;
		(*root).dataAllocated = allocated;
		ret true;
	}
}
GETASCIISTRINGNODE(){
	const uint32 *childOffsetCurrent;
	const uint32 *childOffsetWall;
	const char *string = *stringReturn;
	ASCIIStringNode *const data = (*root).dataStart;
	ASCIIStringNode *node = data;
	uint8 counter;
	uint8 childrenAmount;
	char c;
	jmp confirmRootValidity;
	confirmRootValidity:{
		if(!data){
			ret NONE_ASCII_STRING_NODE;
		}
		jmp getChildNode;
	}
	getChildNode:{
		childOffsetCurrent = (*node).childOffset;
		childOffsetWall = childOffsetCurrent + countof((*node).childOffset);
		counter = 0;
		childrenAmount = (*node).childrenAmount;
		c = *string;
		jmp findChildNodeLoop;
	}
	findChildNodeLoop:{
		if(childOffsetCurrent < childOffsetWall){
			ASCIIStringNode *child;
			if(!*childOffsetCurrent){
				inc childOffsetCurrent;
				jmp findChildNodeLoop;
			}
			child = data + *childOffsetCurrent;
			inc counter;
			if((*child).letter == c){
				node = child;
				inc string;
				jmp getChildNode;
			}
			if(!c and (*child).letter == b(10000000)){
				*stringReturn = string;
				if(nodeReturn){
					*nodeReturn = node;
				}
				ret COMPLETE_ASCII_STRING_NODE;
			}
			if(counter <= childrenAmount){
				inc childOffsetCurrent;
				jmp findChildNodeLoop;
			}
		}
		if(findExact and c){
			ret NONE_ASCII_STRING_NODE;
		}
		*stringReturn = string;
		if(nodeReturn){
			*nodeReturn = node;
		}
		ret INCOMPLETE_ASCII_STRING_NODE;
	}
}
GETMULTIPLEASCIISTRINGNODES(){
	const uint32 *childOffsetCurrent;
	ASCIIStringNode *const data = (*root).dataStart;
	ASCIIStringNode *node = data;
	uint8 bufferStart[256];
	uint8 *bufferCurrent = bufferStart;
	uint returnStringsFoundAmount;
	uint returnStringsFoundSize;
	uint returnStringsFoundAllocated;
	uint8 *returnStringsFoundStart;
	uint8 *returnStringsFoundCurrent;
	uint32 returnStringsFoundToken;
	free((*root).stringsFoundStart);
	popPointer((*root).stringsFoundToken);
	(*root).stringsFoundAmount = 0;
	(*root).stringsFoundStart = NULL;
	(*root).stringsFoundToken = 0;
	jmp getNode;
	getNode:{
		const char *string = prefix;
		switch getASCIIStringNode(root, true, &string, &node) over
			to COMPLETE_ASCII_STRING_NODE: /*---*/ jmp prefixFound;
			to INCOMPLETE_ASCII_STRING_NODE: /*-*/ jmp prefixFound;
			off: /*-----------------------------*/ ret false;
		end
	}
	prefixFound:{
		if(node > data){
			(*(data + (*node).parentOffset)).counter = countof((*node).childOffset);
		}
		(*node).counter = 0;
		childOffsetCurrent = (*node).childOffset;
		jmp copyPrefixLoop;
		copyPrefixLoop:{
			if(*prefix){
				*bufferCurrent = *prefix;
				inc bufferCurrent;
				inc prefix;
				jmp copyPrefixLoop;
			}
			*bufferCurrent = '\0';
			returnStringsFoundAmount = 0;
			returnStringsFoundSize = FOUND_STRINGS_BLOCK_SIZE;
			returnStringsFoundAllocated = 0;
			returnStringsFoundStart = malloc(returnStringsFoundSize * sizeof(uint8));
			returnStringsFoundCurrent = returnStringsFoundStart;
			returnStringsFoundToken = pushPointer(returnStringsFoundStart, "getMultipleASCIIStringNodes() ascii string pointer", iFree);
			if(!returnStringsFoundStart){
				ret false;
			}
			jmp nextLetterLoop;
		}
	}
	nextLetterLoop:{
		if(childOffsetCurrent < (*node).childOffset + countof((*node).childOffset)){
			ASCIIStringNode *child;
			if(!*childOffsetCurrent){
				inc childOffsetCurrent;
				inc (*node).counter;
				jmp nextLetterLoop;
			}
			inc (*node).counter;
			child = data + *childOffsetCurrent;
			if((*child).letter == b(10000000)){
				uint8 *current = bufferStart;
				*bufferCurrent = '\0';
				if(returnStringsFoundAllocated == returnStringsFoundSize){
					const uint offset = returnStringsFoundCurrent - returnStringsFoundStart;
					void *temp;
					returnStringsFoundSize += FOUND_STRINGS_BLOCK_SIZE;
					temp = realloc(returnStringsFoundStart, returnStringsFoundSize * sizeof(uint8));
					updatePointer(returnStringsFoundToken, temp);
					if(!temp){
						printTitledError("memory allocation error", "could not reallocate memory for matched ascii strings");
						returnStringsFoundSize -= FOUND_STRINGS_BLOCK_SIZE;
						jmp emergencyExit;
					}
					returnStringsFoundStart = temp;
					returnStringsFoundCurrent = returnStringsFoundStart + offset;
				}
				*returnStringsFoundCurrent = bufferCurrent - bufferStart;
				inc returnStringsFoundCurrent;
				inc returnStringsFoundAllocated;
				jmp copyNameLoop;
				copyNameLoop:{
					if(returnStringsFoundAllocated == returnStringsFoundSize){
						const uint offset = returnStringsFoundCurrent - returnStringsFoundStart;
						void *temp;
						returnStringsFoundSize += FOUND_STRINGS_BLOCK_SIZE;
						temp = realloc(returnStringsFoundStart, returnStringsFoundSize * sizeof(uint8));
						updatePointer(returnStringsFoundToken, temp);
						if(!temp){
							printTitledError("memory allocation error", "could not reallocate memory for matched ascii strings");
							returnStringsFoundSize -= FOUND_STRINGS_BLOCK_SIZE;
							jmp emergencyExit;
						}
						returnStringsFoundStart = temp;
						returnStringsFoundCurrent = returnStringsFoundStart + offset;
					}
					*returnStringsFoundCurrent = *current;
					inc returnStringsFoundCurrent;
					inc returnStringsFoundAllocated;
					if(*current){
						inc current;
						jmp copyNameLoop;
					}
					dec bufferCurrent;
					node = data + (*node).parentOffset;
					childOffsetCurrent = (*node).childOffset + (*node).counter;
					if(inc returnStringsFoundAmount == amount){
						jmp emergencyExit;
					}
					jmp nextLetterLoop;
				}
			}
			*bufferCurrent = (*child).letter;
			inc bufferCurrent;
			node = child;
			(*node).counter = 0;
			childOffsetCurrent = (*node).childOffset + (*node).counter;
			jmp nextLetterLoop;
		}
		node = data + (*node).parentOffset;
		if((*node).counter < countof((*node).childOffset)){
			dec bufferCurrent;
			childOffsetCurrent = (*node).childOffset + (*node).counter;
			jmp nextLetterLoop;
		}
		jmp emergencyExit;
	}
	emergencyExit:{
		(*root).stringsFoundAmount = returnStringsFoundAmount;
		(*root).stringsFoundSize = returnStringsFoundSize;
		(*root).stringsFoundAllocated = returnStringsFoundAllocated;
		(*root).stringsFoundStart = returnStringsFoundStart;
		(*root).stringsFoundToken = returnStringsFoundToken;
		ret true;
	}
}
DELETEASCIISTRINGROOT(){
	free((*root).stringsFoundStart);
	popPointer((*root).stringsFoundToken);
	free((*root).utf8StringStart);
	popPointer((*root).utf8StringToken);
	free((*root).dataStart);
	popPointer((*root).dataToken);
	ret;
	#undef  INCOMPLETE_ASCII_STRING_NODE
	#undef  COMPLETE_ASCII_STRING_NODE
	#undef  NONE_ASCII_STRING_NODE
	#undef  FOUND_STRINGS_BLOCK_SIZE
	#undef  UTF8_STRING_BLOCK_SIZE
	#undef  DATA_BLOCK_SIZE
}
SETCONFIGVARIABLES(){
	setElementPreferences(&windowPreferences);
	setElementPreferences(&inputPreferences);
	setElementPreferences(&inputContentPreferences);
	setElementPreferences(&resultPreferences);
	setElementPreferences(&resultContentPreferences);
	windowCirclePixmap = XCB_NONE;
	whichMonitor = NONE_WHICH_MONITOR;
	font = XCB_NONE;
	maximumResultAmount = 0;
	resultAllowCircularNavigation = false;
	ret;
}
SETELEMENTPREFERENCES(){
	(*preferences).x = 0;
	(*preferences).y = 0;
	(*preferences).xOffset = 0;
	(*preferences).yOffset = 0;
	(*preferences).width = 0;
	(*preferences).height = 0;
	(*preferences).xType = NONE_NUMBER_TYPE;
	(*preferences).yType = NONE_NUMBER_TYPE;
	(*preferences).xOffsetType = NONE_NUMBER_TYPE;
	(*preferences).yOffsetType = NONE_NUMBER_TYPE;
	(*preferences).widthType = NONE_NUMBER_TYPE;
	(*preferences).heightType = NONE_NUMBER_TYPE;
	(*preferences).horizontalAlignment = NONE_HORIZONTAL_ALIGNMENT;
	(*preferences).verticalAlignment = NONE_VERTICAL_ALIGNMENT;
	(*preferences).padding = 0;
	(*preferences).margin = 0;
	(*preferences).gap = 0;
	(*preferences).cornerRadius = 0;
	(*preferences).cornerUsed = NONE_CORNER_USED;
	(*preferences).foreground = 0x00000000;
	(*preferences).background = 0x00000000;
	(*preferences).selectedForeground = 0x00000000;
	(*preferences).selectedBackground = 0x00000000;
	ret;
}
READCONFIG(){
	#define STATEMENT_BLOCK_SIZE /*-*/ (256)
	#define DEFAULT_CONFIG_PATH /*--*/ ("/etc/" PROGRAM_NAME "/" PROGRAM_NAME ".conf")
	const Instruction *const *currentScopeInstruction = globalScopeInstruction;
	const char *const *currentScopeInstructionList = globalInstructionList;
	const Instruction *instructionStart;
	const Instruction *instructionStartCopy;
	const Instruction *instructionCurrent;
	const Instruction *name0Instruction;
	const Instruction *name1Instruction;
	const Instruction *name2Instruction;
	const Instruction *name3Instruction;
	const Instruction *name4Instruction;
	const Instruction *nameList0Instruction;
	const Instruction *nameList1Instruction;
	const Instruction *nameList2Instruction;
	const Instruction *nameList3Instruction;
	const Instruction *nameList4Instruction;
	const Instruction *integer0Instruction;
	const Instruction *integer1Instruction;
	const Instruction *integer2Instruction;
	const Instruction *integer3Instruction;
	const Instruction *integer4Instruction;
	const Instruction *string0Instruction;
	const Instruction *string1Instruction;
	const Instruction *string2Instruction;
	const Instruction *string3Instruction;
	const Instruction *string4Instruction;
	const Instruction *execute0Instruction;
	const Instruction *execute1Instruction;
	const Instruction *execute2Instruction;
	const Instruction *execute3Instruction;
	const Instruction *execute4Instruction;
	const Instruction *image0Instruction;
	const Instruction *image1Instruction;
	const Instruction *image2Instruction;
	const Instruction *image3Instruction;
	const Instruction *image4Instruction;
	const char *imageErrorMessage;
	FILE *configFile = NULL;
	uint32 configFileToken;
	uint statementSize = STATEMENT_BLOCK_SIZE;
	char *statementStart = NULL;
	uint32 statementToken = 0;
	char *statementCurrent;
	char *statementWall = NULL;
	char *statementConcreteWall;
	uint8 name0Return;
	uint8 name1Return;
	uint8 name2Return;
	uint8 name3Return;
	uint8 name4Return;
	uint8 nameList0Return;
	uint8 nameList1Return;
	uint8 nameList2Return;
	uint8 nameList3Return;
	uint8 nameList4Return;
	int64 integer0Return;
	int64 integer1Return;
	int64 integer2Return;
	int64 integer3Return;
	int64 integer4Return;
	char *string0Return = NULL;
	uint32 string0Token = 0;
	char *string1Return = NULL;
	uint32 string1Token = 0;
	char *string2Return = NULL;
	uint32 string2Token = 0;
	char *string3Return = NULL;
	uint32 string3Token = 0;
	char *string4Return = NULL;
	uint32 string4Token = 0;
	char *execute0Return = NULL;
	uint32 execute0Token = 0;
	char *execute1Return = NULL;
	uint32 execute1Token = 0;
	char *execute2Return = NULL;
	uint32 execute2Token = 0;
	char *execute3Return = NULL;
	uint32 execute3Token = 0;
	char *execute4Return = NULL;
	uint32 execute4Token = 0;
	Image image0Return;
	Image image1Return;
	Image image2Return;
	Image image3Return;
	Image image4Return;
	JmpPoint jmpPoint;
	uint fileLine = 1;
	uint statementLine = 0;
	char fileChar;
	uint itemAmount;
	char quote = '\0';
	uint currentScopeInstructionListSize = countof(globalInstructionList) - 1;
	StringNodeRoot *const *const *currentScopeInstructionData = globalScopeInstructionData;
	StringNodeRoot *const *instructionDataStart;
	StringNodeRoot *const *instructionDataStartCopy;
	StringNodeRoot *const *instructionDataCurrent;
	StringNodeRoot *currentScopeInstructionRoot = &globalInstructionRoot;
	image0Return.dataStart = NULL;
	image0Return.dataToken = 0;
	image1Return.dataStart = NULL;
	image1Return.dataToken = 0;
	image2Return.dataStart = NULL;
	image2Return.dataToken = 0;
	image3Return.dataStart = NULL;
	image3Return.dataToken = 0;
	image4Return.dataStart = NULL;
	image4Return.dataToken = 0;
	jmp setupPointers;
	setupPointers:{
		if(getConfigChar == fgetc){
			if(!createConfigFile){
				DIR *const dir = opendir(configPath);
				uint32 token = pushPointer(dir, "config directory argument", closedir);
				if(dir){
					closedir(dir);
					popPointer(token);
					printConfigError("config error", "config file is directory", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
					jmp configEmergencyExit;
				}
			}
			configFile = fopen(configPath, "r");
			configFileToken = pushPointer(configFile, "config file", fclose);
			if(!configFile){
				#define BUFFER_SIZE /*-*/ (4096)
				FILE *defaultConfigFile;
				uint32 defaultConfigFileToken;
				if(!createConfigFile){
					printConfigError("config error", "could not open config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
					jmp configEmergencyExit;
				}
				configFile = fopen(configPath, "w");
				configFileToken = pushPointer(configFile, "config file", fclose);
				if(!configFile){
					printConfigError("config error", "could not create config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
					jmp configEmergencyExit;
				}
				defaultConfigFile = fopen(DEFAULT_CONFIG_PATH, "r");
				defaultConfigFileToken = pushPointer(defaultConfigFile, "default config file", fclose);
				if(!defaultConfigFile){
					remove(configPath);
					printTitledNamedError("config file error", "could not copy default configuration file from", DEFAULT_CONFIG_PATH);
					jmp configEmergencyExit;
				}
				copyConfigFileLoop:{
					char buffer[BUFFER_SIZE];
					size_t bytesRead;
					if((bytesRead = fread(buffer, sizeof(*buffer), sizeof(buffer), defaultConfigFile))){
						if(fwrite(buffer, sizeof(*buffer), bytesRead, configFile) != bytesRead){
							fclose(defaultConfigFile);
							popPointer(defaultConfigFileToken);
							remove(configPath);
							printTitledError("config copying error", "could not copy default config file correctly");
							jmp configEmergencyExit;
						}
						jmp copyConfigFileLoop;
					}
				}
				fclose(defaultConfigFile);
				popPointer(defaultConfigFileToken);
				fclose(configFile);
				popPointer(configFileToken);
				if(!(configFile = fopen(configPath, "r"))){
					printTitledError("config error", "could not open newly written file");
					jmp configEmergencyExit;
				}
				#undef  BUFFER_SIZE
			}
		}
		statementStart = malloc(statementSize * sizeof(char));
		statementToken = pushPointer(statementStart, "statement pointer", iFree);
		if(!statementStart){
			printTitledError("config error", "could not store user data");
			jmp configEmergencyExit;
		}
		jmp getStatementStart;
	}
	getStatementStart:{
		#define EOF_N1 /*----------------------------*/ (EOF)
		#define ZER_00 /*----------------------------*/ ('\0')
		#define EOT_04 /*----------------------------*/ (0x04)
		#define ALR_07 /*----------------------------*/ ('\a')
		#define BSP_08 /*----------------------------*/ ('\b')
		#define TAB_09 /*----------------------------*/ ('\t')
		#define NLN_10 /*----------------------------*/ ('\n')
		#define VTB_11 /*----------------------------*/ ('\v')
		#define FFD_12 /*----------------------------*/ ('\f')
		#define CRE_13 /*----------------------------*/ ('\r')
		#define ESC_27 /*----------------------------*/ ('\e')
		#define SPC_32 /*----------------------------*/ (' ')
		#define DQT_34 /*----------------------------*/ ('\"')
		#define SQT_39 /*----------------------------*/ ('\'')
		#define AST_42 /*----------------------------*/ ('*')
		#define FSL_47 /*----------------------------*/ ('/')
		#define ZER_48 /*----------------------------*/ ('0')
		#define SCL_59 /*----------------------------*/ (';')
		#define QMK_63 /*----------------------------*/ ('?')
		#define BSL_92 /*----------------------------*/ ('\\')
		#define LOA_97 /*----------------------------*/ ('a')
		#define LOB_98 /*----------------------------*/ ('b')
		#define LOF_102 /*---------------------------*/ ('f')
		#define LON_110 /*---------------------------*/ ('n')
		#define LOR_114 /*---------------------------*/ ('r')
		#define LOT_116 /*---------------------------*/ ('t')
		#define LOV_118 /*---------------------------*/ ('v')
		#define OCB_123 /*---------------------------*/ ('{')
		#define BAR_124 /*---------------------------*/ ('|')
		#define CCB_125 /*---------------------------*/ ('}')
		#define GET_STATEMENT_JMP_POINT /*-----------*/ (0)
		#define STORE_WHITESPACE_JMP_POINT /*--------*/ (1)
		#define CHECK_COMMENT_JMP_POINT /*-----------*/ (2)
		#define STORE_BAR_JMP_POINT /*---------------*/ (3)
		#define GET_DOUBLE_QUOTATION_JMP_POINT /*----*/ (4)
		#define GET_SINGLE_QUOTATION_JMP_POINT /*----*/ (5)
		#define HANDLE_ESCAPE_CHARACTER_JMP_POINT /*-*/ (6)
		#define ENTER_SCOPE_JMP_POINT /*-------------*/ (7)
		#define GET_STATEMENT_END_JMP_POINT /*-------*/ (8)
		statementCurrent = statementStart;
		statementConcreteWall = statementStart + statementSize * sizeof(char);
		statementLine = 0;
		itemAmount = 0;
		free(string0Return);
		popPointer(string0Token);
		free(string1Return);
		popPointer(string1Token);
		free(string2Return);
		popPointer(string2Token);
		free(string3Return);
		popPointer(string3Token);
		free(string4Return);
		popPointer(string4Token);
		free(execute0Return);
		popPointer(execute0Token);
		free(execute1Return);
		popPointer(execute1Token);
		free(execute2Return);
		popPointer(execute2Token);
		free(execute3Return);
		popPointer(execute3Token);
		free(execute4Return);
		popPointer(execute4Token);
		free(image0Return.dataStart);
		popPointer(image0Return.dataToken);
		free(image1Return.dataStart);
		popPointer(image1Return.dataToken);
		free(image2Return.dataStart);
		popPointer(image2Return.dataToken);
		free(image3Return.dataStart);
		popPointer(image3Return.dataToken);
		free(image4Return.dataStart);
		popPointer(image4Return.dataToken);
		name0Instruction = NULL;
		name1Instruction = NULL;
		name2Instruction = NULL;
		name3Instruction = NULL;
		name4Instruction = NULL;
		nameList0Instruction = NULL;
		nameList1Instruction = NULL;
		nameList2Instruction = NULL;
		nameList3Instruction = NULL;
		nameList4Instruction = NULL;
		integer0Instruction = NULL;
		integer1Instruction = NULL;
		integer2Instruction = NULL;
		integer3Instruction = NULL;
		integer4Instruction = NULL;
		string0Instruction = NULL;
		string1Instruction = NULL;
		string2Instruction = NULL;
		string3Instruction = NULL;
		string4Instruction = NULL;
		execute0Instruction = NULL;
		execute1Instruction = NULL;
		execute2Instruction = NULL;
		execute3Instruction = NULL;
		execute4Instruction = NULL;
		image0Instruction = NULL;
		image1Instruction = NULL;
		image2Instruction = NULL;
		image3Instruction = NULL;
		image4Instruction = NULL;
		string0Return = NULL;
		string0Token = 0;
		string1Return = NULL;
		string1Token = 0;
		string2Return = NULL;
		string2Token = 0;
		string3Return = NULL;
		string3Token = 0;
		string4Return = NULL;
		string4Token = 0;
		execute0Return = NULL;
		execute0Token = 0;
		execute1Return = NULL;
		execute1Token = 0;
		execute2Return = NULL;
		execute2Token = 0;
		execute3Return = NULL;
		execute3Token = 0;
		execute4Return = NULL;
		execute4Token = 0;
		image0Return.dataStart = NULL;
		image0Return.dataToken = 0;
		image1Return.dataStart = NULL;
		image1Return.dataToken = 0;
		image2Return.dataStart = NULL;
		image2Return.dataToken = 0;
		image3Return.dataStart = NULL;
		image3Return.dataToken = 0;
		image4Return.dataStart = NULL;
		image4Return.dataToken = 0;
		jmp getStatement;
	}
	getStatement: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*--*/ /*---------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*---------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*---------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*---------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; jmp storeWhitespace;
		to VTB_11: /*--*/ /*---------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*---------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*---------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*---------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; jmp getSingleQuotation;
		to FSL_47: /*--*/ /*---------*/ jmp checkCommentStoreCharacter;
		to SCL_59: /*--*/ /*---------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*---------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*---------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*---------*/ jmp handleClosingBracket;
		off: /*--------*/ /*---------*/ jmp getStatementStoreCharacter;
	end
	getDoubleQuotation: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getDoubleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getDoubleQuotationStoreCharacter;
		to DQT_34: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getDoubleQuotationStoreCharacter;
	end
	getSingleQuotation: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getSingleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getSingleQuotationStoreCharacter;
		to SQT_39: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getSingleQuotationStoreCharacter;
	end
	handleEscapeCharacter: switch fileChar = getConfigChar(configFile) over
		to DQT_34: /*--*/ fileChar = '\"'; jmp storeEscapedCharacter;
		to SQT_39: /*--*/ fileChar = '\''; jmp storeEscapedCharacter;
		to ZER_48: /*--*/ fileChar = '\0'; jmp storeEscapedCharacter;
		to QMK_63: /*--*/ fileChar = '\?'; jmp storeEscapedCharacter;
		to BSL_92: /*--*/ fileChar = '\\'; jmp storeEscapedCharacter;
		to LOA_97: /*--*/ fileChar = '\a'; jmp storeEscapedCharacter;
		to LOB_98: /*--*/ fileChar = '\b'; jmp storeEscapedCharacter;
		to LOF_102: /*-*/ fileChar = '\f'; jmp storeEscapedCharacter;
		to LON_110: /*-*/ fileChar = '\n'; jmp storeEscapedCharacter;
		to LOR_114: /*-*/ fileChar = '\r'; jmp storeEscapedCharacter;
		to LOT_116: /*-*/ fileChar = '\t'; jmp storeEscapedCharacter;
		to LOV_118: /*-*/ fileChar = '\v'; jmp storeEscapedCharacter;
		off: /*--------*/ /*------------*/ jmp getStatementStoreCharacter;
	end
	checkComment: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*--*/ /*-----------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*-----------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*---------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*-----------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*---------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*---------*/ jmp getSingleQuotation;
		to AST_42: /*--*/ dec statementCurrent; /*-*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ dec statementCurrent; /*-*/ jmp ignoreSingleLineComment;
		to SCL_59: /*--*/ /*-----------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*-----------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*-----------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*-----------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*-----------------------*/ jmp getStatementStoreCharacter;
	end
	ignoreMultipleLineComment: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*--*/ /*---------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*---------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; jmp ignoreMultipleLineComment;
		to AST_42: /*--*/ /*---------*/ jmp checkMultipleLineCommentEnd;
		off: /*--------*/ /*---------*/ jmp ignoreMultipleLineComment;
	end
	checkMultipleLineCommentEnd: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*--*/ /*---------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*---------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ /*---------*/ jmp storeWhitespace;
		off: /*--------*/ /*---------*/ jmp ignoreMultipleLineComment;
	end
	ignoreSingleLineComment: switch fileChar = getConfigChar(configFile) over
		to EOF_N1: /*--*/ /*---------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*---------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; jmp storeWhitespace;
		off: /*--------*/ /*---------*/ jmp ignoreSingleLineComment;
	end
	endOfFile:{
		if(statementCurrent == statementStart){
			jmp successfulConfig;
		}
		dec sharedCurrent;
		jmp completeStatement;
	}
	storeWhitespace:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp getStatement;
		}
		inc itemAmount;
		fileChar = '\0';
		jmp getStatementStoreCharacter;
	}
	completeStatement:{
		if(statementCurrent <= statementStart){
			jmp getStatement;
		}
		if(!*(statementCurrent - 1)){
			jmp getStatementEnd;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = GET_STATEMENT_END_JMP_POINT;
		jmp storeCharacter;
	}
	handleOpeningBracket:{
		if(statementCurrent <= statementStart){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray opening bracket error", "could not enter nameless scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		if(*(statementCurrent - 1)){
			inc itemAmount;
			fileChar = '\0';
			jmpPoint = ENTER_SCOPE_JMP_POINT;
			jmp storeCharacter;
		}
		jmp enterScope;
	}
	enterScope:{
		StringNodeRoot *root;
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(currentScopeInstruction == globalScopeInstruction){
			root = &globalScopesInstructionRoot;
		}else{
			printConfigError("invalid scope error", "no scopes inside current scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		if(!findString(root, &statementCurrent)){
			printConfigError("invalid scope error", "invalid scope name", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		if(itemAmount > 1){
			/*! missing space between final argument and scope imminent */
			printConfigError("scope argument error", "too many arguments", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, (void *)1, (void *)1, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		currentScopeInstruction = scope1ScopeInstruction;
		currentScopeInstructionData = scope1ScopeInstructionData;
		currentScopeInstructionList = scope1ScopeInstructionList;
		currentScopeInstructionRoot = &scope1ScopeInstructionRoot;
		currentScopeInstructionListSize = countof(scope1ScopeInstructionList) - 1;
		jmp getStatementStart;
	}
	attemptStoreBar:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp storeBar;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = STORE_BAR_JMP_POINT;
		jmp storeCharacter;
	}
	storeBar:{
		fileChar = '|';
		jmpPoint = STORE_WHITESPACE_JMP_POINT;
		jmp storeCharacter;
	}
	handleClosingBracket:{
		if(statementCurrent > statementStart){
			if(processingSignal){
				dec sharedCurrent;
				jmp completeStatement;
			}
			fseek(configFile, -1, SEEK_CUR);
			jmp completeStatement;
		}
		if(currentScopeInstruction == globalScopeInstruction){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray closing bracket error", "could not drop to previous config scope", '}', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		if(currentScopeInstruction == scope1ScopeInstruction){
			currentScopeInstruction = globalScopeInstruction;
			currentScopeInstructionData = globalScopeInstructionData;
			currentScopeInstructionList = globalInstructionList;
			currentScopeInstructionRoot = &globalInstructionRoot;
			currentScopeInstructionListSize = countof(globalInstructionList) - 1;
		}
		jmp getStatementStart;
	}
	storeEscapedCharacter:{
		*(statementCurrent - 1) = fileChar;
		if(quote == '\"'){
			jmp getDoubleQuotation;
		}
		jmp getSingleQuotation;
	}
	getStatementStoreCharacter:{
		jmpPoint = GET_STATEMENT_JMP_POINT;
		jmp storeCharacter;
	}
	getDoubleQuotationStoreCharacter:{
		jmpPoint = GET_DOUBLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	getSingleQuotationStoreCharacter:{
		jmpPoint = GET_SINGLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	handleEscapeCharacterStoreCharacter:{
		jmpPoint = HANDLE_ESCAPE_CHARACTER_JMP_POINT;
		jmp storeCharacter;
	}
	checkCommentStoreCharacter:{
		jmpPoint = CHECK_COMMENT_JMP_POINT;
		jmp storeCharacter;
	}
	storeCharacter:{
		if(statementCurrent >= statementConcreteWall){
			const uint offset = statementCurrent - statementStart;
			void *temp;
			statementSize += STATEMENT_BLOCK_SIZE;
			temp = realloc(statementStart, statementSize * sizeof(char));
			updatePointer(statementToken, temp);
			if(!temp){
				printConfigError("memory allocation error", "could not reallocate memory for config statement", ';', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
				statementSize -= STATEMENT_BLOCK_SIZE;
				jmp getStatementStart;
			}
			statementStart = temp;
			statementCurrent = statementStart + offset;
			statementConcreteWall = statementStart + statementSize * sizeof(char);
		}
		if(jmpPoint != CHECK_COMMENT_JMP_POINT and !statementLine){
			statementLine = fileLine;
		}
		*statementCurrent = fileChar;
		inc statementCurrent;
		switch jmpPoint over
			to GET_STATEMENT_JMP_POINT: /*-----------*/ jmp getStatement;
			to STORE_WHITESPACE_JMP_POINT: /*--------*/ jmp storeWhitespace;
			to CHECK_COMMENT_JMP_POINT: /*-----------*/ jmp checkComment;
			to STORE_BAR_JMP_POINT: /*---------------*/ jmp storeBar;
			to GET_DOUBLE_QUOTATION_JMP_POINT: /*----*/ jmp getDoubleQuotation;
			to GET_SINGLE_QUOTATION_JMP_POINT: /*----*/ jmp getSingleQuotation;
			to HANDLE_ESCAPE_CHARACTER_JMP_POINT: /*-*/ jmp handleEscapeCharacter;
			to ENTER_SCOPE_JMP_POINT: /*-------------*/ jmp enterScope;
			off: /*----------------------------------*/ jmp getStatementEnd;
		end
	}
	getStatementEnd:{
		if(statementCurrent > statementStart) /*-*/ jmp findStatement;
		if(!feof(configFile)) /*-----------------*/ jmp getStatementStart;
		/*---------------------------------------*/ jmp successfulConfig;
		#undef  GET_STATEMENT_END_JMP_POINT
		#undef  ENTER_SCOPE_JMP_POINT
		#undef  HANDLE_ESCAPE_CHARACTER_JMP_POINT
		#undef  GET_SINGLE_QUOTATION_JMP_POINT
		#undef  GET_DOUBLE_QUOTATION_JMPPOINT
		#undef  STORE_BAR_JMP_POINT
		#undef  CHECK_COMMENT_JMP_POINT
		#undef  STORE_WHITESPACE_JMP_POINT
		#undef  GET_STATEMENT_JMP_POINT
		#undef  CCB_125
		#undef  BAR_124
		#undef  OCB_123
		#undef  LOV_118
		#undef  LOT_116
		#undef  LOR_114
		#undef  LON_110
		#undef  LOF_102
		#undef  LOB_98
		#undef  LOA_97
		#undef  BSL_92
		#undef  QMK_63
		#undef  SCL_59
		#undef  ZER_48
		#undef  FSL_47
		#undef  AST_42
		#undef  SQT_39
		#undef  DQT_34
		#undef  SPC_32
		#undef  ESC_27
		#undef  CRE_13
		#undef  FFD_12
		#undef  VTB_11
		#undef  NLN_10
		#undef  TAB_09
		#undef  BSP_08
		#undef  ALR_07
		#undef  EOT_04
		#undef  ZER_00
		#undef  EOF_N1
	}
	findStatement:{
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(!findString(currentScopeInstructionRoot, &statementCurrent)){
			printConfigError("config error", "unrecognized instruction", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp printAllInstructionPatterns;
		}
		instructionStart = *(currentScopeInstruction + (*currentScopeInstructionRoot).returnedCounter);
		instructionStartCopy = instructionStart;
		instructionCurrent = instructionStart;
		instructionDataStart = *(currentScopeInstructionData + (*currentScopeInstructionRoot).returnedCounter);
		instructionDataStartCopy = instructionDataStart;
		instructionDataCurrent = instructionDataStart;
		if(*instructionCurrent == NONE_INSTRUCTION_TYPE){
			jmp unimplementedInstruction;
		}
		if(statementCurrent >= statementWall and *instructionCurrent != END_INSTRUCTION_TYPE){
			printConfigError("config error", "missing instruction body", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		inc statementCurrent;
		jmp switchInstructionLoop;
	}
	switchInstructionLoop: switch *instructionCurrent over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp unimplementedInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp matchName;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp matchNameList;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp matchInteger;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp matchString;
		to EXECUTE_INSTRUCTION_TYPE: /*---*/ jmp matchExecuteString;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp matchImageString;
		off: /*---------------------------*/ jmp endOfInstruction;
	end
	unimplementedInstruction:{
		printConfigError("implementation error", "using unimplemented instruction", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	matchName:{
		char *s;
		uint8 *namePointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!name0Instruction){
			namePointer = &name0Return;
			name0Instruction = instructionCurrent;
		}elif(!name1Instruction){
			namePointer = &name1Return;
			name1Instruction = instructionCurrent;
		}elif(!name2Instruction){
			namePointer = &name2Return;
			name2Instruction = instructionCurrent;
		}elif(!name3Instruction){
			namePointer = &name3Return;
			name3Instruction = instructionCurrent;
		}else{
			namePointer = &name4Return;
			name4Instruction = instructionCurrent;
		}
		s = statementCurrent;
		if(!findString(*instructionDataCurrent, &s)){
			printConfigError("match string error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		statementCurrent = s;
		inc statementCurrent;
		*namePointer = (**instructionDataCurrent).returnedCounter;
		jmp advanceDataInstruction;
	}
	matchNameList:{
		uint8 *nameListPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!nameList0Instruction){
			nameListPointer = &nameList0Return;
			nameList0Instruction = instructionCurrent;
		}elif(!nameList1Instruction){
			nameListPointer = &nameList1Return;
			nameList1Instruction = instructionCurrent;
		}elif(!nameList2Instruction){
			nameListPointer = &nameList2Return;
			nameList2Instruction = instructionCurrent;
		}elif(!nameList3Instruction){
			nameListPointer = &nameList3Return;
			nameList3Instruction = instructionCurrent;
		}else{
			nameListPointer = &nameList4Return;
			nameList4Instruction = instructionCurrent;
		}
		switch matchNameList(*instructionDataCurrent, statementWall, &statementCurrent, nameListPointer) over
			to INVALID_NAME_NAME_LIST: /*--*/ jmp invalidNameNameList;
			to PREMATURE_END_NAME_LIST: /*-*/ jmp prematureEndNameList;
			off: /*------------------------*/ jmp advanceDataInstruction;
		end
	}
	invalidNameNameList:{
		printConfigError("bar list error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	prematureEndNameList:{
		printConfigError("bar list error", "missing final name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	matchInteger:{
		int64 *integerPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!integer0Instruction){
			integerPointer = &integer0Return;
			integer0Instruction = instructionCurrent;
		}elif(!integer1Instruction){
			integerPointer = &integer1Return;
			integer1Instruction = instructionCurrent;
		}elif(!integer2Instruction){
			integerPointer = &integer2Return;
			integer2Instruction = instructionCurrent;
		}elif(!integer3Instruction){
			integerPointer = &integer3Return;
			integer3Instruction = instructionCurrent;
		}else{
			integerPointer = &integer4Return;
			integer4Instruction = instructionCurrent;
		}
		switch matchInteger(&statementCurrent, statementWall, integerPointer) over
			to NON_NUMBER_NUMBER: /*-------*/ jmp printNonNumberError;
			to OVERFLOWN_NUMBER_NUMBER: /*-*/ jmp printOverflownNumberError;
			to DIVIDED_BY_ZERO_NUMBER: /*--*/ jmp printDividedByZeroNumberError;
			off: /*------------------------*/ jmp advanceInstruction;
		end
	}
	printNonNumberError:{
		printConfigError("match integer error", "not a number", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printOverflownNumberError:{
		printConfigError("match integer error", "integer overflow", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printDividedByZeroNumberError:{
		printConfigError("match integer error", "integer divided by zero", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	matchString:{
		char **stringPointer;
		uint32 *stringTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!string0Instruction){
			stringPointer = &string0Return;
			stringTokenPointer = &string0Token;
			string0Instruction = instructionCurrent;
		}elif(!string1Instruction){
			stringPointer = &string1Return;
			stringTokenPointer = &string1Token;
			string1Instruction = instructionCurrent;
		}elif(!string2Instruction){
			stringPointer = &string2Return;
			stringTokenPointer = &string2Token;
			string2Instruction = instructionCurrent;
		}elif(!string3Instruction){
			stringPointer = &string3Return;
			stringTokenPointer = &string3Token;
			string3Instruction = instructionCurrent;
		}else{
			stringPointer = &string4Return;
			stringTokenPointer = &string4Token;
			string4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, stringPointer, stringTokenPointer)){
			printConfigError("match string error", "could not allocate string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchExecuteString:{
		char **executePointer;
		uint32 *executeTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!execute0Instruction){
			executePointer = &execute0Return;
			executeTokenPointer = &execute0Token;
			execute0Instruction = instructionCurrent;
		}elif(!execute1Instruction){
			executePointer = &execute1Return;
			executeTokenPointer = &execute1Token;
			execute1Instruction = instructionCurrent;
		}elif(!execute2Instruction){
			executePointer = &execute2Return;
			executeTokenPointer = &execute2Token;
			execute2Instruction = instructionCurrent;
		}elif(!execute3Instruction){
			executePointer = &execute3Return;
			executeTokenPointer = &execute3Token;
			execute3Instruction = instructionCurrent;
		}else{
			executePointer = &execute4Return;
			executeTokenPointer = &execute4Token;
			execute4Instruction = instructionCurrent;
		}
		if(!matchExecute(&statementCurrent, executePointer, executeTokenPointer)){
			printConfigError("match execute error", "could not allocate execute string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchImageString:{
		char *string = NULL;
		uint32 token = 0;
		Image *imagePointer;
		uint8 readImageReturn;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!image0Instruction){
			imagePointer = &image0Return;
			image0Instruction = instructionCurrent;
		}elif(!image1Instruction){
			imagePointer = &image1Return;
			image1Instruction = instructionCurrent;
		}elif(!image2Instruction){
			imagePointer = &image2Return;
			image2Instruction = instructionCurrent;
		}elif(!image3Instruction){
			imagePointer = &image3Return;
			image3Instruction = instructionCurrent;
		}else{
			imagePointer = &image4Return;
			image4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, &string, &token)){
			printConfigError("match image error", "could not allocate image string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		readImageReturn = readImage(string, &imageErrorMessage, &image0Return);
		free(string);
		popPointer(token);
		switch readImageReturn over
			to CANNOT_OPEN_READ_CONFIG: /*--------*/ jmp printCannotOpenReadConfig;
			to CANNOT_READ_READ_CONFIG: /*--------*/ jmp printCannotReadReadConfig;
			to UNSUPPORTED_FORMAT_READ_CONFIG: /*-*/ jmp printUnsupportedFormatReadConfig;
			to BAD_HEADER_READ_CONFIG: /*---------*/ jmp printBadHeaderReadConfig;
			to BAD_DEPTH_READ_CONFIG: /*----------*/ jmp printBadDepthReadConfig;
			to BAD_COMPRESSION_READ_CONFIG: /*----*/ jmp printBadCompressionReadConfig;
			to UNSUPPORTED_HEIGHT_READ_CONFIG: /*-*/ jmp printUnsupportedHeightReadConfig;
			to BAD_SIZE_READ_CONFIG: /*-----------*/ jmp printBadSizeReadConfig;
			to FAILED_READ_CONFIG: /*-------------*/ jmp printFailedReadConfig;
			to BAD_PIXELS_READ_CONFIG: /*---------*/ jmp printBadPixelsReadConfig;
			to BAD_IMAGE_READ_CONFIG: /*----------*/ jmp printBadImageReadConfig;
			off: /*-------------------------------*/ jmp advanceInstruction;
		end
	}
	printCannotOpenReadConfig:{
		printConfigError("match image error", "could not open image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printCannotReadReadConfig:{
		printConfigError("match image error", "could not read image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printUnsupportedFormatReadConfig:{
		printConfigError("match image error", "image file not bmp", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadHeaderReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadDepthReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadCompressionReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printUnsupportedHeightReadConfig:{
		printConfigError("match image error", "negative height is not supported", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadSizeReadConfig:{
		printConfigError("match image error", "could not traverse image past the header", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printFailedReadConfig:{
		printConfigError("match image error", "could not allocate pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadPixelsReadConfig:{
		printConfigError("match image error", "could not read pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printBadImageReadConfig:{
		printConfigError("match image error", "image is broken", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	endOfInstruction:{
		if(instructionStart == doInstruction){
			#define applySubinstruction(s, i) /*-*/ instructionStart = s##i##Subinstruction; instructionDataStart = s##i##SubinstructionData
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, Do); jmp assessSubinstruction;
				off: /*----------------*/ /*-----------------------------*/ brk;
			}
		}
		if(instructionStart == setInstruction){
			switch name0Return over
				to WINDOW_X_VARIABLE: /*----------------------------*/ applySubinstruction(windowX, Set); /*--------------------------*/ jmp assessSubinstruction;
				to WINDOW_Y_VARIABLE: /*----------------------------*/ applySubinstruction(windowY, Set); /*--------------------------*/ jmp assessSubinstruction;
				to WINDOW_X_OFFSET_VARIABLE: /*---------------------*/ applySubinstruction(windowXOffset, Set); /*--------------------*/ jmp assessSubinstruction;
				to WINDOW_Y_OFFSET_VARIABLE: /*---------------------*/ applySubinstruction(windowYOffset, Set); /*--------------------*/ jmp assessSubinstruction;
				to WINDOW_WIDTH_VARIABLE: /*------------------------*/ applySubinstruction(windowWidth, Set); /*----------------------*/ jmp assessSubinstruction;
				to WINDOW_HEIGHT_VARIABLE: /*-----------------------*/ applySubinstruction(windowHeight, Set); /*---------------------*/ jmp assessSubinstruction;
				to WINDOW_HORIZONTAL_ALIGNMENT_VARIABLE: /*---------*/ applySubinstruction(windowHorizontalAlignment, Set); /*--------*/ jmp assessSubinstruction;
				to WINDOW_VERTICAL_ALIGNMENT_VARIABLE: /*-----------*/ applySubinstruction(windowVerticalAlignment, Set); /*----------*/ jmp assessSubinstruction;
				to WINDOW_CORNER_RADIUS_VARIABLE: /*----------------*/ applySubinstruction(windowCornerRadius, Set); /*---------------*/ jmp assessSubinstruction;
				to WINDOW_BACKGROUND_VARIABLE: /*-------------------*/ applySubinstruction(windowBackground, Set); /*-----------------*/ jmp assessSubinstruction;
				to INPUT_X_VARIABLE: /*-----------------------------*/ applySubinstruction(inputX, Set); /*---------------------------*/ jmp assessSubinstruction;
				to INPUT_Y_VARIABLE: /*-----------------------------*/ applySubinstruction(inputY, Set); /*---------------------------*/ jmp assessSubinstruction;
				to INPUT_X_OFFSET_VARIABLE: /*----------------------*/ applySubinstruction(inputXOffset, Set); /*---------------------*/ jmp assessSubinstruction;
				to INPUT_Y_OFFSET_VARIABLE: /*----------------------*/ applySubinstruction(inputYOffset, Set); /*---------------------*/ jmp assessSubinstruction;
				to INPUT_WIDTH_VARIABLE: /*-------------------------*/ applySubinstruction(inputWidth, Set); /*-----------------------*/ jmp assessSubinstruction;
				to INPUT_HEIGHT_VARIABLE: /*------------------------*/ applySubinstruction(inputHeight, Set); /*----------------------*/ jmp assessSubinstruction;
				to INPUT_HORIZONTAL_ALIGNMENT_VARIABLE: /*----------*/ applySubinstruction(inputHorizontalAlignment, Set); /*---------*/ jmp assessSubinstruction;
				to INPUT_VERTICAL_ALIGNMENT_VARIABLE: /*------------*/ applySubinstruction(inputVerticalAlignment, Set); /*-----------*/ jmp assessSubinstruction;
				to INPUT_PADDING_VARIABLE: /*-----------------------*/ applySubinstruction(inputPadding, Set); /*---------------------*/ jmp assessSubinstruction;
				to INPUT_MARGIN_VARIABLE: /*------------------------*/ applySubinstruction(inputMargin, Set); /*----------------------*/ jmp assessSubinstruction;
				to INPUT_BACKGROUND_VARIABLE: /*--------------------*/ applySubinstruction(inputBackground, Set); /*------------------*/ jmp assessSubinstruction;
				to INPUT_CONTENT_X_VARIABLE: /*---------------------*/ applySubinstruction(inputContentX, Set); /*--------------------*/ jmp assessSubinstruction;
				to INPUT_CONTENT_Y_VARIABLE: /*---------------------*/ applySubinstruction(inputContentY, Set); /*--------------------*/ jmp assessSubinstruction;
				to INPUT_CONTENT_X_OFFSET_VARIABLE: /*--------------*/ applySubinstruction(inputContentXOffset, Set); /*--------------*/ jmp assessSubinstruction;
				to INPUT_CONTENT_Y_OFFSET_VARIABLE: /*--------------*/ applySubinstruction(inputContentYOffset, Set); /*--------------*/ jmp assessSubinstruction;
				to INPUT_CONTENT_HORIZONTAL_ALIGNMENT_VARIABLE: /*--*/ applySubinstruction(inputContentHorizontalAlignment, Set); /*--*/ jmp assessSubinstruction;
				to INPUT_CONTENT_VERTICAL_ALIGNMENT_VARIABLE: /*----*/ applySubinstruction(inputContentVerticalAlignment, Set); /*----*/ jmp assessSubinstruction;
				to INPUT_CONTENT_FOREGROUND_VARIABLE: /*------------*/ applySubinstruction(inputContentForeground, Set); /*-----------*/ jmp assessSubinstruction;
				to INPUT_CONTENT_BACKGROUND_VARIABLE: /*------------*/ applySubinstruction(inputContentBackground, Set); /*-----------*/ jmp assessSubinstruction;
				to INPUT_CONTENT_SELECTED_FOREGROUND_VARIABLE: /*---*/ applySubinstruction(inputContentSelectedForeground, Set); /*---*/ jmp assessSubinstruction;
				to INPUT_CONTENT_SELECTED_BACKGROUND_VARIABLE: /*---*/ applySubinstruction(inputContentSelectedBackground, Set); /*---*/ jmp assessSubinstruction;
				to RESULT_X_VARIABLE: /*----------------------------*/ applySubinstruction(resultX, Set); /*--------------------------*/ jmp assessSubinstruction;
				to RESULT_Y_VARIABLE: /*----------------------------*/ applySubinstruction(resultY, Set); /*--------------------------*/ jmp assessSubinstruction;
				to RESULT_X_OFFSET_VARIABLE: /*---------------------*/ applySubinstruction(resultXOffset, Set); /*--------------------*/ jmp assessSubinstruction;
				to RESULT_Y_OFFSET_VARIABLE: /*---------------------*/ applySubinstruction(resultYOffset, Set); /*--------------------*/ jmp assessSubinstruction;
				to RESULT_WIDTH_VARIABLE: /*------------------------*/ applySubinstruction(resultWidth, Set); /*----------------------*/ jmp assessSubinstruction;
				to RESULT_HEIGHT_VARIABLE: /*-----------------------*/ applySubinstruction(resultHeight, Set); /*---------------------*/ jmp assessSubinstruction;
				to RESULT_HORIZONTAL_ALIGNMENT_VARIABLE: /*---------*/ applySubinstruction(resultHorizontalAlignment, Set); /*--------*/ jmp assessSubinstruction;
				to RESULT_VERTICAL_ALIGNMENT_VARIABLE: /*-----------*/ applySubinstruction(resultVerticalAlignment, Set); /*----------*/ jmp assessSubinstruction;
				to RESULT_PADDING_VARIABLE: /*----------------------*/ applySubinstruction(resultPadding, Set); /*--------------------*/ jmp assessSubinstruction;
				to RESULT_MARGIN_VARIABLE: /*-----------------------*/ applySubinstruction(resultMargin, Set); /*---------------------*/ jmp assessSubinstruction;
				to RESULT_GAP_VARIABLE: /*--------------------------*/ applySubinstruction(resultGap, Set); /*------------------------*/ jmp assessSubinstruction;
				to RESULT_BACKGROUND_VARIABLE: /*-------------------*/ applySubinstruction(resultBackground, Set); /*-----------------*/ jmp assessSubinstruction;
				to RESULT_SELECTED_BACKGROUND_VARIABLE: /*----------*/ applySubinstruction(resultSelectedBackground, Set); /*---------*/ jmp assessSubinstruction;
				to RESULT_CONTENT_X_VARIABLE: /*--------------------*/ applySubinstruction(resultContentX, Set); /*-------------------*/ jmp assessSubinstruction;
				to RESULT_CONTENT_Y_VARIABLE: /*--------------------*/ applySubinstruction(resultContentY, Set); /*-------------------*/ jmp assessSubinstruction;
				to RESULT_CONTENT_X_OFFSET_VARIABLE: /*-------------*/ applySubinstruction(resultContentXOffset, Set); /*-------------*/ jmp assessSubinstruction;
				to RESULT_CONTENT_Y_OFFSET_VARIABLE: /*-------------*/ applySubinstruction(resultContentYOffset, Set); /*-------------*/ jmp assessSubinstruction;
				to RESULT_CONTENT_HORIZONTAL_ALIGNMENT_VARIABLE: /*-*/ applySubinstruction(resultContentHorizontalAlignment, Set); /*-*/ jmp assessSubinstruction;
				to RESULT_CONTENT_VERTICAL_ALIGNMENT_VARIABLE: /*---*/ applySubinstruction(resultContentVerticalAlignment, Set); /*---*/ jmp assessSubinstruction;
				to RESULT_CONTENT_FOREGROUND_VARIABLE: /*-----------*/ applySubinstruction(resultContentForeground, Set); /*----------*/ jmp assessSubinstruction;
				to RESULT_CONTENT_BACKGROUND_VARIABLE: /*-----------*/ applySubinstruction(resultContentBackground, Set); /*----------*/ jmp assessSubinstruction;
				to RESULT_CONTENT_SELECTED_FOREGROUND_VARIABLE: /*--*/ applySubinstruction(resultContentSelectedForeground, Set); /*--*/ jmp assessSubinstruction;
				to RESULT_CONTENT_SELECTED_BACKGROUND_VARIABLE: /*--*/ applySubinstruction(resultContentSelectedBackground, Set); /*--*/ jmp assessSubinstruction;
				to WHICH_MONITOR_VARIABLE: /*-----------------------*/ applySubinstruction(whichMonitor, Set); /*---------------------*/ jmp assessSubinstruction;
				to FONT_VARIABLE: /*--------------------------------*/ applySubinstruction(font, Set); /*-----------------------------*/ jmp assessSubinstruction;
				to MAXIMUM_RESULT_AMOUNT_VARIABLE: /*---------------*/ applySubinstruction(maximumResultAmount, Set); /*--------------*/ jmp assessSubinstruction;
				to RESULT_ALLOW_CIRCULAR_NAVIGATION_VARIABLE: /*----*/ applySubinstruction(resultAllowCircularNavigation, Set); /*----*/ jmp assessSubinstruction;
				off: /*---------------------------------------------*/ /*-------------------------------------------------------------*/ brk;
			end
		}
		if(instructionStart == grabKeycodeInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabKeycode); jmp assessSubinstruction;
				off: /*----------------*/ /*--------------------------------------*/ brk;
			}
		}
		if(instructionStart == grabButtonInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabButton); jmp assessSubinstruction;
				off: /*----------------*/ /*-------------------------------------*/ brk;
			}
			#undef  useSubinstruction
		}
		if(statementCurrent < statementWall){
			printConfigError("config error", "extra parameters error", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
			jmp getStatementStart;
		}
		if(instructionStartCopy == helpInstruction){
			printError("%s%s: %s: line %u: %s%s:%s %s:\n", colorStart, programName, configPath, statementLine, colorError, "config help menu", colorEnd, displaySimpleConfigErrors? "contracted" : "expanded");
			jmp printAllInstructionPatterns;
		}
		if(instructionStartCopy == expandInstruction){
			displaySimpleConfigErrors = false;
			jmp getStatementStart;
		}
		if(instructionStartCopy == contractInstruction){
			displaySimpleConfigErrors = true;
			jmp getStatementStart;
		}
		if(instructionStartCopy == readConfigInstruction){
			readConfig(false, string0Return, fgetc);
			jmp getStatementStart;
		}
		if(instructionStartCopy == useMessengerInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(shmRunning){
						printConfigError("config error", "shared memory messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					shmConnect();
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!shmRunning){
						printConfigError("config error", "shared memory messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					shmDisconnect();
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == doInstruction){
			switch matchCommand(name0Return, CONFIG_SWITCH_COMMAND_ORIGIN) over
				to TYPICAL_SWITCH_COMMAND:{
					jmp getStatementStart;
				}
				to RESTART_SWITCH_COMMAND:{
					if(getConfigChar == getSharedCharacter){
						restartCommand(true);
						/*! should probably also actually restart, not just free old resources. */
					}
					jmp getStatementStart;
				}
				to EXIT_SWITCH_COMMAND:{
					exitCommand();
					jmp getStatementStart;
				}
				off:{
					printConfigError("config error", "do subinstruction not implemented yet", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionStart, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == setInstruction){
			switch name0Return over
				to WINDOW_X_VARIABLE:{
					windowPreferences.x = integer0Return;
					windowPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_Y_VARIABLE:{
					windowPreferences.y = integer0Return;
					windowPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_X_OFFSET_VARIABLE:{
					windowPreferences.xOffset = integer0Return;
					windowPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_Y_OFFSET_VARIABLE:{
					windowPreferences.yOffset = integer0Return;
					windowPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					windowPreferences.width = integer0Return;
					windowPreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					windowPreferences.height = integer0Return;
					windowPreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_HORIZONTAL_ALIGNMENT_VARIABLE:{
					windowPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_VERTICAL_ALIGNMENT_VARIABLE:{
					windowPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_CORNER_RADIUS_VARIABLE:{
					Image image;
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					if(integer0Return and integer0Return != windowPreferences.cornerRadius and createCircle(integer0Return, windowPreferences.background, 0x00000000, &image)){
						if(windowCirclePixmap){
							xcb_free_pixmap(connection, windowCirclePixmap);
						}
						windowCirclePixmap = xcb_generate_id(connection);
						xcb_create_pixmap(connection, depth, windowCirclePixmap, window, image.width, image.height);
						xcb_put_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, windowCirclePixmap, gc, image.width, image.height, 0, 0, 0, depth, image.size, image.dataStart);
						free(image.dataStart);
						popPointer(image.dataToken);
						windowPreferences.cornerRadius = integer0Return;
						windowPreferences.cornerUsed = nameList0Return;
					}
					jmp getStatementStart;
				}
				to WINDOW_BACKGROUND_VARIABLE:{
					Image image;
					windowPreferences.background = integer0Return;
					if(windowPreferences.cornerRadius and createCircle(windowPreferences.cornerRadius, windowPreferences.background, 0x00000000, &image)){
						if(windowCirclePixmap){
							xcb_free_pixmap(connection, windowCirclePixmap);
						}
						windowCirclePixmap = xcb_generate_id(connection);
						xcb_create_pixmap(connection, depth, windowCirclePixmap, window, image.width, image.height);
						xcb_put_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, windowCirclePixmap, gc, image.width, image.height, 0, 0, 0, depth, image.size, image.dataStart);
						free(image.dataStart);
						popPointer(image.dataToken);
					}
					jmp getStatementStart;
				}
				to INPUT_X_VARIABLE:{
					inputPreferences.x = integer0Return;
					inputPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_Y_VARIABLE:{
					inputPreferences.y = integer0Return;
					inputPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_X_OFFSET_VARIABLE:{
					inputPreferences.xOffset = integer0Return;
					inputPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_Y_OFFSET_VARIABLE:{
					inputPreferences.yOffset = integer0Return;
					inputPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					inputPreferences.width = integer0Return;
					inputPreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					inputPreferences.height = integer0Return;
					inputPreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_HORIZONTAL_ALIGNMENT_VARIABLE:{
					inputPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to INPUT_VERTICAL_ALIGNMENT_VARIABLE:{
					inputPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to INPUT_PADDING_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					inputPreferences.padding = integer0Return;
					jmp getStatementStart;
				}
				to INPUT_MARGIN_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					inputPreferences.margin = integer0Return;
					jmp getStatementStart;
				}
				to INPUT_BACKGROUND_VARIABLE:{
					inputPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to INPUT_CONTENT_X_VARIABLE:{
					inputContentPreferences.x = integer0Return;
					inputContentPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_CONTENT_Y_VARIABLE:{
					inputContentPreferences.y = integer0Return;
					inputContentPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_CONTENT_X_OFFSET_VARIABLE:{
					inputContentPreferences.xOffset = integer0Return;
					inputContentPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_CONTENT_Y_OFFSET_VARIABLE:{
					inputContentPreferences.yOffset = integer0Return;
					inputContentPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_CONTENT_HORIZONTAL_ALIGNMENT_VARIABLE:{
					inputContentPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to INPUT_CONTENT_VERTICAL_ALIGNMENT_VARIABLE:{
					inputContentPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to INPUT_CONTENT_FOREGROUND_VARIABLE:{
					inputContentPreferences.foreground = integer0Return;
					jmp getStatementStart;
				}
				to INPUT_CONTENT_BACKGROUND_VARIABLE:{
					inputContentPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to INPUT_CONTENT_SELECTED_FOREGROUND_VARIABLE:{
					inputContentPreferences.selectedForeground = integer0Return;
					jmp getStatementStart;
				}
				to INPUT_CONTENT_SELECTED_BACKGROUND_VARIABLE:{
					inputContentPreferences.selectedBackground = integer0Return;
					jmp getStatementStart;
				}
				to RESULT_X_VARIABLE:{
					resultPreferences.x = integer0Return;
					resultPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to RESULT_Y_VARIABLE:{
					resultPreferences.y = integer0Return;
					resultPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to RESULT_X_OFFSET_VARIABLE:{
					resultPreferences.xOffset = integer0Return;
					resultPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to RESULT_Y_OFFSET_VARIABLE:{
					resultPreferences.yOffset = integer0Return;
					resultPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to RESULT_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					resultPreferences.width = integer0Return;
					resultPreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to RESULT_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					resultPreferences.height = integer0Return;
					resultPreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to RESULT_HORIZONTAL_ALIGNMENT_VARIABLE:{
					resultPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to RESULT_VERTICAL_ALIGNMENT_VARIABLE:{
					resultPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to RESULT_PADDING_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					resultPreferences.padding = integer0Return;
					jmp getStatementStart;
				}
				to RESULT_MARGIN_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					resultPreferences.margin = integer0Return;
					jmp getStatementStart;
				}
				to RESULT_GAP_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
						jmp getStatementStart;
					}
					resultPreferences.gap = integer0Return;
					jmp getStatementStart;
				}
				to RESULT_BACKGROUND_VARIABLE:{
					resultPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to RESULT_SELECTED_BACKGROUND_VARIABLE:{
					resultPreferences.selectedBackground = integer0Return;
					jmp getStatementStart;
				}
				to RESULT_CONTENT_X_VARIABLE:{
					resultContentPreferences.x = integer0Return;
					resultContentPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to RESULT_CONTENT_Y_VARIABLE:{
					resultContentPreferences.y = integer0Return;
					resultContentPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to RESULT_CONTENT_X_OFFSET_VARIABLE:{
					resultContentPreferences.xOffset = integer0Return;
					resultContentPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to RESULT_CONTENT_Y_OFFSET_VARIABLE:{
					resultContentPreferences.yOffset = integer0Return;
					resultContentPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to RESULT_CONTENT_HORIZONTAL_ALIGNMENT_VARIABLE:{
					resultContentPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to RESULT_CONTENT_VERTICAL_ALIGNMENT_VARIABLE:{
					resultContentPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to RESULT_CONTENT_FOREGROUND_VARIABLE:{
					resultContentPreferences.foreground = integer0Return;
					jmp getStatementStart;
				}
				to RESULT_CONTENT_BACKGROUND_VARIABLE:{
					resultContentPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to RESULT_CONTENT_SELECTED_FOREGROUND_VARIABLE:{
					resultContentPreferences.selectedForeground = integer0Return;
					jmp getStatementStart;
				}
				to RESULT_CONTENT_SELECTED_BACKGROUND_VARIABLE:{
					resultContentPreferences.selectedBackground = integer0Return;
					jmp getStatementStart;
				}
				to WHICH_MONITOR_VARIABLE:{
					whichMonitor = name1Return;
					jmp getStatementStart;
				}
				to FONT_VARIABLE:{
					if(font){
						xcb_close_font(connection, font);
					}
					font = xcb_generate_id(connection);
					{
						const xcb_void_cookie_t cookie = xcb_open_font_checked(connection, font, findStringLength(string0Return), string0Return);
						xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
						uint32 token = pushPointer(error, "open font error", iFree);
						if(error){
							xcb_open_font(connection, font, lengthof("fixed"), "fixed");
							printError("%s%s: %s%s:%s %s \"%s\"\n", colorStart, programName, colorError, "open font error", colorEnd, "could not open font", string0Return);
							free(error);
							popPointer(token);
						}
					}
					xcb_change_gc(connection, gc, XCB_GC_FONT, &font);
					jmp getStatementStart;
				}
				to MAXIMUM_RESULT_AMOUNT_VARIABLE:{
					maximumResultAmount = integer0Return;
					jmp getStatementStart;
				}
				to RESULT_ALLOW_CIRCULAR_NAVIGATION_VARIABLE:{
					resultAllowCircularNavigation = name1Return;
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == grabKeycodeInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			if(!insertShortcut(&keycodeShortcut, integer0Return, nameList0Return, name0Return, execute0Return, execute0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
				jmp getStatementStart;
			}
			execute0Return = NULL;
			execute0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_key_checked(connection, true, (*screen).root, nameList0Return, integer0Return, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab key on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == grabButtonInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			if(!insertShortcut(&buttonShortcut, integer0Return, nameList0Return, name0Return, execute0Return, execute0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
				jmp getStatementStart;
			}
			execute0Return = NULL;
			execute0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_button_checked(connection, true, (*screen).root, XCB_EVENT_MASK_NO_EVENT, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, integer0Return, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab button on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabKeycodeInstruction){
			if(!removeShortcut(&keycodeShortcut, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find key to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_key_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab key from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabButtonInstruction){
			if(!removeShortcut(&buttonShortcut, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find button to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_button_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab button from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == stopInstruction){
			jmp successfulConfig;
		}
		jmp getStatementStart;
	}
	advanceInstruction:{
		inc instructionCurrent;
		jmp switchInstructionLoop;
	}
	advanceDataInstruction:{
		inc instructionCurrent;
		inc instructionDataCurrent;
		jmp switchInstructionLoop;
	}
	assessSubinstruction:{
		instructionCurrent = instructionStart + (instructionCurrent - instructionStartCopy);
		instructionDataCurrent = instructionDataStart + (instructionDataCurrent - instructionDataStartCopy);
		if(statementCurrent < statementWall){
			jmp switchInstructionLoop;
		}
		jmp printMissingArgumentError;
	}
	printMissingArgumentError:{
		printConfigError("config error", "missing argument error", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionRoot);
		jmp getStatementStart;
	}
	printAllInstructionPatterns:{
		const char *const *const wall = currentScopeInstructionList + currentScopeInstructionListSize;
		const char *const *current = currentScopeInstructionList;
		const Instruction *const *in = currentScopeInstruction;
		StringNodeRoot *const *const *da = currentScopeInstructionData;
		jmp printExpandedHelpInstructions;
		printExpandedHelpInstructions:{
			const Instruction *n = *in - 1;
			StringNodeRoot *const *d = *da;
			printError("\tpattern | %s", *current);
			jmp printHelpInstructionParametersLoop;
			printHelpInstructionParametersLoop: switch *(inc n) over
				to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
				to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
				to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
				to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
				to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
				to EXECUTE_INSTRUCTION_TYPE: /*---*/ jmp executeInstruction;
				to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
				off: /*---------------------------*/ jmp printHelpInstructionParametersLoopExit;
			end
			noneInstruction:{
				printError(" <unimplemented>");
				jmp printHelpInstructionParametersLoopExit;
			}
			nameInstruction:{
				const char *const *stringArray;
				if(displaySimpleConfigErrors){
					printError(" name");
					jmp printHelpInstructionParametersLoop;
				}
				stringArray = (**d).stringArray;
				printError(" (%s", *stringArray);
				inc stringArray;
				printNameLoop:{
					if(*stringArray){
						printError("|%s", *stringArray);
						inc stringArray;
						jmp printNameLoop;
					}
				}
				printError(")");
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			nameListInstruction:{
				const char *const *stringArray;
				if(displaySimpleConfigErrors){
					printError(" list");
					jmp printHelpInstructionParametersLoop;
				}
				stringArray = (**d).stringArray;
				printError(" ((%s", *stringArray);
				inc stringArray;
				printNameListOnceLoop:{
					if(*stringArray){
						printError("|%s", *stringArray);
						inc stringArray;
						jmp printNameListOnceLoop;
					}
				}
				stringArray = (**d).stringArray;
				printError(")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
				inc stringArray;
				printNameListTwiceLoop:{
					if(*stringArray){
						printError("|%s", *stringArray);
						inc stringArray;
						jmp printNameListTwiceLoop;
					}
				}
				printError("))*(?![\\s]*[|]))");
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			numberInstruction:{
				if(displaySimpleConfigErrors){
					printError(" number");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
				jmp printHelpInstructionParametersLoop;
			}
			stringInstruction:{
				if(displaySimpleConfigErrors){
					printError(" string");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			executeInstruction:{
				if(displaySimpleConfigErrors){
					printError(" execute");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			imageInstruction:{
				if(displaySimpleConfigErrors){
					printError(" image");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
		}
		printHelpInstructionParametersLoopExit:{
			inc in;
			inc da;
			if(displaySimpleConfigErrors){
				printError("\n");
			}else{
				printError(" $\n");
			}
			if(inc current < wall){
				jmp printExpandedHelpInstructions;
			}
			printError("\n");
		}
		jmp getStatementStart;
	}
	successfulConfig:{
		if(currentScopeInstruction != globalScopeInstruction){
			*statementCurrent = '\0';
			statementWall = statementCurrent;
			statementLine = fileLine;
			if(fileLine != 1){
				dec statementLine;
			}
			printConfigError("config error", "missing closing scope bracket", '\0', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
		}
		jmp configEmergencyExit;
	}
	configEmergencyExit:{
		if(configFile and fileLine == 1 and !statementLine){
			printConfigError("config warning", "empty config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionRoot);
		}
		free(statementStart);
		popPointer(statementToken);
		if(configFile){
			fclose(configFile);
			popPointer(configFileToken);
		}
		jmp postReadConfig;
	}
	postReadConfig:{
		configureWindow();
		xcb_flush(connection);
		ret;
	}
	#undef  DEFAULT_CONFIG_PATH
	#undef  STATEMENT_BLOCK_SIZE
}
MATCHNAMELIST(){
	char *current = *statementCurrentReturn;
	uint value = 0;
	jmp matchNameLoop;
	matchNameLoop:{
		if(!findString(root, &current)){
			ret INVALID_NAME_NAME_LIST;
		}
		value |= !!(*root).returnedCounter * (1 << ((*root).returnedCounter - 1));
		jmp matchBar;
	}
	matchBar: switch *(inc current) over
		to '\0': /*-*/ jmp endCheck;
		to '|': /*--*/ jmp advance;
		off: /*-----*/ jmp successful;
	end
	endCheck:{
		if(current >= statementWall){
			jmp successful;
		}
		jmp matchBar;
	}
	advance:{
		if(inc current >= statementWall){
			ret PREMATURE_END_NAME_LIST;
		}
		inc current;
		jmp matchNameLoop;
	}
	successful:{
		*valueReturn = value;
		*statementCurrentReturn = current;
		ret SUCCESS_NAME_LIST;
	}
}
MATCHINTEGER(){
	#define LEVEL0_JMP_POINT /*-*/ (0)
	#define LEVEL1_JMP_POINT /*-*/ (1)
	#define LEVEL2_JMP_POINT /*-*/ (2)
	char *current = *statementCurrent - 1;
	int64 number = 0;
	char op = '\0';
	JmpPoint jmpPoint;
	int64 i0 = 0;
	int64 i1 = 0;
	char o0 = '\0';
	char o1 = '\0';
	jmpPoint = LEVEL0_JMP_POINT;
	jmp matchWhitespace0Loop;
	matchWhitespace0Loop:{
		if(inc current >= statementWall){
			number = 0;
			op = '\0';
			jmp matchOperationReturnPoint;
		}
		switch *current over
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace0Loop;
			to '\n': /*-*/ jmp matchWhitespace0Loop;
			to '\v': /*-*/ jmp matchWhitespace0Loop;
			to '\f': /*-*/ jmp matchWhitespace0Loop;
			to '\r': /*-*/ jmp matchWhitespace0Loop;
			to ' ': /*--*/ jmp matchWhitespace0Loop;
			off: /*-----*/ jmp matchInteger;
		end
	}
	matchInteger:{
		number = 0;
		dec current;
		jmp initialCheck;
	}
	initialCheck: switch *(inc current) over
		to '0': /*-*/ /*--------*/ jmp formatCheck;
		to '1': /*-*/ dec current; jmp matchDecimalLoop;
		to '2': /*-*/ dec current; jmp matchDecimalLoop;
		to '3': /*-*/ dec current; jmp matchDecimalLoop;
		to '4': /*-*/ dec current; jmp matchDecimalLoop;
		to '5': /*-*/ dec current; jmp matchDecimalLoop;
		to '6': /*-*/ dec current; jmp matchDecimalLoop;
		to '7': /*-*/ dec current; jmp matchDecimalLoop;
		to '8': /*-*/ dec current; jmp matchDecimalLoop;
		to '9': /*-*/ dec current; jmp matchDecimalLoop;
		to '+': /*-*/ /*--------*/ jmp matchOperation;
		to '-': /*-*/ /*--------*/ jmp matchOperation;
		to '*': /*-*/ /*--------*/ jmp matchOperation;
		to '/': /*-*/ /*--------*/ jmp matchOperation;
		off: /*----*/ /*--------*/ jmp matchMacro;
	end
	formatCheck: switch *(inc current) over
		to '\0': /*-*/ /*--------*/ jmp matchOperation;
		to '\t': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ /*--------*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ dec current; jmp matchOctalLoop;
		to '1': /*--*/ dec current; jmp matchOctalLoop;
		to '2': /*--*/ dec current; jmp matchOctalLoop;
		to '3': /*--*/ dec current; jmp matchOctalLoop;
		to '4': /*--*/ dec current; jmp matchOctalLoop;
		to '5': /*--*/ dec current; jmp matchOctalLoop;
		to '6': /*--*/ dec current; jmp matchOctalLoop;
		to '7': /*--*/ dec current; jmp matchOctalLoop;
		to 'B': /*--*/ /*--------*/ jmp matchBinaryLoop;
		to 'b': /*--*/ /*--------*/ jmp matchBinaryLoop;
		to 'X': /*--*/ /*--------*/ jmp matchHexadecimalLoop;
		to 'x': /*--*/ /*--------*/ jmp matchHexadecimalLoop;
		to '+': /*--*/ /*--------*/ jmp matchOperation;
		to '-': /*--*/ /*--------*/ jmp matchOperation;
		to '*': /*--*/ /*--------*/ jmp matchOperation;
		to '/': /*--*/ /*--------*/ jmp matchOperation;
		off: /*-----*/ /*--------*/ jmp nonNumber;
	end
	matchBinaryLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateBinary;
		to '1': /*--*/ jmp calculateBinary;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchOctalLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateOctal;
		to '1': /*--*/ jmp calculateOctal;
		to '2': /*--*/ jmp calculateOctal;
		to '3': /*--*/ jmp calculateOctal;
		to '4': /*--*/ jmp calculateOctal;
		to '5': /*--*/ jmp calculateOctal;
		to '6': /*--*/ jmp calculateOctal;
		to '7': /*--*/ jmp calculateOctal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchDecimalLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateDecimal;
		to '1': /*--*/ jmp calculateDecimal;
		to '2': /*--*/ jmp calculateDecimal;
		to '3': /*--*/ jmp calculateDecimal;
		to '4': /*--*/ jmp calculateDecimal;
		to '5': /*--*/ jmp calculateDecimal;
		to '6': /*--*/ jmp calculateDecimal;
		to '7': /*--*/ jmp calculateDecimal;
		to '8': /*--*/ jmp calculateDecimal;
		to '9': /*--*/ jmp calculateDecimal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchHexadecimalLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateHexadecimal;
		to '1': /*--*/ jmp calculateHexadecimal;
		to '2': /*--*/ jmp calculateHexadecimal;
		to '3': /*--*/ jmp calculateHexadecimal;
		to '4': /*--*/ jmp calculateHexadecimal;
		to '5': /*--*/ jmp calculateHexadecimal;
		to '6': /*--*/ jmp calculateHexadecimal;
		to '7': /*--*/ jmp calculateHexadecimal;
		to '8': /*--*/ jmp calculateHexadecimal;
		to '9': /*--*/ jmp calculateHexadecimal;
		to 'A': /*--*/ jmp calculateHexadecimal;
		to 'B': /*--*/ jmp calculateHexadecimal;
		to 'C': /*--*/ jmp calculateHexadecimal;
		to 'D': /*--*/ jmp calculateHexadecimal;
		to 'E': /*--*/ jmp calculateHexadecimal;
		to 'F': /*--*/ jmp calculateHexadecimal;
		to 'a': /*--*/ jmp calculateHexadecimal;
		to 'b': /*--*/ jmp calculateHexadecimal;
		to 'c': /*--*/ jmp calculateHexadecimal;
		to 'd': /*--*/ jmp calculateHexadecimal;
		to 'e': /*--*/ jmp calculateHexadecimal;
		to 'f': /*--*/ jmp calculateHexadecimal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchMacro:{
		if(!findString(&macroRoot, &current)){
			jmp nonNumber;
		}
		if(macroRoot.returnedCounter < 5){
			number = macroRoot.returnedCounter;
			inc number;
		}elif(macroRoot.returnedCounter < 9){
			number = macroRoot.returnedCounter - 5;
		}elif(macroRoot.returnedCounter < 11){
			number = macroRoot.returnedCounter - 9;
		}elif(macroRoot.returnedCounter < 15){
			number = macroRoot.returnedCounter - 11;
		}elif(macroRoot.returnedCounter < 17){
			number = macroRoot.returnedCounter - 15;
		}else{
			number = 0;
		}
		switch *current over
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace1Loop;
			to '\n': /*-*/ jmp matchWhitespace1Loop;
			to '\v': /*-*/ jmp matchWhitespace1Loop;
			to '\f': /*-*/ jmp matchWhitespace1Loop;
			to '\r': /*-*/ jmp matchWhitespace1Loop;
			to ' ': /*--*/ jmp matchWhitespace1Loop;
			to '+': /*--*/ jmp matchOperation;
			to '-': /*--*/ jmp matchOperation;
			to '*': /*--*/ jmp matchOperation;
			to '/': /*--*/ jmp matchOperation;
			off: /*-----*/ jmp nonNumber;
		end
	}
	calculateBinary:{
		const int copy = number;
		number = number * 2 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchBinaryLoop;
	}
	calculateOctal:{
		const int copy = number;
		number = number * 8 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchOctalLoop;
	}
	calculateDecimal:{
		const int copy = number;
		number = number * 10 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchDecimalLoop;
	}
	calculateHexadecimal:{
		const int copy = number;
		number = number * 16 + *current - (*current >= '0') * 48 - (*current >= 'A') * 7 - (*current >= 'a') * 32;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchHexadecimalLoop;
	}
	matchWhitespace1Loop:{
		if(inc current >= statementWall){
			op = '\0';
			jmp matchOperationReturnPoint;
		}
		switch *current over
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace1Loop;
			to '\n': /*-*/ jmp matchWhitespace1Loop;
			to '\v': /*-*/ jmp matchWhitespace1Loop;
			to '\f': /*-*/ jmp matchWhitespace1Loop;
			to '\r': /*-*/ jmp matchWhitespace1Loop;
			to ' ': /*--*/ jmp matchWhitespace1Loop;
			off: /*-----*/ jmp matchOperation;
		end
	}
	matchOperation: switch *current over
		to '+': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '-': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '*': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '/': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		off: /*----*/ op = '\0'; /*-----*/ jmp matchOperationReturnPoint;
	end
	matchOperationReturnPoint: switch jmpPoint over
		to LEVEL0_JMP_POINT: /*-*/ jmp switchOperation0;
		to LEVEL1_JMP_POINT: /*-*/ jmp switchOperation1;
		off: /*-----------------*/ jmp switchOperation2;
	end
	switchOperation0: switch op over
		to '\0': /*-*/ jmp level0;
		to '+': /*--*/ jmp level1;
		to '-': /*--*/ jmp level1;
		to '*': /*--*/ jmp level2;
		to '/': /*--*/ jmp level2;
	end
	switchOperation1: switch op over
		to '\0': /*-*/ jmp level1End;
		to '+': /*--*/ jmp level1FoundLevel1;
		to '-': /*--*/ jmp level1FoundLevel1;
		to '*': /*--*/ jmp level2;
		to '/': /*--*/ jmp level2;
	end
	switchOperation2: switch op over
		to '\0': /*-*/ jmp level2End;
		to '+': /*--*/ jmp level2FoundLevel1;
		to '-': /*--*/ jmp level2FoundLevel1;
		to '*': /*--*/ jmp level2FoundLevel2;
		to '/': /*--*/ jmp level2FoundLevel2;
	end
	level0:{
		i0 = number;
		jmp validNumber;
	}
	level1:{
		i0 = number;
		o0 = op;
		jmpPoint = LEVEL1_JMP_POINT;
		jmp matchWhitespace0Loop;
	}
	level2:{
		i1 = number;
		o1 = op;
		jmpPoint = LEVEL2_JMP_POINT;
		jmp matchWhitespace0Loop;
	}
	level1End:{
		if(o0 == '+'){
			i0 += number;
		}else{
			i0 -= number;
		}
		o0 = op;
		jmp validNumber;
	}
	level1FoundLevel1:{
		if(o0 == '+'){
			i0 += number;
		}else{
			i0 -= number;
		}
		o0 = op;
		jmp matchWhitespace0Loop;
	}
	level2End:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		switch o0 over
			to '\0': /*-*/ i0  = i1; jmp validNumber;
			to '+': /*--*/ i0 += i1; jmp validNumber;
			to '-': /*--*/ i0 -= i1; jmp validNumber;
		end
	}
	level2FoundLevel1:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		switch o0 over
			to '\0': /*-*/ o1 = '\0'; /*-*/ number = i1; jmp level1;
			to '+': /*--*/ i0 += i1; /*--*/ number = i0; jmp level1;
			to '-': /*--*/ i0 -= i1; /*--*/ number = i0; jmp level1;
		end
	}
	level2FoundLevel2:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		o1 = op;
		jmp matchWhitespace0Loop;
	}
	validNumber:{
		*statementCurrent = current + 1;
		*returnValue = i0;
		ret VALID_NUMBER_NUMBER;
	}
	nonNumber:{
		*statementCurrent = current + 1;
		ret NON_NUMBER_NUMBER;
	}
	overflownNumber:{
		*statementCurrent = current + 1;
		ret OVERFLOWN_NUMBER_NUMBER;
	}
	dividedByZeroNumber:{
		*statementCurrent = current + 1;
		ret DIVIDED_BY_ZERO_NUMBER;
	}
	#undef  LEVEL2_JMP_POINT
	#undef  LEVEL1_JMP_POINT
	#undef  LEVEL0_JMP_POINT
}
MATCHSTRING(){
	#define STRING_BLOCK_SIZE /*-*/ (1024)
	uint size = STRING_BLOCK_SIZE;
	char *dataStart = malloc(size * sizeof(char));
	uint32 dataToken = pushPointer(dataStart, "matched string pointer", iFree);
	uint allocated = 0;
	char *dataCurrent = dataStart;
	char *current = *statementCurrent;
	jmp validateMalloc;
	validateMalloc:{
		if(!dataStart){
			ret false;
		}
		jmp copyStringLoop;
	}
	copyStringLoop:{
		if(allocated == size){
			const uint offset = dataCurrent - dataStart;
			void *temp;
			size += STRING_BLOCK_SIZE;
			temp = realloc(dataStart, size * sizeof(char));
			updatePointer(dataToken, temp);
			if(!temp){
				free(dataStart);
				popPointer(dataToken);
				ret false;
			}
			dataStart = temp;
			dataCurrent = dataStart + offset;
		}
		*dataCurrent = *current;
		inc allocated;
		if(*current){
			inc current;
			inc dataCurrent;
			jmp copyStringLoop;
		}
		inc current;
		jmp trimMemory;
	}
	trimMemory:{
		void *temp = realloc(dataStart, allocated * sizeof(char));
		updatePointer(dataToken, temp);
		if(!temp){
			jmp returnValidString;
		}
		dataStart = temp;
		jmp returnValidString;
	}
	returnValidString:{
		*statementCurrent = current;
		*stringReturn = dataStart;
		*stringToken = dataToken;
		ret true;
	}
	#undef  STRING_BLOCK_SIZE
}
MATCHEXECUTE(){
	#define EXECUTE_BLOCK_SIZE /*-------*/ (1024)
	#define ROOT_UID /*-----------------*/ (0)
	#define PREPEND_STRING_OPERATION /*-*/ (0)
	#define GIVEN_STRING_OPERATION /*---*/ (1)
	#define APPEND_STRING_OPERATION /*--*/ (2)
	const uid_t uid = geteuid();
	char *current = *statementCurrent;
	uint allocated = 0;
	uint size = EXECUTE_BLOCK_SIZE;
	char *dataStart = malloc(size * sizeof(char));
	uint32 dataToken = pushPointer(dataStart, "matched execute pointer", iFree);
	char *dataCurrent = dataStart;
	char *string = current;
	bool operation = APPEND_STRING_OPERATION;
	jmp validateMalloc;
	validateMalloc:{
		if(!dataStart){
			ret false;
		}
		jmp pickPrivilegedUnprivilegedPath;
	}
	pickPrivilegedUnprivilegedPath:{
		if(uid == ROOT_UID){
			string = "su $(logname) -c \'";
			operation = PREPEND_STRING_OPERATION;
		}
		jmp matchStringLoop;
	}
	matchStringLoop:{
		if(allocated == size){
			const uint offset = dataCurrent - dataStart;
			void *temp;
			size += EXECUTE_BLOCK_SIZE;
			temp = realloc(dataStart, size * sizeof(char));
			updatePointer(dataToken, temp);
			if(!temp){
				free(dataStart);
				popPointer(dataToken);
				ret false;
			}
			dataStart = temp;
			dataCurrent = dataStart + offset;
		}
		*dataCurrent = *string;
		inc allocated;
		inc dataCurrent;
		if(*(inc string)){
			jmp matchStringLoop;
		}
		jmp nextString;
	}
	nextString: switch operation over
		to PREPEND_STRING_OPERATION:{
			operation = GIVEN_STRING_OPERATION;
			string = current;
			jmp matchStringLoop;
		}
		to GIVEN_STRING_OPERATION:{
			operation = APPEND_STRING_OPERATION;
			current = inc string;
			string = "\'";
			jmp matchStringLoop;
		}
		off:{
			if(allocated == size){
				const uint offset = dataCurrent - dataStart;
				void *temp;
				size += EXECUTE_BLOCK_SIZE;
				temp = realloc(dataStart, size * sizeof(char));
				updatePointer(dataToken, temp);
				if(!temp){
					free(dataStart);
					popPointer(dataToken);
					ret false;
				}
				dataStart = temp;
				dataCurrent = dataStart + offset;
			}
			*dataCurrent = '\0';
			inc allocated;
			jmp trimMemory;
		}
	end
	trimMemory:{
		void *temp = realloc(dataStart, allocated * sizeof(char));
		updatePointer(dataToken, temp);
		if(!temp){
			jmp returnValidString;
		}
		dataStart = temp;
		jmp returnValidString;
	}
	returnValidString:{
		if(uid != ROOT_UID){
			current = inc string;
		}
		*statementCurrent = current;
		*executeReturn = dataStart;
		*executeToken = dataToken;
		ret true;
	}
	#undef  APPEND_STRING_OPERATION
	#undef  GIVEN_STRING_OPERATION
	#undef  PREPEND_STRING_OPERATION
	#undef  ROOT_UID
	#undef  EXECUTE_BLOCK_SIZE
}
READIMAGE(){
	#define FILE_HEADER_SIZE /*---*/ (14)
	#define BITMAPCOREHEADER /*---*/ (12)
	#define OS22XBITMAPHEADER /*--*/ (64)
	#define BITMAPINFOHEADER /*---*/ (40)
	#define BITMAPV2INFOHEADER /*-*/ (52)
	#define BITMAPV3INFOHEADER /*-*/ (56)
	#define BITMAPV4HEADER /*-----*/ (108)
	#define BITMAPV5HEADER /*-----*/ (124)
	#define BI_RGB /*-------------*/ (0)
	#define BI_RLE8 /*------------*/ (1)
	#define BI_RLE4 /*------------*/ (2)
	#define BI_BITFIELDS /*-------*/ (3)
	#define BI_JPEG /*------------*/ (4)
	#define BI_PNG /*-------------*/ (5)
	#define BI_ALPHABITFIELDS /*--*/ (6)
	#define BI_CMYK /*------------*/ (11)
	#define BI_CMYKRLE8 /*--------*/ (12)
	#define BI_CMYKRLE4 /*--------*/ (13)
	FILE *file = NULL;
	uint32 fileToken = 0;
	uint8 b;
	uint8 m;
	uint32 headerSize;
	int32 width;
	int32 height;
	uint16 depth;
	uint32 compression;
	uint32 *data = NULL;
	uint32 dataToken = 0;
	uint8 returnValue;
	*errorMessage = NULL;
	jmp openFile;
	openFile:{
		file = fopen(path, "rb");
		fileToken = pushPointer(file, "image file", fclose);
		if(!file){
			returnValue = CANNOT_OPEN_READ_CONFIG;
			jmp failedImage;
		}
		jmp readHeaders;
	}
	readHeaders:{
		uint8 header[FILE_HEADER_SIZE + BITMAPINFOHEADER];
		if(fread(header, sizeof(uint8), FILE_HEADER_SIZE + 34, file) != FILE_HEADER_SIZE + 34){
			returnValue = CANNOT_READ_READ_CONFIG;
			jmp failedImage;
		}
		b /*-----------*/ = *(uint8  *)(header + 0);
		m /*-----------*/ = *(uint8  *)(header + 1);
		headerSize /*--*/ = *(uint32 *)(header + 14);
		width /*-------*/ = *( int32 *)(header + 18);
		height /*------*/ = *( int32 *)(header + 22);
		depth /*-------*/ = *(uint16 *)(header + 28);
		compression /*-*/ = *(uint32 *)(header + 30);
		jmp queryFileFormat;
	}
	queryFileFormat:{
		if(b != 'B' or m != 'M'){
			returnValue = UNSUPPORTED_FORMAT_READ_CONFIG;
			jmp failedImage;
		}
		jmp queryHeaderSupport;
	}
	queryHeaderSupport: switch headerSize over
		to BITMAPCOREHEADER: /*---*/ *errorMessage = "BITMAPCOREHEADER header not supported"; /*--*/ jmp printHeaderError;
		to OS22XBITMAPHEADER: /*--*/ *errorMessage = "OS22XBITMAPHEADER header not supported"; /*-*/ jmp printHeaderError;
		to BITMAPINFOHEADER: /*---*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV2INFOHEADER: /*-*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV3INFOHEADER: /*-*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV4HEADER: /*-----*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV5HEADER: /*-----*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		off: /*-------------------*/ *errorMessage = "unrecognized header"; /*--------------------*/ jmp printHeaderError;
	end
	printHeaderError:{
		returnValue = BAD_HEADER_READ_CONFIG;
		jmp failedImage;
	}
	queryDepth: switch depth over
		to 1: /*--*/ *errorMessage = "1 bit depth not supported"; /*---*/ jmp printDepthError;
		to 4: /*--*/ *errorMessage = "4 bit depth not supported"; /*---*/ jmp printDepthError;
		to 8: /*--*/ *errorMessage = "8 bit depth not supported"; /*---*/ jmp printDepthError;
		to 16: /*-*/ *errorMessage = "16 bit depth not supported"; /*--*/ jmp printDepthError;
		to 24: /*-*/ /*------------------------------------------------*/ jmp queryCompression;
		to 32: /*-*/ /*------------------------------------------------*/ jmp queryCompression;
		off: /*---*/ *errorMessage = "unknown depth not supported"; /*-*/ jmp printDepthError;
	end
	printDepthError:{
		returnValue = BAD_DEPTH_READ_CONFIG;
		jmp failedImage;
	}
	queryCompression: switch compression over
		to BI_RGB: /*------------*/ /*----------------------------------------------------------------*/ jmp queryHeight;
		to BI_RLE8: /*-----------*/ *errorMessage = "BI_RLE8 compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_RLE4: /*-----------*/ *errorMessage = "BI_RLE4 compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_BITFIELDS: /*------*/ /*----------------------------------------------------------------*/ jmp queryHeight;
		to BI_JPEG: /*-----------*/ *errorMessage = "BI_JPEG compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_PNG: /*------------*/ *errorMessage = "BI_PNG compression not supported"; /*------------*/ jmp printCompressionError;
		to BI_ALPHABITFIELDS: /*-*/ *errorMessage = "BI_ALPHABITFIELDS compression not supported"; /*-*/ jmp printCompressionError;
		to BI_CMYK: /*-----------*/ *errorMessage = "BI_CMYK compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_CMYKRLE8: /*-------*/ *errorMessage = "BI_CMYKRLE8 compression not supported"; /*-------*/ jmp printCompressionError;
		to BI_CMYKRLE4: /*-------*/ *errorMessage = "BI_CMYKRLE4 compression not supported"; /*-------*/ jmp printCompressionError;
		off: /*------------------*/ *errorMessage = "unrecognized compression used"; /*---------------*/ jmp printCompressionError;
	end
	printCompressionError:{
		returnValue = BAD_COMPRESSION_READ_CONFIG;
		jmp failedImage;
	}
	queryHeight:{
		if(height < 0){
			returnValue = UNSUPPORTED_HEIGHT_READ_CONFIG;
			jmp failedImage;
		}
		jmp setupImage;
	}
	setupImage:{
		if(fseek(file, FILE_HEADER_SIZE + headerSize, SEEK_SET)){
			returnValue = BAD_SIZE_READ_CONFIG;
			jmp failedImage;
		}
		(*image).width = width;
		(*image).height = height;
		(*image).size = width * height * sizeof(uint32);
		data = malloc((*image).size * sizeof(uint8));
		dataToken = pushPointer(data, "image data pointer", iFree);
		if(!data){
			returnValue = FAILED_READ_CONFIG;
			jmp failedImage;
		}
		jmp readPixels;
	}
	readPixels:{
		const uint32 amount = (depth * width + 31) / 8 / width;
		const uint widthTwice = 2 * width;
		uint32 *const start = data + (height - 1) * width;
		uint32 *current = start;
		uint multipleCounter = 0;
		uint32 *currentWall = current + width;
		jmp readRowLoop;
		readRowLoop:{
			if(fread(current, sizeof(uint8), amount, file) != amount){
				if(current == start){
					returnValue = BAD_PIXELS_READ_CONFIG;
					jmp failedImage;
				}
				returnValue = BAD_IMAGE_READ_CONFIG;
				jmp failedImage;
			}
			if(depth == 24){
				*current |= 0xFF000000;
			}
			multipleCounter += amount;
			multipleCounter -= (multipleCounter > 4) * 4;
			if(inc current < currentWall){
				jmp readRowLoop;
			}
			if((current -= widthTwice) >= data){
				fseek(file, 4 - multipleCounter, SEEK_CUR);
				multipleCounter = 0;
				currentWall -= width;
				jmp readRowLoop;
			}
			jmp successfulImage;
		}
	}
	successfulImage:{
		fclose(file);
		popPointer(fileToken);
		(*image).dataStart = data;
		(*image).dataToken = dataToken;
		ret SUCCESS_READ_CONFIG;
	}
	failedImage:{
		free(data);
		popPointer(dataToken);
		if(file){
			fclose(file);
			popPointer(fileToken);
		}
		ret returnValue;
	}
	#undef  BI_CMYKRLE4
	#undef  BI_CMYKRLE8
	#undef  BI_CMYK
	#undef  BI_ALPHABITFIELDS
	#undef  BI_PNG
	#undef  BI_JPEG
	#undef  BI_BITFIELDS
	#undef  BI_RLE4
	#undef  BI_RLE8
	#undef  BI_RGB
	#undef  BITMAPV5HEADER
	#undef  BITMAPV4HEADER
	#undef  BITMAPV3INFOHEADER
	#undef  BITMAPV2INFOHEADER
	#undef  BITMAPINFOHEADER
	#undef  OS22XBITMAPHEADER
	#undef  BITMAPCOREHEADER
	#undef  FILE_HEADER_SIZE
}
FREECONFIGVARIABLES(){
	if(windowCirclePixmap){
		xcb_free_pixmap(connection, windowCirclePixmap);
	}
	if(font){
		xcb_close_font(connection, font);
	}
	ret;
}
MATCHCOMMAND(){
	uint8 commandReturned = TYPICAL_SWITCH_COMMAND;
	if(origin <= RELEASE_SWITCH_COMMAND_ORIGIN){
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
	}
	switch origin over
		to PRESS_SWITCH_COMMAND_ORIGIN: /*-------*/ printCommand("press"); /*-------*/ jmp pressCommand;
		to RELEASE_SWITCH_COMMAND_ORIGIN: /*-----*/ printCommand("release"); /*-----*/ jmp releaseCommand;
		to CONFIG_SWITCH_COMMAND_ORIGIN: /*------*/ printCommand("config"); /*------*/ jmp configCommand;
		to STDIN_SWITCH_COMMAND_ORIGIN: /*-------*/ printCommand("stdin"); /*-------*/ jmp configCommand;
		to TRANSMITTER_SWITCH_COMMAND_ORIGIN: /*-*/ printCommand("transmitter"); /*-*/ jmp configCommand;
		off: /*----------------------------------*/ /*------------------------------*/ jmp emergencyExit;
	end
	pressCommand: switch command over
		to NONE_COMMAND: /*--------------------*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*-----------------*/ jmp executeCommand;
		to TO_NEXT_LETTER_COMMAND: /*----------*/ jmp toNextLetterCommand;
		to TO_PREVIOUS_LETTER_COMMAND: /*------*/ jmp toPreviousLetterCommand;
		to TO_NEXT_WORD_COMMAND: /*------------*/ jmp toNextWordCommand;
		to TO_PREVIOUS_WORD_COMMAND: /*--------*/ jmp toPreviousWordCommand;
		to TO_START_OF_LINE_COMMAND: /*--------*/ jmp toStartOfLineCommand;
		to TO_END_OF_LINE_COMMAND: /*----------*/ jmp toEndOfLineCommand;
		to TO_NEXT_RESULT_COMMAND: /*----------*/ jmp toNextResultCommand;
		to TO_PREVIOUS_RESULT_COMMAND: /*------*/ jmp toPreviousResultCommand;
		to REMOVE_LEFT_LETTER_COMMAND: /*------*/ jmp removeLeftLetterCommand;
		to REMOVE_RIGHT_LETTER_COMMAND: /*-----*/ jmp removeRightLetterCommand;
		to REMOVE_LEFT_WORD_COMMAND: /*--------*/ jmp removeLeftWordCommand;
		to REMOVE_RIGHT_WORD_COMMAND: /*-------*/ jmp removeRightWordCommand;
		to SELECT_LEFT_LETTER_COMMAND: /*------*/ jmp selectLeftLetterCommand;
		to SELECT_RIGHT_LETTER_COMMAND: /*-----*/ jmp selectRightLetterCommand;
		to SELECT_LEFT_WORD_COMMAND: /*--------*/ jmp selectLeftWordCommand;
		to SELECT_RIGHT_WORD_COMMAND: /*-------*/ jmp selectRightWordCommand;
		to SELECT_TO_START_OF_LINE_COMMAND: /*-*/ jmp selectToStartOfLineCommand;
		to SELECT_TO_END_OF_LINE_COMMAND: /*---*/ jmp selectToEndOfLineCommand;
		to SELECT_ALL_COMMAND: /*--------------*/ jmp selectAllCommand;
		to COPY_SELECTION_COMMAND: /*----------*/ jmp copySelectionCommand;
		to CUT_SELECTION_COMMAND: /*-----------*/ jmp cutSelectionCommand;
		to PASTE_SELECTION_COMMAND: /*---------*/ jmp pasteSelectionCommand;
		to UPPERCASE_SELECTION_COMMAND: /*-----*/ jmp uppercaseSelectionCommand;
		to LOWERCASE_SELECTION_COMMAND: /*-----*/ jmp lowercaseSelectionCommand;
		to TOGGLE_INSERT_MODE_COMMAND: /*------*/ jmp toggleInsertModeCommand;
		to PICK_RESULT_COMMAND: /*-------------*/ jmp pickResultCommand;
		to LAUNCH_COMMAND: /*------------------*/ jmp launchCommand;
		to RESTART_COMMAND: /*-----------------*/ jmp restartCommand;
		to EXIT_COMMAND: /*--------------------*/ jmp exitCommand;
		off: /*--------------------------------*/ jmp unrecognizedCommand;
	end
	releaseCommand: switch command over
		to NONE_COMMAND: /*--------------------*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*-----------------*/ jmp noneCommand;
		to TO_NEXT_LETTER_COMMAND: /*----------*/ jmp noneCommand;
		to TO_PREVIOUS_LETTER_COMMAND: /*------*/ jmp noneCommand;
		to TO_NEXT_WORD_COMMAND: /*------------*/ jmp noneCommand;
		to TO_PREVIOUS_WORD_COMMAND: /*--------*/ jmp noneCommand;
		to TO_START_OF_LINE_COMMAND: /*--------*/ jmp noneCommand;
		to TO_END_OF_LINE_COMMAND: /*----------*/ jmp noneCommand;
		to TO_NEXT_RESULT_COMMAND: /*----------*/ jmp noneCommand;
		to TO_PREVIOUS_RESULT_COMMAND: /*------*/ jmp noneCommand;
		to REMOVE_LEFT_LETTER_COMMAND: /*------*/ jmp noneCommand;
		to REMOVE_RIGHT_LETTER_COMMAND: /*-----*/ jmp noneCommand;
		to REMOVE_LEFT_WORD_COMMAND: /*--------*/ jmp noneCommand;
		to REMOVE_RIGHT_WORD_COMMAND: /*-------*/ jmp noneCommand;
		to SELECT_LEFT_LETTER_COMMAND: /*------*/ jmp noneCommand;
		to SELECT_RIGHT_LETTER_COMMAND: /*-----*/ jmp noneCommand;
		to SELECT_LEFT_WORD_COMMAND: /*--------*/ jmp noneCommand;
		to SELECT_RIGHT_WORD_COMMAND: /*-------*/ jmp noneCommand;
		to SELECT_TO_START_OF_LINE_COMMAND: /*-*/ jmp noneCommand;
		to SELECT_TO_END_OF_LINE_COMMAND: /*---*/ jmp noneCommand;
		to SELECT_ALL_COMMAND: /*--------------*/ jmp noneCommand;
		to COPY_SELECTION_COMMAND: /*----------*/ jmp noneCommand;
		to CUT_SELECTION_COMMAND: /*-----------*/ jmp noneCommand;
		to PASTE_SELECTION_COMMAND: /*---------*/ jmp noneCommand;
		to UPPERCASE_SELECTION_COMMAND: /*-----*/ jmp noneCommand;
		to LOWERCASE_SELECTION_COMMAND: /*-----*/ jmp noneCommand;
		to TOGGLE_INSERT_MODE_COMMAND: /*------*/ jmp noneCommand;
		to PICK_RESULT_COMMAND: /*-------------*/ jmp noneCommand;
		to LAUNCH_COMMAND: /*------------------*/ jmp noneCommand;
		to RESTART_COMMAND: /*-----------------*/ jmp noneCommand;
		to EXIT_COMMAND: /*--------------------*/ jmp noneCommand;
		off: /*--------------------------------*/ jmp unrecognizedCommand;
	end
	configCommand: switch command over
		to NONE_COMMAND: /*--------------------*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*-----------------*/ jmp executeCommand;
		to TO_NEXT_LETTER_COMMAND: /*----------*/ jmp toNextLetterCommand;
		to TO_PREVIOUS_LETTER_COMMAND: /*------*/ jmp toPreviousLetterCommand;
		to TO_NEXT_WORD_COMMAND: /*------------*/ jmp toNextWordCommand;
		to TO_PREVIOUS_WORD_COMMAND: /*--------*/ jmp toPreviousWordCommand;
		to TO_START_OF_LINE_COMMAND: /*--------*/ jmp toStartOfLineCommand;
		to TO_END_OF_LINE_COMMAND: /*----------*/ jmp toEndOfLineCommand;
		to TO_NEXT_RESULT_COMMAND: /*----------*/ jmp toNextResultCommand;
		to TO_PREVIOUS_RESULT_COMMAND: /*------*/ jmp toPreviousResultCommand;
		to REMOVE_LEFT_LETTER_COMMAND: /*------*/ jmp removeLeftLetterCommand;
		to REMOVE_RIGHT_LETTER_COMMAND: /*-----*/ jmp removeRightLetterCommand;
		to REMOVE_LEFT_WORD_COMMAND: /*--------*/ jmp removeLeftWordCommand;
		to REMOVE_RIGHT_WORD_COMMAND: /*-------*/ jmp removeRightWordCommand;
		to SELECT_LEFT_LETTER_COMMAND: /*------*/ jmp selectLeftLetterCommand;
		to SELECT_RIGHT_LETTER_COMMAND: /*-----*/ jmp selectRightLetterCommand;
		to SELECT_LEFT_WORD_COMMAND: /*--------*/ jmp selectLeftWordCommand;
		to SELECT_RIGHT_WORD_COMMAND: /*-------*/ jmp selectRightWordCommand;
		to SELECT_TO_START_OF_LINE_COMMAND: /*-*/ jmp selectToStartOfLineCommand;
		to SELECT_TO_END_OF_LINE_COMMAND: /*---*/ jmp selectToEndOfLineCommand;
		to SELECT_ALL_COMMAND: /*--------------*/ jmp selectAllCommand;
		to COPY_SELECTION_COMMAND: /*----------*/ jmp copySelectionCommand;
		to CUT_SELECTION_COMMAND: /*-----------*/ jmp cutSelectionCommand;
		to PASTE_SELECTION_COMMAND: /*---------*/ jmp pasteSelectionCommand;
		to UPPERCASE_SELECTION_COMMAND: /*-----*/ jmp uppercaseSelectionCommand;
		to LOWERCASE_SELECTION_COMMAND: /*-----*/ jmp lowercaseSelectionCommand;
		to TOGGLE_INSERT_MODE_COMMAND: /*------*/ jmp toggleInsertModeCommand;
		to PICK_RESULT_COMMAND: /*-------------*/ jmp pickResultCommand;
		to LAUNCH_COMMAND: /*------------------*/ jmp launchCommand;
		to RESTART_COMMAND: /*-----------------*/ jmp restartCommand;
		to EXIT_COMMAND: /*--------------------*/ jmp exitCommand;
		off: /*--------------------------------*/ jmp unrecognizedCommand;
	end
	noneCommand:{
		jmp emergencyExit;
	}
	executeCommand:{
		exec((*eventModifierNode).string);
		jmp emergencyExit;
	}
	toNextLetterCommand:{
		gotoRight(&inputBuffer, CHARACTER_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	toPreviousLetterCommand:{
		gotoLeft(&inputBuffer, CHARACTER_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	toNextWordCommand:{
		gotoRight(&inputBuffer, WORD_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	toPreviousWordCommand:{
		gotoLeft(&inputBuffer, WORD_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	toStartOfLineCommand:{
		gotoStart(&inputBuffer);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	toEndOfLineCommand:{
		gotoEnd(&inputBuffer);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	toNextResultCommand:{
		if(currentSelectedResult < (int)asciiRoot.stringsFoundAmount - 1){
			inc currentSelectedResult;
		}elif(resultAllowCircularNavigation and currentSelectedResult != -1){
			currentSelectedResult = 0;
		}
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	toPreviousResultCommand:{
		if(currentSelectedResult > 0){
			dec currentSelectedResult;
		}elif(currentSelectedResult == -1 or resultAllowCircularNavigation){
			currentSelectedResult = (int)asciiRoot.stringsFoundAmount - 1;
		}
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	removeLeftLetterCommand:{
		removeText(&inputBuffer, LEFT_DIRECTION, CHARACTER_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	removeRightLetterCommand:{
		removeText(&inputBuffer, RIGHT_DIRECTION, CHARACTER_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	removeLeftWordCommand:{
		removeText(&inputBuffer, LEFT_DIRECTION, WORD_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	removeRightWordCommand:{
		removeText(&inputBuffer, RIGHT_DIRECTION, WORD_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	selectLeftLetterCommand:{
		selectText(&inputBuffer, LEFT_DIRECTION, CHARACTER_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	selectRightLetterCommand:{
		selectText(&inputBuffer, RIGHT_DIRECTION, CHARACTER_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	selectLeftWordCommand:{
		selectText(&inputBuffer, LEFT_DIRECTION, WORD_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	selectRightWordCommand:{
		selectText(&inputBuffer, RIGHT_DIRECTION, WORD_MATCH_LENGTH);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	selectToStartOfLineCommand:{
		selectStart(&inputBuffer);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	selectToEndOfLineCommand:{
		selectEnd(&inputBuffer);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	selectAllCommand:{
		selectAll(&inputBuffer);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	copySelectionCommand:{
		if(inputBuffer.selectedDataCurrent){
			copySelected(&inputBuffer);
			getResults(&inputBuffer);
			updateWindow();
		}
		jmp emergencyExit;
	}
	cutSelectionCommand:{
		if(inputBuffer.selectedDataCurrent){
			copySelected(&inputBuffer);
			removeSelected(&inputBuffer);
			getResults(&inputBuffer);
			updateWindow();
		}
		jmp emergencyExit;
	}
	pasteSelectionCommand:{
		pasteClipboard(&inputBuffer);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	uppercaseSelectionCommand:{
		toCase(&inputBuffer, UPPER_CASE);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	lowercaseSelectionCommand:{
		toCase(&inputBuffer, LOWER_CASE);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	toggleInsertModeCommand:{
		changeMode();
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	pickResultCommand:{
		pickResult(&inputBuffer);
		getResults(&inputBuffer);
		updateWindow();
		jmp emergencyExit;
	}
	launchCommand:{
		launch(&inputBuffer);
		commandReturned = EXIT_SWITCH_COMMAND;
		jmp emergencyExit;
	}
	restartCommand:{
		commandReturned = RESTART_SWITCH_COMMAND;
		jmp emergencyExit;
	}
	exitCommand:{
		commandReturned = EXIT_SWITCH_COMMAND;
		jmp emergencyExit;
	}
	unrecognizedCommand:{
		printTitledValuedError("command error", "executed unrecognized command with type", command);
		jmp emergencyExit;
	}
	emergencyExit:{
		if(origin <= RELEASE_SWITCH_COMMAND_ORIGIN){
			if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock globals write lock");
			}
		}
		ret commandReturned;
	}
}
EXEC(){
	#define FORK_FAILURE /*-------*/ (-1)
	#define CHILD_FORK_PROCESS /*-*/ (0)
	switch fork() over
		to FORK_FAILURE:{
			printTitledError("fork error", "could not execute shell command");
			ret;
		}
		to CHILD_FORK_PROCESS:{
			setsid();
			execl("/bin/sh", "sh", "-c", string, NULL);
			printTitledError("fork error", "shell command returned an error");
			exit(EXIT_SUCCESS);
		}
		off:{
			ret;
		}
	end
	#undef  CHILD_FORK_PROCESS
	#undef  FORK_FAILURE
}
SETMEMORY(){
	switch perByteAmount over
		to sizeof(uint8): /*--*/ jmp perByte;
		to sizeof(uint16): /*-*/ jmp perTwoBytes;
		to sizeof(uint32): /*-*/ jmp perFourBytes;
		to sizeof(uint64): /*-*/ jmp perEightBytes;
		off: /*---------------*/ ret;
	end
	perByte:{
		const uint8 value8 = value;
		uint8 *current = destinationStart;
		uint8 *const wall = current + itemAmount;
		jmp perByteLoop;
		perByteLoop:{
			if(current < wall){
				*current = value8;
				inc current;
				jmp perByteLoop;
			}
			ret;
		}
	}
	perTwoBytes:{
		const uint16 value16 = value;
		uint16 *current = destinationStart;
		uint16 *const wall = current + itemAmount;
		jmp perTwoBytesLoop;
		perTwoBytesLoop:{
			if(current < wall){
				*current = value16;
				inc current;
				jmp perTwoBytesLoop;
			}
			ret;
		}
	}
	perFourBytes:{
		const uint32 value32 = value;
		uint32 *current = destinationStart;
		uint32 *const wall = current + itemAmount;
		jmp perFourBytesLoop;
		perFourBytesLoop:{
			if(current < wall){
				*current = value32;
				inc current;
				jmp perFourBytesLoop;
			}
			ret;
		}
	}
	perEightBytes:{
		const uint64 value64 = value;
		uint64 *current = destinationStart;
		uint64 *const wall = current + itemAmount;
		jmp perEightBytesLoop;
		perEightBytesLoop:{
			if(current < wall){
				*current = value64;
				inc current;
				jmp perEightBytesLoop;
			}
			ret;
		}
	}
}
COPYMEMORY(){
	const uint largeAmount = byteAmount / sizeof(uint64);
	const uint smallAmount = byteAmount % sizeof(uint64);
	void *sourceCurrent = sourceStart;
	void *destinationCurrent = destinationStart;
	void *sourceWall = (uint64 *)sourceCurrent + largeAmount;
	jmp largeLoop;
	largeLoop:{
		if((uint64 *)sourceCurrent < (uint64 *)sourceWall){
			*(uint64 *)destinationCurrent = *(uint64 *)sourceCurrent;
			sourceCurrent = (uint64 *)sourceCurrent + 1;
			destinationCurrent = (uint64 *)destinationCurrent + 1;
			jmp largeLoop;
		}
		sourceWall = (uint8 *)sourceCurrent + smallAmount;
		jmp smallLoop;
	}
	smallLoop:{
		if((uint8 *)sourceCurrent < (uint8 *)sourceWall){
			*(uint8 *)destinationCurrent = *(uint8 *)sourceCurrent;
			sourceCurrent = (uint8 *)sourceCurrent + 1;
			destinationCurrent = (uint8 *)destinationCurrent + 1;
			jmp smallLoop;
		}
		ret;
	}
}
FINDSTRINGLENGTH(){
	const uint8 *current = string;
	jmp advanceStringPointerLoop;
	advanceStringPointerLoop:{
		if(*current){
			inc current;
			jmp advanceStringPointerLoop;
		}
		ret current - (uint8 *)string;
	}
}
UTF8TOUCS2(){
	uint16 *ucs2Current = ucs2Start;
	uint16 *const ucs2Wall = ucs2Current + ucs2Length;
	jmp loop;
	loop:{
		if(*utf8 and ucs2Current < ucs2Wall){
			uint16 newUCS2;
			uint8 byte1 = *utf8;
			if(byte1 < b(10000000)){
				newUCS2 = byte1;
				byte1 = '\0';
				inc utf8;
			}elif((byte1 & b(11100000)) == b(11000000)){
				const uint8 byte2 = *(utf8 + 1);
				if((byte2 & b(11000000)) == b(10000000)){
					newUCS2 = ((byte1 & b(00011111)) << 6) | (byte2 & b(00111111));
					byte1 = '\0';
					utf8 += 2;
				}else{
					inc utf8;
				}
			}elif((byte1 & b(11110000)) == b(11100000)){
				const uint8 byte2 = *(utf8 + 1);
				const uint8 byte3 = *(utf8 + 2);
				if((byte2 & b(11000000)) == b(10000000) and (byte3 & b(11000000)) == b(10000000)){
					newUCS2 = ((byte1 & b(00001111)) << 12) | ((byte2 & b(00111111)) << 6) | (byte3 & b(00111111));
					byte1 = '\0';
					utf8 += 3;
				}else{
					inc utf8;
				}
			}elif((byte1 & b(11111000)) == b(11110000)){
				const uint8 byte2 = *(utf8 + 1);
				const uint8 byte3 = *(utf8 + 2);
				const uint8 byte4 = *(utf8 + 3);
				if((byte2 & b(11000000)) == b(10000000) and (byte3 & b(11000000)) == b(10000000) and (byte4 & b(11000000)) == b(10000000)){
					utf8 += 4;
				}else{
					inc utf8;
				}
			}else{
				inc utf8;
			}
			if(!byte1){
				*ucs2Current = (newUCS2 << 8) | (newUCS2 >> 8);
				inc ucs2Current;
			}
			jmp loop;
		}
		ret ucs2Current - ucs2Start;
	}
}
GETTIMESTAMP(){
	uint offset;
	if(!event){
		jmp invalidTimestamp;
	}
	offset = 0;
	jmp checkEventValidity;
	checkEventValidity: switch (*event).response_type over
		to XCB_KEY_PRESS: /*---------*/ /*-------*/ jmp validTimestamp;
		to XCB_KEY_RELEASE: /*-------*/ /*-------*/ jmp validTimestamp;
		to XCB_BUTTON_PRESS: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_BUTTON_RELEASE: /*----*/ /*-------*/ jmp validTimestamp;
		to XCB_MOTION_NOTIFY: /*-----*/ /*-------*/ jmp validTimestamp;
		to XCB_ENTER_NOTIFY: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_LEAVE_NOTIFY: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_PROPERTY_NOTIFY: /*---*/ offset = 2; jmp validTimestamp;
		to XCB_SELECTION_CLEAR: /*---*/ /*-------*/ jmp validTimestamp;
		to XCB_SELECTION_REQUEST: /*-*/ /*-------*/ jmp validTimestamp;
		to XCB_SELECTION_NOTIFY: /*--*/ /*-------*/ jmp validTimestamp;
		off: /*----------------------*/ /*-------*/ jmp invalidTimestamp;
	end
	invalidTimestamp:{
		ret XCB_CURRENT_TIME;
	}
	validTimestamp:{
		ret *(xcb_timestamp_t *)((*event).pad + offset);
	}
}
GETPOINTERMONITOR(){
	if(monitorAllocated > 1){
		xcb_query_pointer_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_pointer_unchecked(connection, (*screen).root), NULL);
		uint32 token = pushPointer(reply, "get pointer monitor reply", iFree);
		if(reply){
			const int x = (*reply).root_x;
			const int y = (*reply).root_y;
			Monitor *current = monitorStart;
			Monitor *const wall = current + monitorAllocated;
			free(reply);
			popPointer(token);
			jmp loop;
			loop:{
				if(x >= (*current).leftX and x < (*current).rightX and y >= (*current).topY and y < (*current).bottomY){
					ret current;
				}
				if(inc current < wall){
					jmp loop;
				}
			}
		}
	}
	ret monitorStart;
}
GETWINDOWMONITOR(){
	if(monitorAllocated > 0){
		const xcb_get_geometry_cookie_t geometryCookie = xcb_get_geometry_unchecked(connection, window);
		const xcb_translate_coordinates_cookie_t translateCoordinatesCookie = xcb_translate_coordinates_unchecked(connection, window, (*screen).root, 0, 0);
		xcb_get_geometry_reply_t *const getGeometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);
		uint32 getGeometryToken = pushPointer(getGeometryReply, "getWindowMonitor() get geometry reply", iFree);
		xcb_translate_coordinates_reply_t *const translateCoordinatesReply = xcb_wait_for_reply(connection, translateCoordinatesCookie, NULL);
		uint32 translateCoordinatesToken = pushPointer(translateCoordinatesReply, "getWindowMonitor() translate coordinates reply", iFree);
		Monitor *monitor = NULL;
		if(getGeometryReply and translateCoordinatesReply){
			const int width = (*getGeometryReply).width + 2 * (*getGeometryReply).border_width;
			const int height = (*getGeometryReply).height + 2 * (*getGeometryReply).border_width;
			const int leftX = (*translateCoordinatesReply).dst_x;
			const int topY = (*translateCoordinatesReply).dst_y;
			const int rightX = leftX + width;
			const int bottomY = topY + height;
			Monitor *current = monitorStart;
			Monitor *const wall = current + monitorAllocated;
			int mostPixels = 0;
			jmp loop;
			loop:{
				if((*current).leftX < rightX and (*current).rightX > leftX and (*current).topY < bottomY and (*current).bottomY > topY){
					const int w = ((*current). rightX <  rightX? (*current). rightX :  rightX) - ((*current).leftX > leftX? (*current).leftX : leftX);
					const int h = ((*current).bottomY < bottomY? (*current).bottomY : bottomY) - ((*current). topY >  topY? (*current). topY :  topY);
					const int pixels = w * h;
					if(pixels > mostPixels){
						mostPixels = pixels;
						monitor = current;
					}
				}
				if(inc current < wall){
					jmp loop;
				}
			}
		}
		free(getGeometryReply);
		popPointer(getGeometryToken);
		free(translateCoordinatesReply);
		popPointer(translateCoordinatesToken);
		ret monitor;
	}
	ret NULL;
}
CREATECIRCLE(){
	const uint width = radius * 2 + 1;
	const uint height = width;
	const int r2 = radius * radius;
	uint32 *data = malloc(width * height * sizeof(uint32));
	uint32 token = pushPointer(data, "createCorner() data pointer", iFree);
	int y = -radius;
	uint32 *currentData = data;
	if(!data){
		ret false;
	}
	jmp yLoop;
	yLoop:{
		if(y <= radius){
			const int y2 = y * y;
			int x = -radius;
			jmp xLoop;
			xLoop:{
				if(x <= radius){
					const int x2y2 = x * x + y2;
					if(x2y2 <= r2){
						*currentData = foreground;
					}else{
						*currentData = background;
					}
					inc currentData;
					inc x;
					jmp xLoop;
				}
				inc y;
				jmp yLoop;
			}
		}
		(*image).dataStart = data;
		(*image).dataToken = token;
		(*image).size = width * height * sizeof(uint32);
		(*image).x = 0;
		(*image).y = 0;
		(*image).width = width;
		(*image).height = height;
		ret true;
	}
}
COMPOSITEIMAGES(){
	int intersectionWidth;
	int intersectionHeight;
	uint32 *sourceCurrent;
	uint32 *sourceWidthWall;
	uint32 *sourceWall;
	uint32 *destinationCurrent;
	if(sourceX < 0 or sourceY < 0 or sourceX >= (*source).width or sourceY >= (*source).height){
		ret;
	}
	{
		const int b1lx = 0;
		const int b1ty = 0;
		const int b1rx = (*destination).width;
		const int b1by = (*destination).height;
		const int b2lx = destinationX;
		const int b2ty = destinationY;
		const int b2rx = b2lx + (*source).width - sourceX;
		const int b2by = b2ty + (*source).height - sourceY;
		intersectionWidth = (b1rx < b2rx? b1rx : b2rx) - (b1lx > b2lx? b1lx : b2lx);
		intersectionHeight = (b1by < b2by? b1by : b2by) - (b1ty > b2ty? b1ty : b2ty);
		if(intersectionWidth < 1 or intersectionWidth < 1){
			ret;
		}
	}
	sourceCurrent = (uint32 *)(*source).dataStart + sourceY * (*source).width + sourceX;
	if(destinationX < 0){
		sourceCurrent -= destinationX;
		destinationX = 0;
	}
	if(destinationY < 0){
		sourceCurrent -= destinationY * (*source).width;
		destinationY = 0;
	}
	sourceWidthWall = sourceCurrent + intersectionWidth;
	sourceWall = sourceCurrent + intersectionHeight * (*source).width;
	destinationCurrent = (uint32 *)(*destination).dataStart + destinationY * (*destination).width + destinationX;
	jmp yLoop;
	yLoop:{
		if(sourceCurrent < sourceWall){
			jmp xLoop;
			xLoop:{
				if(sourceCurrent < sourceWidthWall){
					operation(sourceCurrent, destinationCurrent);
					inc sourceCurrent;
					inc destinationCurrent;
					jmp xLoop;
				}
				sourceCurrent += (*source).width - intersectionWidth;
				sourceWidthWall += (*source).width;
				destinationCurrent += (*destination).width - intersectionWidth;
				jmp yLoop;
			}
		}
		ret;
	}
}
COMPOSITEIMAGESOVER(){
	const uint32 s = *source;
	const uint32 d = *destination;
	const uint64 a_a = s >> 24;
	if(a_a == 0xFF){
		*destination = s;
		ret;
	}
	if(a_a){
		const uint32 r_a = (s & 0x00FF0000) >> 16;
		const uint32 g_a = (s & 0x0000FF00) >> 8;
		const uint32 b_a = (s & 0x000000FF) >> 0;
		const uint32 a_b = d >> 24;
		const uint32 r_b = (d & 0x00FF0000) >> 16;
		const uint32 g_b = (d & 0x0000FF00) >> 8;
		const uint32 b_b = (d & 0x000000FF) >> 0;
		const uint32 a_0 = a_a + a_b * (0xFF - a_a) / 0xFF;
		const uint32 r = (r_a * a_a + r_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		const uint32 g = (g_a * a_a + g_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		const uint32 b = (b_a * a_a + b_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		*destination = (a_0 << 24) + ((r & 0x000000FF) << 16) + ((g & 0x000000FF) << 8) + ((b & 0x000000FF) << 0);
		ret;
	}
	ret;
}
COMPOSITEIMAGESAND(){
	if(!(*source >> 24)){
		*destination = 0x00000000;
		ret;
	}
	ret;
}
TWOPASSBOXBLUR(){
	uint32 *intermediateData;
	uint32 *kernelColumnRStart;
	uint32 *kernelColumnGStart;
	uint32 *kernelColumnBStart;
	uint32 *pixelRStart;
	uint32 *pixelGStart;
	uint32 *pixelBStart;
	if(boxSize == 1){
		ret;
	}
	intermediateData = malloc(width * height * sizeof(uint32));
	kernelColumnRStart = malloc(boxSize + 2 * width * sizeof(uint32));
	kernelColumnGStart = malloc(boxSize + 2 * width * sizeof(uint32));
	kernelColumnBStart = malloc(boxSize + 2 * width * sizeof(uint32));
	pixelRStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	pixelGStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	pixelBStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	{
		const int divisor = boxSize * boxSize;
		const int boxDistanceFromZero = boxSize >> 1;
		const int nBoxDistanceFromZero = -boxDistanceFromZero;
		const int widthMinusOne = width - 1;
		const int heightMinusOne = height - 1;
		const int heightMinusBoxSize = height - boxSize;
		uint32 *tx = destinationData;
		uint32 *txCopy = tx;
		uint32 *rx = intermediateData;
		uint32 r;
		uint32 g;
		uint32 b;
		jmp loop;
		loop:{
			uint32 *kernelColumnRCurrent = kernelColumnRStart;
			uint32 *kernelColumnGCurrent = kernelColumnGStart;
			uint32 *kernelColumnBCurrent = kernelColumnBStart;
			uint32 *kernelColumnRCurrentCopy = kernelColumnRStart;
			uint32 *kernelColumnGCurrentCopy = kernelColumnGStart;
			uint32 *kernelColumnBCurrentCopy = kernelColumnBStart;
			uint32 *pixelRCurrent = pixelRStart;
			uint32 *pixelGCurrent = pixelGStart;
			uint32 *pixelBCurrent = pixelBStart;
			uint32 *pixelRCurrentCopy = pixelRStart;
			uint32 *pixelGCurrentCopy = pixelGStart;
			uint32 *pixelBCurrentCopy = pixelBStart;
			int x = 0;
			int y = 0;
			{
				int kx = nBoxDistanceFromZero;
				r = 0;
				g = 0;
				b = 0;
				while(kx <= boxDistanceFromZero){
					int ky = nBoxDistanceFromZero;
					int usedX = x + kx;
					if(usedX < 0){
						usedX = 0;
					}
					*kernelColumnRCurrent = 0;
					*kernelColumnGCurrent = 0;
					*kernelColumnBCurrent = 0;
					tx += usedX;
					while(ky <= boxDistanceFromZero){
						int usedY = y + ky;
						uint32 color;
						if(usedY < 0){
							usedY = 0;
						}
						color = *(tx + usedY * width);
						*pixelRCurrent = (color & 0xFF0000) >> 16;
						*pixelGCurrent = (color & 0x00FF00) >>  8;
						*pixelBCurrent =  color & 0x0000FF;
						*kernelColumnRCurrent += *pixelRCurrent;
						*kernelColumnGCurrent += *pixelGCurrent;
						*kernelColumnBCurrent += *pixelBCurrent;
						inc pixelRCurrent;
						inc pixelGCurrent;
						inc pixelBCurrent;
						inc ky;
					}
					tx -= usedX;
					r += *kernelColumnRCurrent;
					g += *kernelColumnGCurrent;
					b += *kernelColumnBCurrent;
					pixelRCurrent += heightMinusBoxSize;
					pixelGCurrent += heightMinusBoxSize;
					pixelBCurrent += heightMinusBoxSize;
					inc kernelColumnRCurrent;
					inc kernelColumnGCurrent;
					inc kernelColumnBCurrent;
					inc kx;
				}
				*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
				inc rx;
			}
			inc x;
			xFirstLoop:{
				int kx = boxDistanceFromZero;
				int ky = nBoxDistanceFromZero;
				int usedX = x + kx;
				if(usedX < 0){
					usedX = 0;
				}elif(usedX >= width){
					usedX = widthMinusOne;
				}
				r -= *kernelColumnRCurrentCopy;
				g -= *kernelColumnGCurrentCopy;
				b -= *kernelColumnBCurrentCopy;
				kernelColumnRCurrent = kernelColumnRCurrentCopy + boxSize;
				kernelColumnGCurrent = kernelColumnGCurrentCopy + boxSize;
				kernelColumnBCurrent = kernelColumnBCurrentCopy + boxSize;
				inc kernelColumnRCurrentCopy;
				inc kernelColumnGCurrentCopy;
				inc kernelColumnBCurrentCopy;
				{
					uint32 lr = 0;
					uint32 lg = 0;
					uint32 lb = 0;
					tx += usedX;
					while(ky <= boxDistanceFromZero){
						int usedY = y + ky;
						uint32 color;
						if(usedY < 0){
							usedY = 0;
						}elif(usedY >= height){
							usedY = heightMinusOne;
						}
						color = *(tx + usedY * width);
						*pixelRCurrent = (color & 0xFF0000) >> 16;
						*pixelGCurrent = (color & 0x00FF00) >>  8;
						*pixelBCurrent =  color & 0x0000FF;
						lr += *pixelRCurrent;
						lg += *pixelGCurrent;
						lb += *pixelBCurrent;
						inc pixelRCurrent;
						inc pixelGCurrent;
						inc pixelBCurrent;
						inc ky;
					}
					tx -= usedX;
					r += lr;
					g += lg;
					b += lb;
					*kernelColumnRCurrent = lr;
					*kernelColumnGCurrent = lg;
					*kernelColumnBCurrent = lb;
					pixelRCurrent += heightMinusBoxSize;
					pixelGCurrent += heightMinusBoxSize;
					pixelBCurrent += heightMinusBoxSize;
				}
				*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
				inc rx;
				if(inc x < width){
					jmp xFirstLoop;
				}
			}
			inc y;
			yLoop:{
				uint32 *pr;
				uint32 *pg;
				uint32 *pb;
				int ky = boxDistanceFromZero;
				int usedY = y + ky;
				if(usedY < 0){
					usedY = 0;
				}elif(usedY >= height){
					usedY = heightMinusOne;
				}
				x = 0;
				{
					int kx = nBoxDistanceFromZero;
					kernelColumnRCurrent = kernelColumnRStart;
					kernelColumnGCurrent = kernelColumnGStart;
					kernelColumnBCurrent = kernelColumnBStart;
					kernelColumnRCurrentCopy = kernelColumnRStart;
					kernelColumnGCurrentCopy = kernelColumnGStart;
					kernelColumnBCurrentCopy = kernelColumnBStart;
					pixelRCurrent = pixelRCurrentCopy;
					pixelGCurrent = pixelGCurrentCopy;
					pixelBCurrent = pixelBCurrentCopy;
					pr = pixelRCurrent + boxSize;
					pg = pixelGCurrent + boxSize;
					pb = pixelBCurrent + boxSize;
					r = 0;
					g = 0;
					b = 0;
					tx += usedY * width;
					while(kx <= boxDistanceFromZero){
						int usedX = x + kx;
						uint32 color;
						if(usedX < 0){
							usedX = 0;
						}elif(usedX >= width){
							usedX = widthMinusOne;
						}
						color = *(tx + usedX);
						*pr = (color & 0xFF0000) >> 16;
						*pg = (color & 0x00FF00) >>  8;
						*pb =  color & 0x0000FF;
						*kernelColumnRCurrent += *pr - *pixelRCurrent;
						*kernelColumnGCurrent += *pg - *pixelGCurrent;
						*kernelColumnBCurrent += *pb - *pixelBCurrent;
						r += *kernelColumnRCurrent;
						g += *kernelColumnGCurrent;
						b += *kernelColumnBCurrent;
						pixelRCurrent += height;
						pixelGCurrent += height;
						pixelBCurrent += height;
						pr += height;
						pg += height;
						pb += height;
						inc kernelColumnRCurrent;
						inc kernelColumnGCurrent;
						inc kernelColumnBCurrent;
						inc kx;
					}
					tx -= usedY * width;
					*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
					inc rx;
					inc x;
				}
				{
					int usedX = x + boxDistanceFromZero;
					usedY *= width;
					tx += usedY;
					xLoop:{
						uint32 color;
						if(usedX >= width){
							usedX = widthMinusOne;
						}
						kernelColumnRCurrent = kernelColumnRCurrentCopy + boxSize;
						kernelColumnGCurrent = kernelColumnGCurrentCopy + boxSize;
						kernelColumnBCurrent = kernelColumnBCurrentCopy + boxSize;
						r -= *kernelColumnRCurrentCopy;
						g -= *kernelColumnGCurrentCopy;
						b -= *kernelColumnBCurrentCopy;
						color = *(tx + usedX);
						*pr = (color & 0xFF0000) >> 16;
						*pg = (color & 0x00FF00) >>  8;
						*pb =  color & 0x0000FF;
						*kernelColumnRCurrent += *pr - *pixelRCurrent;
						*kernelColumnGCurrent += *pg - *pixelGCurrent;
						*kernelColumnBCurrent += *pb - *pixelBCurrent;
						r += *kernelColumnRCurrent;
						g += *kernelColumnGCurrent;
						b += *kernelColumnBCurrent;
						inc kernelColumnRCurrentCopy;
						inc kernelColumnGCurrentCopy;
						inc kernelColumnBCurrentCopy;
						pixelRCurrent += height;
						pixelGCurrent += height;
						pixelBCurrent += height;
						pr += height;
						pg += height;
						pb += height;
						*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
						inc rx;
						if(inc x < width){
							inc usedX;
							jmp xLoop;
						}
					}
					tx -= usedY;
				}
				if(inc y < height){
					inc pixelRCurrentCopy;
					inc pixelGCurrentCopy;
					inc pixelBCurrentCopy;
					jmp yLoop;
				}
			}
			if(txCopy == destinationData){
				tx = intermediateData;
				txCopy = tx;
				rx = destinationData;
				jmp loop;
			}
		}
	}
	free(intermediateData);
	free(kernelColumnRStart);
	free(kernelColumnGStart);
	free(kernelColumnBStart);
	free(pixelRStart);
	free(pixelGStart);
	free(pixelBStart);
	ret;
}
ROTATEIMAGE(){
	const int oldWidth = (*image).width;
	const int oldHeight = (*image).height;
	const int oldSize = (*image).size;
	uint32 *newData;
	uint32 newDataToken;
	uint32 *current = (*image).dataStart;
	uint32 *const yWall = (void *)((uint8 *)current + oldSize);
	uint32 *xWall = current + oldWidth;
	int newWidth;
	int newHeight;
	uint32 *newDataCurrent;
	int newDataNextX;
	int newDataNextY;
	if(!rotation){
		ret true;
	}
	newData = malloc(oldSize * sizeof(uint8));
	newDataToken = pushPointer(newData, "rotateImage() new data pointer", iFree);
	if(!newData){
		printTitledError("memory allocation error", "could not allocate rotated image color data");
		ret false;
	}
	switch rotation over
		to DEGREE_90_ROTATION: /*--*/ jmp rotate90Degrees;
		to DEGREE_180_ROTATION: /*-*/ jmp rotate180Degrees;
		to DEGREE_270_ROTATION: /*-*/ jmp rotate270Degrees;
		off: /*--------------------*/ ret false;
	end
	rotate90Degrees:{
		newWidth = oldHeight;
		newHeight = oldWidth;
		newDataCurrent = newData + newWidth - 1;
		newDataNextX = newWidth;
		newDataNextY = -newHeight * newWidth - 1;
		jmp copyYAxisLoop;
	}
	rotate180Degrees:{
		newWidth = oldWidth;
		newHeight = oldHeight;
		newDataCurrent = newData + newHeight * newWidth - 1;
		newDataNextX = -1;
		newDataNextY = 0;
		jmp copyYAxisLoop;
	}
	rotate270Degrees:{
		newWidth = oldHeight;
		newHeight = oldWidth;
		newDataCurrent = newData + newHeight * newWidth - newWidth;
		newDataNextX = -newWidth;
		newDataNextY = newHeight * newWidth + 1;
		jmp copyYAxisLoop;
	}
	copyYAxisLoop:{
		if(current < yWall){
			jmp copyXAxisLoop;
			copyXAxisLoop:{
				if(current < xWall){
					*newDataCurrent = *current;
					newDataCurrent += newDataNextX;
					inc current;
					jmp copyXAxisLoop;
				}
				newDataCurrent += newDataNextY;
				xWall += oldWidth;
				jmp copyYAxisLoop;
			}
		}
		jmp success;
	}
	success:{
		if(deletePreviousData){
			free((*image).dataStart);
			popPointer((*image).dataToken);
		}
		(*image).dataStart = newData;
		(*image).dataToken = newDataToken;
		(*image).width = newWidth;
		(*image).height = newHeight;
		ret true;
	}
}
FILLDRAWABLE(){
	xcb_rectangle_t rectangle;
	rectangle.x = x;
	rectangle.y = y;
	rectangle.width = width;
	rectangle.height = height;
	xcb_change_gc(connection, gc, XCB_GC_FOREGROUND, &color);
	xcb_poly_fill_rectangle(connection, drawable, gc, 1, &rectangle);
	ret;
}
RESTARTCOMMAND(){
	if(!isInsideConfig){
		shmDisconnect();
	}
	freeConfigVariables();
	setConfigVariables();
	ungrabShortcuts();
	unsetShortcutRoot(&buttonShortcut);
	setShortcutRoot(&buttonShortcut);
	unsetShortcutRoot(&keycodeShortcut);
	setShortcutRoot(&keycodeShortcut);
	ret;
}
EXITCOMMAND(){
	free(event);
	popPointer(eventToken);
	shmDisconnect();
	cancelThreads();
	freeConfigVariables();
	ungrabShortcuts();
	freeMonitors();
	if(ic){
		XDestroyIC(ic);
	}
	if(im){
		XCloseIM(im);
	}
	if(connectionToken){
		xcb_ungrab_keyboard(connection, getTimestamp());
		xcb_disconnect(connection);
		popPointer(connectionToken);
	}
	if(display){
		XCloseDisplay(display);
		popPointer(displayToken);
	}
	deleteASCIIStringRoot(&asciiRoot);
	unsetShortcutRoot(&buttonShortcut);
	unsetShortcutRoot(&keycodeShortcut);



	/*!*/

	deleteStringRoot(&cornerRoot);
	deleteStringRoot(&whichMonitorRoot);
	deleteStringRoot(&numberTypeRoot);
	deleteStringRoot(&verticalAlignmentRoot);
	deleteStringRoot(&horizontalAlignmentRoot);



	deleteStringRoot(&macroRoot);
	deleteStringRoot(&modifierRoot);
	deleteStringRoot(&variableRoot);
	deleteStringRoot(&commandRoot);
	deleteStringRoot(&booleanRoot);
	deleteStringRoot(&scope1ScopeInstructionRoot);
	deleteStringRoot(&globalInstructionRoot);
	deleteStringRoot(&globalScopesInstructionRoot);
	if(dynamicDataSegment.allocated > 1){
		printError("%s%s: %s%s:%s %s", colorStart, programName, colorError, "warning", colorEnd, "program exited with unaccounted for data pointers, namely:\n");
		printUnaccountedForPointers(dynamicDataSegment.data + 1, dynamicDataSegment.data + dynamicDataSegment.allocated);
	}
	deleteMemoryManager();
	closeErrorStream();
	exit(EXIT_SUCCESS);
}
CANCELTHREADS(){
	if(globalsLockCreated){
		if(pthread_rwlock_destroy(&globalsLock) != PTHREAD_RWLOCK_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy globals lock");
		}
		globalsLockCreated = false;
	}
	ret;
}
FREEMONITORS(){
	free(monitorStart);
	popPointer(monitorToken);
	monitorStart = NULL;
	monitorToken = 0;
	ret;
}
PRINTUNACCOUNTEDFORPOINTERS(){
	if(current < wall){
		jmp printPointedVariablesLoop;
		printPointedVariablesLoop:{
			if((*current).data){
				labelExamined = (*current).label;
				printError("\t%s: line %u: %s\n", (*current).file, (*current).line, labelExamined);
			}
			if(inc current < wall){
				jmp printPointedVariablesLoop;
			}
		}
	}
	ret;
}
PRINTERROR(){
	if(openErrorStream()){
		va_list arguments;
		va_start(arguments, message);
		flockfile(errorStream);
		vfprintf(errorStream, message, arguments);
		funlockfile(errorStream);
		va_end(arguments);
		closeErrorStream();
	}
	ret;
}
PRINTTITLEDERROR(){
	printError("%s%s: %s%s:%s %s\n", colorStart, programName, colorError, title, colorEnd, message);
	ret;
}
PRINTTITLEDQUOTEDERROR(){
	printError("%s%s: %s%s:%s \"%s\" %s\n", colorStart, programName, colorError, title, colorEnd, argument, message);
	ret;
}
PRINTCONNECTIONERROR(){
	const char *string;
	jmp findConnectionError;
	findConnectionError: switch xcb_connection_has_error(connection) over
		to XCB_CONN_ERROR: /*-------------------*/ string = "socket/pipe/stream error"; /*------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_EXT_NOTSUPPORTED: /*-*/ string = "extension not supported"; /*-------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_MEM_INSUFFICIENT: /*-*/ string = "insufficient memory"; /*-----------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_REQ_LEN_EXCEED: /*---*/ string = "exceeded request length"; /*-------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_PARSE_ERR: /*--------*/ string = "error parsing display string"; /*--*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_INVALID_SCREEN: /*---*/ string = "screen-display mismatch"; /*-------*/ jmp printConnectionError;
		off: /*---------------------------------*/ string = "unrecognized connection error"; /*-*/ jmp printConnectionError;
	end
	printConnectionError:{
		printTitledError("fatal X server error", string);
		ret;
	}
}
PRINTTITLEDNAMEDERROR(){
	printError("%s%s: %s%s:%s %s %s\n", colorStart, programName, colorError, title, colorEnd, message, name);
	ret;
}
PRINTXERROR(){
	#define useErrorName(n0, n1) /*--------------*/ n0 == n1? *(n1 + ((*error).error_code >= countof(n1)? countof(n1) - 1 : (*error).error_code))
	#define useErrorOperationName(n0, n1, n2) /*-*/ n0 == n1? *(n2 + ((*error).major_code >= countof(n2)? countof(n2) - 1 : (*error).major_code))
	const xcb_generic_error_t *const error = (void *)event;
	printError("%s%s: %sX error event:%s %s error in %s operation using the 0x%x resource\n", colorStart, programName, colorError, colorEnd
		, useErrorName(name, errorName)
		: useErrorName(name, randrErrorName)
		: "unrecognized"
		, useErrorOperationName(name, errorName, operationName)
		: useErrorOperationName(name, randrErrorName, randrOperationName)
		: "unrecognized"
	, (*error).resource_id);
	ret;
	#undef  useErrorOperationName
	#undef  useErrorName
}
PRINTTITLEDVALUEDERROR(){
	printError("%s%s: %s%s:%s %s %u\n", colorStart, programName, colorError, title, colorEnd, message, value);
	ret;
}
PRINTCONFIGERROR(){
	const char *statementCurrent = statementStart;
	const uint itemAmountWall = instructionCurrent - instructionStart;
	uint itemAmount = 0;
	uint spaceAmount = 0;
	StringNodeRoot *const *data;
	if(!openErrorStream()){
		ret;
	}
	flockfile(errorStream);
	fprintf(errorStream, "%s%s: %s: ", colorStart, programName, configPath);
	if(printLine){
		fprintf(errorStream, "line %u: ", statementLine);
	}
	fprintf(errorStream, "%s%s:%s %s", colorError, type, colorEnd, message);
	if(printConfig){
		fprintf(errorStream, ":\n\t config |");
	}else{
		fprintf(errorStream, "\n");
		jmp emergencyExit;
	}
	jmp printStatementItemLoop;
	printStatementItemLoop:{
		if(statementCurrent < statementWall){
			fprintf(errorStream, " %s", statementCurrent);
			jmp pushOutTermLoop;
			pushOutTermLoop:{
				if(*(inc statementCurrent)){
					jmp pushOutTermLoop;
				}
				inc statementCurrent;
			}
			if(itemAmount == itemAmountWall and instructionStart){
				spaceAmount = statementCurrent - statementStart;
			}
			inc itemAmount;
			jmp printStatementItemLoop;
		}
		if(spaceAmount == 0 and finalStatementCharacter != ';'){
			fprintf(errorStream, " ");
		}
		fprintf(errorStream, "%c\n", finalStatementCharacter);
		jmp printPattern;
	}
	printPattern:{
		if(printPointer){
			if(spaceAmount == statementCurrent - statementStart){
				dec spaceAmount;
			}
			fprintf(errorStream, "\t        |%*c^\n", inc spaceAmount, ' ');
		}
		if(!printPattern or !instructionStart){
			fprintf(errorStream, "\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, "\n\tpattern | %s", *(currentScopeInstructionList + (*currentScopeInstructionRoot).returnedCounter));
		dec instructionStart;
		data = instructionDataStart;
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoop: switch *(inc instructionStart) over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
		to EXECUTE_INSTRUCTION_TYPE: /*---*/ jmp executeInstruction;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
		off: /*----------------------*/ jmp printInstructionParameterLoopExit;
	end
	noneInstruction:{
		fprintf(errorStream, " <unimplemented>");
		jmp printInstructionParameterLoopExit;
	}
	nameInstruction:{
		const char *const *stringArray;
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " name");
			jmp printInstructionParameterLoop;
		}
		stringArray = (**data).stringArray;
		fprintf(errorStream, " (%s", *stringArray);
		inc stringArray;
		printNameLoop:{
			if(*stringArray){
				fprintf(errorStream, "|%s", *stringArray);
				inc stringArray;
				jmp printNameLoop;
			}
		}
		fprintf(errorStream, ")");
		inc data;
		jmp printInstructionParameterLoop;
	}
	nameListInstruction:{
		const char *const *stringArray;
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " list");
			jmp printInstructionParameterLoop;
		}
		stringArray = (**data).stringArray;
		fprintf(errorStream, " ((%s", *stringArray);
		inc stringArray;
		printNameListOnceLoop:{
			if(*stringArray){
				fprintf(errorStream, "|%s", *stringArray);
				inc stringArray;
				jmp printNameListOnceLoop;
			}
		}
		stringArray = (**data).stringArray;
		fprintf(errorStream, ")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
		inc stringArray;
		printNameListTwiceLoop:{
			if(*stringArray){
				fprintf(errorStream, "|%s", *stringArray);
				inc stringArray;
				jmp printNameListTwiceLoop;
			}
		}
		fprintf(errorStream, "))*(?![\\s]*[|]))");
		inc data;
		jmp printInstructionParameterLoop;
	}
	numberInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " number");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
		jmp printInstructionParameterLoop;
	}
	stringInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " string");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	executeInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " execute");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	imageInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " image");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	printTilde:{
		fprintf(errorStream, " ~");
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoopExit:{
		if(displaySimpleConfigErrors){
			fprintf(errorStream, "\n\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, " $\n\n");
		jmp emergencyExit;
	}
	emergencyExit:{
		funlockfile(errorStream);
		closeErrorStream();
		ret;
	}
}
OPENERRORSTREAM(){
	if(!mustOpenErrorStream){
		ret true;
	}
	errorStream = fopen(errorPath, "a");
	errorStreamToken = pushPointer(errorStream, "error stream", fclose);
	if(errorStream){
		ret true;
	}
	mustOpenErrorStream = false;
	errorStream = DEFAULT_ERROR_STREAM;
	colorStart = MESSAGE_START;
	colorFatal = MESSAGE_FATAL;
	colorError = MESSAGE_ERROR;
	colorEvent = MESSAGE_EVENT;
	colorEnd = MESSAGE_END;
	printTitledError("stream error", "could not open error file, reverting to the default error stream");
	ret true;
}
CLOSEERRORSTREAM(){
	if(mustOpenErrorStream and errorStream){
		fclose(errorStream);
		popPointer(errorStreamToken);
		errorStreamToken = 0;
	}
	ret;
}
